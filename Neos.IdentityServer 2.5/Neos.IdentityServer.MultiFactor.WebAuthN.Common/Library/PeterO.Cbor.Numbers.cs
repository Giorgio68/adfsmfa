using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Neos.IdentityServer.MultiFactor.WebAuthN.Library.Cbor
{
    internal static class BigNumberFlags
    {
        internal const int FlagNegative = 1;
        internal const int FlagQuietNaN = 4;
        internal const int FlagSignalingNaN = 8;
        internal const int FlagInfinity = 2;
        internal const int FlagSpecial = FlagQuietNaN | FlagSignalingNaN |
        FlagInfinity;

        internal const int FlagNaN = FlagQuietNaN | FlagSignalingNaN;
        internal const int UnderflowFlags = EContext.FlagInexact |
        EContext.FlagSubnormal | EContext.FlagUnderflow | EContext.FlagRounded;

        internal const int LostDigitsFlags = EContext.FlagLostDigits |
        EContext.FlagInexact | EContext.FlagRounded;

        internal const int FiniteOnly = 0;
        internal const int FiniteAndNonFinite = 1;
    }

    internal sealed class BitShiftAccumulator : IShiftAccumulator
    {
        private const int SmallBitLength = 32;
        private int bitLeftmost;

        public int LastDiscardedDigit
        {
            get
            {
                return this.bitLeftmost;
            }
        }

        private int bitsAfterLeftmost;

        public int OlderDiscardedDigits
        {
            get
            {
                return this.bitsAfterLeftmost;
            }
        }

        private EInteger shiftedBigInt;
        private FastInteger knownBitLength;

        public FastInteger GetDigitLength()
        {
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            return FastInteger.CopyFrozen(this.knownBitLength);
        }

        private void VerifyKnownLength()
        {
#if DEBUG
            if (this.knownBitLength != null)
            {
                if (this.knownBitLength.CompareTo(this.CalcKnownBitLength()) != 0)
                {
                    string msg = "*****" +
                      this + "\n*****expected " + this.CalcKnownBitLength() +
                      "\n" + "*****kdl=" + this.knownBitLength;
                    throw new InvalidOperationException(msg);
                }
            }
#endif
        }

        public void ShiftToDigits(
      FastInteger bits,
      FastInteger preShift,
      bool truncate)
        {
            if (bits.Sign < 0)
            {
                throw new ArgumentException("bits's sign (" + bits.Sign +
                  ") is less than 0");
            }
            if (preShift != null && preShift.Sign > 0)
            {
                this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
                // DebugUtility.Log("bits=" + bits + " pre=" + preShift + " known=" +
                // (//kbl) + " [" + this.shiftedBigInt + "]");
                if (this.knownBitLength.CompareTo(bits) <= 0)
                {
                    // Known digit length is already small enough
                    if (truncate)
                    {
                        this.TruncateRight(preShift);
                    }
                    else
                    {
                        this.ShiftRight(preShift);
                    }
                    this.VerifyKnownLength();
                    return;
                }
                else
                {
                    FastInteger bitDiff = this.knownBitLength.Copy()
                      .Subtract(bits);
                    // DebugUtility.Log("bitDiff=" + bitDiff);
                    int cmp = bitDiff.CompareTo(preShift);
                    if (cmp <= 0)
                    {
                        // Difference between desired digit length and current
                        // length is smaller than the shift, make it the shift
                        if (truncate)
                        {
                            this.TruncateRight(preShift);
                        }
                        else
                        {
                            this.ShiftRight(preShift);
                        }
                        this.VerifyKnownLength();
                        return;
                    }
                    else
                    {
                        if (truncate)
                        {
                            this.TruncateRight(bitDiff);
                        }
                        else
                        {
                            this.ShiftRight(bitDiff);
                        }
                        this.VerifyKnownLength();
                        return;
                    }
                }
            }
            if (bits.CanFitInInt32())
            {
                this.ShiftToDigitsInt(bits.AsInt32());
                this.VerifyKnownLength();
            }
            else
            {
                this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
                EInteger bigintDiff = this.knownBitLength.AsEInteger();
                EInteger bitsBig = bits.AsEInteger();
                bigintDiff -= (EInteger)bitsBig;
                if (bigintDiff.Sign > 0)
                {
                    // current length is greater than the
                    // desired bit length
                    this.ShiftRight(FastInteger.FromBig(bigintDiff));
                }
                this.VerifyKnownLength();
            }
        }

        private int shiftedSmall;
        private bool isSmall;

        public EInteger ShiftedInt
        {
            get
            {
                return this.isSmall ? ((EInteger)this.shiftedSmall) :
                this.shiftedBigInt;
            }
        }

        public FastInteger ShiftedIntFast
        {
            get
            {
                return this.isSmall ? (new FastInteger(this.shiftedSmall)) :
                FastInteger.FromBig(this.shiftedBigInt);
            }
        }

        private FastInteger discardedBitCount;

        public FastInteger DiscardedDigitCount
        {
            get
            {
                return this.discardedBitCount;
            }
        }

        public BitShiftAccumulator(
      EInteger bigint,
      int lastDiscarded,
      int olderDiscarded)
        {
            if (bigint.Sign < 0)
            {
                throw new ArgumentException("bigint's sign (" + bigint.Sign +
                  ") is less than 0");
            }
            if (bigint.CanFitInInt32())
            {
                this.isSmall = true;
                this.shiftedSmall = (int)bigint;
            }
            else
            {
                this.shiftedBigInt = bigint;
            }
            this.discardedBitCount = new FastInteger(0);
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = (lastDiscarded != 0) ? 1 : 0;
        }

        public BitShiftAccumulator(
      int smallint,
      int lastDiscarded,
      int olderDiscarded)
        {
            this.shiftedSmall = smallint;
            if (this.shiftedSmall < 0)
            {
                throw new ArgumentException("shiftedSmall (" + this.shiftedSmall +
                  ") is less than 0");
            }
            this.isSmall = true;
            this.discardedBitCount = new FastInteger(0);
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = (lastDiscarded != 0) ? 1 : 0;
        }

        public static BitShiftAccumulator FromInt32(int smallNumber)
        {
            if (smallNumber < 0)
            {
                throw new ArgumentException("smallNumber (" + smallNumber +
                  ") is less than 0");
            }
            BitShiftAccumulator bsa = new BitShiftAccumulator(EInteger.Zero, 0, 0)
            {
                shiftedSmall = smallNumber,
                discardedBitCount = new FastInteger(0),
                isSmall = true
            };
            return bsa;
        }

        public void TruncateRight(FastInteger fastint)
        {
            this.ShiftRight(fastint);
        }

        public void ShiftRight(FastInteger fastint)
        {
            if (fastint.Sign <= 0)
            {
                return;
            }
            if (fastint.CanFitInInt32())
            {
                this.ShiftRightInt(fastint.AsInt32());
            }
            else
            {
                EInteger bi = fastint.AsEInteger();
                while (bi.Sign > 0)
                {
                    int count = 1000000;
                    if (bi.CompareTo((EInteger)1000000) < 0)
                    {
                        count = (int)bi;
                    }
                    this.ShiftRightInt(count);
                    bi -= (EInteger)count;
                    if (this.isSmall ? this.shiftedSmall == 0 :
                    this.shiftedBigInt.IsZero)
                    {
                        break;
                    }
                }
            }
        }

        private void ShiftRightBig(int bits)
        {
            if (bits <= 0)
            {
                return;
            }
            if (this.shiftedBigInt.IsZero)
            {
                this.discardedBitCount.AddInt(bits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.isSmall = true;
                this.shiftedSmall = 0;
                this.knownBitLength = new FastInteger(1);
                return;
            }
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            this.discardedBitCount.AddInt(bits);
            int cmp = this.knownBitLength.CompareToInt(bits);
            if (cmp < 0)
            {
                // too few bits
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitsAfterLeftmost |= this.shiftedBigInt.IsZero ? 0 : 1;
                this.bitLeftmost = 0;
                this.isSmall = true;
                this.shiftedSmall = 0;
                this.knownBitLength = new FastInteger(1);
            }
            else
            {
                // enough bits in the current value
                int bs = bits;
                this.knownBitLength.SubtractInt(bits);
                if (bs == 1)
                {
                    bool odd = !this.shiftedBigInt.IsEven;
                    this.shiftedBigInt >>= 1;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = odd ? 1 : 0;
                }
                else
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    int lowestSetBit = this.shiftedBigInt.GetLowBit();
                    if (lowestSetBit < bs - 1)
                    {
                        // One of the discarded bits after
                        // the last one is set
                        this.bitsAfterLeftmost |= 1;
                        this.bitLeftmost = this.shiftedBigInt.GetSignedBit(bs - 1) ? 1 : 0;
                    }
                    else if (lowestSetBit > bs - 1)
                    {
                        // Means all discarded bits are zero
                        this.bitLeftmost = 0;
                    }
                    else
                    {
                        // Only the last discarded bit is set
                        this.bitLeftmost = 1;
                    }
                    this.shiftedBigInt >>= bs;
                }
                if (this.knownBitLength.CompareToInt(SmallBitLength) < 0)
                {
                    // Shifting to small number of bits,
                    // convert to small integer
                    this.isSmall = true;
                    this.shiftedSmall = (int)this.shiftedBigInt;
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
        }

        private FastInteger CalcKnownBitLength()
        {
            if (this.isSmall)
            {
                int kb = SmallBitLength;
                for (int i = SmallBitLength - 1; i >= 0; --i)
                {
                    if ((this.shiftedSmall & (1 << i)) != 0)
                    {
                        break;
                    }
                    --kb;
                }
                // Make sure bit length is 1 if value is 0
                if (kb == 0)
                {
                    ++kb;
                }
                // Console.WriteLine("{0:X8} kbl=" + kb);
                return new FastInteger(kb);
            }
            return new FastInteger(this.shiftedBigInt.IsZero ? 1 :
            this.shiftedBigInt.GetSignedBitLength());
        }

        private void ShiftBigToBits(int bits)
        {
            // Shifts a number until it reaches the given number of bits,
            // gathering information on whether the last bit discarded is set and
            // whether the discarded bits to the right of that bit are set. Assumes
            // that the big integer being shifted is positive.
            if (this.knownBitLength != null)
            {
                if (this.knownBitLength.CompareToInt(bits) <= 0)
                {
                    return;
                }
            }
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            if (this.knownBitLength.CompareToInt(bits) <= 0)
            {
                return;
            }
            // Shift by the difference in bit length
            if (this.knownBitLength.CompareToInt(bits) > 0)
            {
                int bs = 0;
                if (this.knownBitLength.CanFitInInt32())
                {
                    bs = this.knownBitLength.AsInt32();
                    bs -= bits;
                }
                else
                {
                    FastInteger bitShift =
                    this.knownBitLength.Copy().SubtractInt(bits);
                    if (!bitShift.CanFitInInt32())
                    {
                        this.ShiftRight(bitShift);
                        return;
                    }
                    bs = bitShift.AsInt32();
                }
                this.knownBitLength.SetInt(bits);
                this.discardedBitCount.AddInt(bs);
                if (bs == 1)
                {
                    bool odd = !this.shiftedBigInt.IsEven;
                    this.shiftedBigInt >>= 1;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = odd ? 1 : 0;
                }
                else
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    int lowestSetBit = this.shiftedBigInt.GetLowBit();
                    if (lowestSetBit < bs - 1)
                    {
                        // One of the discarded bits after
                        // the last one is set
                        this.bitsAfterLeftmost |= 1;
                        this.bitLeftmost = this.shiftedBigInt.GetSignedBit(bs - 1) ? 1 : 0;
                    }
                    else if (lowestSetBit > bs - 1)
                    {
                        // Means all discarded bits are zero
                        this.bitLeftmost = 0;
                    }
                    else
                    {
                        // Only the last discarded bit is set
                        this.bitLeftmost = 1;
                    }
                    this.shiftedBigInt >>= bs;
                }
                if (bits < SmallBitLength)
                {
                    // Shifting to small number of bits,
                    // convert to small integer
                    this.isSmall = true;
                    this.shiftedSmall = (int)this.shiftedBigInt;
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
        }

        public void ShiftRightInt(int bits)
        {
            // <summary>Shifts a number to the right, gathering information on
            // whether the last bit discarded is set and whether the discarded
            // bits to the right of that bit are set. Assumes that the big integer
            // being shifted is positive.</summary>
            if (this.isSmall)
            {
                this.ShiftRightSmall(bits);
            }
            else
            {
                this.ShiftRightBig(bits);
            }
        }

        private void ShiftRightSmall(int bits)
        {
            if (bits <= 0)
            {
                return;
            }
            if (this.shiftedSmall == 0)
            {
                this.discardedBitCount.AddInt(bits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownBitLength = new FastInteger(1);
                return;
            }
            int kb = SmallBitLength;
            for (int i = SmallBitLength - 1; i >= 0; --i)
            {
                if ((this.shiftedSmall & (1 << i)) != 0)
                {
                    break;
                }
                --kb;
            }
            int shift = (int)Math.Min(kb, bits);
            bool shiftingMoreBits = bits > kb;
            kb -= shift;
            this.knownBitLength = new FastInteger(kb);
            this.discardedBitCount.AddInt(bits);
            this.bitsAfterLeftmost |= this.bitLeftmost;
            // Get the bottommost shift minus 1 bits
            this.bitsAfterLeftmost |= (shift > 1 && (this.shiftedSmall <<
            (SmallBitLength - shift + 1)) != 0) ? 1 : 0;
            // Get the bit just above that bit
            this.bitLeftmost = (int)((this.shiftedSmall >> (shift - 1)) & 0x01);
            this.shiftedSmall >>= shift;
            if (shiftingMoreBits)
            {
                // Shifted more bits than the bit length
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
            }
            this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
        }

        public void ShiftToDigitsInt(int bits)
        {
            if (bits < 0)
            {
                throw new ArgumentException("bits (" + bits + ") is less than 0");
            }
            if (this.isSmall)
            {
                this.ShiftSmallToBits(bits);
            }
            else
            {
                this.ShiftBigToBits(bits);
            }
        }

        private void ShiftSmallToBits(int bits)
        {
            if (this.knownBitLength != null)
            {
                if (this.knownBitLength.CompareToInt(bits) <= 0)
                {
                    return;
                }
            }
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            if (this.knownBitLength.CompareToInt(bits) <= 0)
            {
                return;
            }
            int kbl = this.knownBitLength.AsInt32();
            // Shift by the difference in bit length
            if (kbl > bits)
            {
                int bitShift = kbl - (int)bits;
                int shift = (int)bitShift;
                this.knownBitLength = new FastInteger(bits);
                this.discardedBitCount.AddInt(bitShift);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                // Get the bottommost shift minus 1 bits
                this.bitsAfterLeftmost |= (shift > 1 && (this.shiftedSmall <<
                (SmallBitLength - shift + 1)) != 0) ? 1 : 0;
                // Get the bit just above that bit
                this.bitLeftmost = (int)((this.shiftedSmall >> (shift - 1)) & 0x01);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                this.shiftedSmall >>= shift;
            }
            else
            {
                this.knownBitLength = new FastInteger(kbl);
            }
        }
    }

    internal sealed class DigitShiftAccumulator : IShiftAccumulator
    {
        private static readonly long[] TenPowersLong = {
      1L, 10L, 100L, 1000L, 10000L, 100000L,
      1000000L, 10000000L, 100000000L,
      1000000000L,
      10000000000L,
      100000000000L,
      1000000000000L,
      10000000000000L,
      100000000000000L,
      1000000000000000L,
      10000000000000000L,
      100000000000000000L,
      1000000000000000000L,
    };

        private static readonly EInteger ValueTen = (EInteger)10;

        private static readonly int[] ValueTenPowers = {
      1, 10, 100, 1000, 10000, 100000,
      1000000, 10000000, 100000000
    };

        private int bitLeftmost;

        private int bitsAfterLeftmost;
        private FastInteger discardedBitCount;
        private bool isSmall;
        private FastInteger knownDigitLength;

        private EInteger shiftedBigInt;

        private int shiftedSmall;

        public override string ToString()
        {
            return "[this.bitLeftmost=" + this.bitLeftmost +
             ", this.bitsAfterLeftmost=" + this.bitsAfterLeftmost +
             ", this.discardedBitCount=" + this.discardedBitCount +
             ", this.isSmall=" + this.isSmall + ", this.knownDigitLength=" +
               this.knownDigitLength + ", this.shiftedBigInt=" +
               this.shiftedBigInt + ", this.shiftedSmall=" +
             this.shiftedSmall + "]";
        }

        public DigitShiftAccumulator(
      EInteger bigint,
      int lastDiscarded,
      int olderDiscarded)
        {
            if (bigint.CanFitInInt32())
            {
                this.shiftedSmall = (int)bigint;
                if (this.shiftedSmall < 0)
                {
                    throw new ArgumentException("shiftedSmall (" + this.shiftedSmall +
                      ") is less than 0");
                }
                this.isSmall = true;
            }
            else
            {
                this.shiftedBigInt = bigint;
                this.isSmall = false;
            }
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = lastDiscarded;
        }

        public DigitShiftAccumulator(
      int smallint,
      int lastDiscarded,
      int olderDiscarded)
        {
            this.shiftedSmall = smallint;
            if (this.shiftedSmall < 0)
            {
                throw new ArgumentException("shiftedSmall (" + this.shiftedSmall +
                  ") is less than 0");
            }
            this.isSmall = true;
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = lastDiscarded;
        }

        public FastInteger DiscardedDigitCount
        {
            get
            {
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                return this.discardedBitCount;
            }
        }

        public int LastDiscardedDigit
        {
            get
            {
                return this.bitLeftmost;
            }
        }

        public int OlderDiscardedDigits
        {
            get
            {
                return this.bitsAfterLeftmost;
            }
        }

        public EInteger ShiftedInt
        {
            get
            {
                return this.isSmall ? ((EInteger)this.shiftedSmall) :
                this.shiftedBigInt;
            }
        }

        public FastInteger ShiftedIntFast
        {
            get
            {
                return this.isSmall ? (new FastInteger(this.shiftedSmall)) :
                FastInteger.FromBig(this.shiftedBigInt);
            }
        }

        public FastInteger GetDigitLength()
        {
            this.knownDigitLength = this.knownDigitLength ??
                  this.CalcKnownDigitLength();
            return this.knownDigitLength;
        }

        public void ShiftRight(FastInteger fastint)
        {
            if (fastint == null)
            {
                throw new ArgumentNullException(nameof(fastint));
            }
            if (fastint.CanFitInInt32())
            {
                int fi = fastint.AsInt32();
                if (fi < 0)
                {
                    return;
                }
                this.ShiftRightInt(fi);
            }
            else
            {
                if (fastint.Sign <= 0)
                {
                    return;
                }
                EInteger bi = fastint.AsEInteger();
                while (bi.Sign > 0)
                {
                    int count = 1000000;
                    if (bi.CompareTo((EInteger)1000000) < 0)
                    {
                        count = (int)bi;
                    }
                    this.ShiftRightInt(count);
                    bi -= (EInteger)count;
                    if (this.isSmall ? this.shiftedSmall == 0 :
                    this.shiftedBigInt.IsZero)
                    {
                        break;
                    }
                }
            }
        }

        public void ShiftRightInt(int digits)
        {
            // <summary>Shifts a number to the right, gathering information on
            // whether the last digit discarded is set and whether the discarded
            // digits to the right of that digit are set. Assumes that the big
            // integer being shifted is positive.</summary>
            if (this.isSmall)
            {
                this.ShiftRightSmall(digits);
            }
            else
            {
                this.ShiftRightBig(digits, false);
            }
        }

        public void ShiftToDigits(
      FastInteger bits,
      FastInteger preShift,
      bool truncate)
        {
#if DEBUG
            if (bits.Sign < 0)
            {
                throw new ArgumentException("bits's sign (" + bits.Sign +
                  ") is less than 0");
            }
#endif
            if (preShift != null && preShift.Sign > 0)
            {
                FastInteger kdl = this.knownDigitLength ?? this.CalcKnownDigitLength();
                this.knownDigitLength = kdl;
                // DebugUtility.Log("bits=" + bits + " pre=" + preShift + " known=" +
                // (//kdl) + " [" + this.shiftedBigInt + "]");
                if (kdl.CompareTo(bits) <= 0)
                {
                    // Known digit length is already small enough
                    if (truncate)
                    {
                        this.TruncateRight(preShift);
                    }
                    else
                    {
                        this.ShiftRight(preShift);
                    }
                    this.VerifyKnownLength();
                    return;
                }
                else
                {
                    FastInteger bitDiff = kdl.Copy().Subtract(bits);
                    // DebugUtility.Log("bitDiff=" + bitDiff);
                    int cmp = bitDiff.CompareTo(preShift);
                    if (cmp <= 0)
                    {
                        // Difference between desired digit length and current
                        // length is smaller than the shift, make it the shift
                        if (truncate)
                        {
                            this.TruncateRight(preShift);
                        }
                        else
                        {
                            this.ShiftRight(preShift);
                        }
                        this.VerifyKnownLength();
                        return;
                    }
                    else
                    {
                        if (truncate)
                        {
                            this.TruncateRight(bitDiff);
                        }
                        else
                        {
                            this.ShiftRight(bitDiff);
                        }
                        this.VerifyKnownLength();
                        return;
                    }
                }
            }
            if (bits.CanFitInInt32())
            {
                int intval = bits.AsInt32();
                if (intval < 0)
                {
                    throw new ArgumentException("intval (" + intval + ") is less than " +
                             "0");
                }
                if (this.isSmall)
                {
                    this.ShiftToDigitsSmall(intval);
                }
                else
                {
                    this.ShiftToDigitsBig(intval, truncate);
                }
                this.VerifyKnownLength();
            }
            else
            {
                FastInteger kdl = this.knownDigitLength ?? this.CalcKnownDigitLength();
                this.knownDigitLength = kdl;
                this.VerifyKnownLength();
                EInteger bigintDiff = kdl.AsEInteger();
                EInteger bitsBig = bits.AsEInteger();
                bigintDiff -= (EInteger)bitsBig;
                if (bigintDiff.Sign > 0)
                {
                    // current length is greater than the
                    // desired bit length
                    this.ShiftRight(FastInteger.FromBig(bigintDiff));
                }
                this.VerifyKnownLength();
            }
        }

        public void TruncateRight(FastInteger fastint)
        {
            if (fastint == null)
            {
                throw new ArgumentNullException(nameof(fastint));
            }
            if (fastint.CanFitInInt32())
            {
                int fi = fastint.AsInt32();
                if (fi < 0)
                {
                    return;
                }
                if (!this.isSmall)
                {
                    if (this.shiftedBigInt.CanFitInInt64())
                    {
                        this.TruncateRightLong(this.shiftedBigInt.ToInt64Checked(), fi);
                    }
                    else
                    {
                        this.ShiftRightBig(fi, true);
                    }
                }
                else
                {
                    this.TruncateRightSmall(fi);
                }
            }
            else
            {
                this.ShiftRight(fastint);
            }
        }

        private static int FastParseLong(string str, int offset, int length)
        {
            // Assumes the string is length 9 or less and contains
            // only the digits '0' through '9'
            if (length > 9)
            {
                throw new ArgumentException("length (" + length + ") is more than " +
                       "9 ");
            }
            int ret = 0;
            for (int i = 0; i < length; ++i)
            {
                int digit = (int)(str[offset + i] - '0');
                ret *= 10;
                ret += digit;
            }
            return ret;
        }

        private static int LongDigitLength(long value)
        {
#if DEBUG
            if (!(value >= 0))
            {
                throw new ArgumentException("doesn't satisfy value>= 0");
            }
#endif
            if (value >= 1000000000L)
            {
                return (value >= 1000000000000000000L) ? 19 : ((value >=
                         100000000000000000L) ? 18 : ((value >= 10000000000000000L) ?
                          17 : ((value >= 1000000000000000L) ? 16 :
                          ((value >= 100000000000000L) ? 15 : ((value
                          >= 10000000000000L) ?
                          14 : ((value >= 1000000000000L) ? 13 : ((value
                          >= 100000000000L) ? 12 : ((value >= 10000000000L) ?
                          11 : ((value >= 1000000000L) ? 10 : 9)))))))));
            }
            else
            {
                int v2 = (int)value;
                return (v2 >= 100000000) ? 9 : ((v2 >= 10000000) ? 8 : ((v2 >=
                          1000000) ? 7 : ((v2 >= 100000) ? 6 : ((v2
                          >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ?
                          3 : ((v2 >= 10) ? 2 : 1)))))));
            }
        }

        private FastInteger CalcKnownDigitLength()
        {
            if (this.isSmall)
            {
                int kb = 0;
                int v2 = this.shiftedSmall;
                if (v2 < 100000)
                {
                    kb = (v2 >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ?
                    3 : ((v2 >= 10) ? 2 : 1)));
                }
                else
                {
                    kb = (v2 >= 1000000000) ? 10 : ((v2 >= 100000000) ? 9 : ((v2 >=
                    10000000) ? 8 : ((v2 >= 1000000) ? 7 : 6)));
                }
                return new FastInteger(kb);
            }
            return new FastInteger(this.shiftedBigInt.GetDigitCount());
        }

        private void VerifyKnownLength()
        {
            /*
            #if DEBUG
                  if (this.knownDigitLength != null) {
                    if (this.knownDigitLength.CompareTo(this.CalcKnownDigitLength()) != 0) {
                      throw new InvalidOperationException("*****"
                        +this+"\n*****expected " +this.CalcKnownDigitLength()+"\n" +
                         "*****kdl="+this.knownDigitLength);
                    }
                  }
            #endif
            */
        }

        private void UpdateKnownLengthInt(int digits)
        {
            if (this.knownDigitLength != null)
            {
                this.knownDigitLength.SubtractInt(digits);
                if (this.knownDigitLength.CompareToInt(1) < 0)
                {
                    this.knownDigitLength.SetInt(1);
                }
                this.VerifyKnownLength();
            }
        }

        private void UpdateKnownLength(FastInteger digitsFast)
        {
            if (this.knownDigitLength != null)
            {
                this.knownDigitLength.Subtract(digitsFast);
                if (this.knownDigitLength.CompareToInt(1) < 0)
                {
                    this.knownDigitLength.SetInt(1);
                }
                this.VerifyKnownLength();
            }
        }

        private void ShiftRightBig(int digits, bool truncate)
        {
            if (digits <= 0)
            {
                return;
            }
            if (this.shiftedBigInt.IsZero)
            {
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (truncate)
            {
                EInteger bigquo;
                if (digits > 50)
                {
                    // To avoid having to calculate a very big power of 10,
                    // check the digit count to see if doing so can be avoided
                    int bitLength = this.shiftedBigInt.GetUnsignedBitLength();
                    bool bigPower = false;
                    // 10^48 has 160 bits; 10^98 has 326; bit length is cheaper
                    // to calculate than base-10 digit length
                    if (bitLength < 160 || (digits > 100 && bitLength < 326))
                    {
                        bigPower = true;
                    }
                    else
                    {
                        FastInteger knownDigits = this.GetDigitLength();
                        bigPower = knownDigits.Copy().SubtractInt(digits)
                          .CompareToInt(-2) < 0;
                        if (!bigPower)
                        {
                            // DebugUtility.Log("digitlength {0} [todiscard: {1}]"
                            // , knownDigits, digits);
                        }
                    }
                    if (bigPower)
                    {
                        // Power of 10 to be divided would be much bigger
                        this.discardedBitCount = this.discardedBitCount ?? (new
                               FastInteger(0));
                        this.discardedBitCount.AddInt(digits);
                        this.bitsAfterLeftmost |= this.bitLeftmost;
                        this.bitsAfterLeftmost |= this.shiftedBigInt.IsZero ? 0 : 1;
                        this.bitLeftmost = 0;
                        this.knownDigitLength = new FastInteger(1);
                        this.isSmall = true;
                        this.shiftedSmall = 0;
                        return;
                    }
                }
                if (this.shiftedBigInt.IsEven && this.bitLeftmost == 0)
                {
                    EInteger[] quorem = this.shiftedBigInt.DivRem(
                    NumberUtility.FindPowerOfTen(digits));
                    bigquo = quorem[0];
                    this.bitLeftmost |= quorem[1].IsZero ? 0 : 1;
                }
                else
                {
                    this.bitLeftmost = 1;
                    bigquo = this.shiftedBigInt.Divide(
                    NumberUtility.FindPowerOfTen(digits));
                }
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.discardedBitCount = this.discardedBitCount == null ?
                   new FastInteger(digits) : this.discardedBitCount.AddInt(digits);
                if (bigquo.IsZero)
                {
                    // Shifted all the way to 0
                    this.isSmall = true;
                    this.shiftedBigInt = null;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                }
                else if (bigquo.CanFitInInt32())
                {
                    this.isSmall = true;
                    this.shiftedSmall = bigquo.ToInt32Unchecked();
                    this.shiftedBigInt = null;
                    this.UpdateKnownLengthInt(digits);
                }
                else
                {
                    this.isSmall = false;
                    this.shiftedBigInt = bigquo;
                    this.UpdateKnownLengthInt(digits);
                }
                return;
            }
            if (digits == 1)
            {
                EInteger bigrem;
                EInteger bigquo;
                EInteger[] divrem = this.shiftedBigInt.DivRem((EInteger)10);
                bigquo = divrem[0];
                bigrem = divrem[1];
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = (int)bigrem;
                this.shiftedBigInt = bigquo;
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.AddInt(digits);
                this.UpdateKnownLengthInt(digits);
                return;
            }
            if (digits >= 2 && digits <= 8)
            {
                EInteger bigrem;
                EInteger bigquo;
                EInteger[] divrem =
                  this.shiftedBigInt.DivRem(NumberUtility.FindPowerOfTen(digits));
                bigquo = divrem[0];
                bigrem = divrem[1];
                int intRem = (int)bigrem;
                int smallPower = ValueTenPowers[digits - 1];
                int leftBit = intRem / smallPower;
                int otherBits = intRem - (leftBit * smallPower);
                this.bitsAfterLeftmost |= otherBits | this.bitLeftmost;
                this.bitLeftmost = leftBit;
                this.shiftedBigInt = bigquo;
                this.discardedBitCount = (this.discardedBitCount != null) ?
                  this.discardedBitCount.AddInt(digits) : (new FastInteger(digits));
                this.UpdateKnownLengthInt(digits);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                if (this.shiftedBigInt.CanFitInInt32())
                {
                    this.isSmall = true;
                    this.shiftedSmall = this.shiftedBigInt.ToInt32Unchecked();
                    this.shiftedBigInt = null;
                }
                return;
            }
            this.knownDigitLength = this.knownDigitLength ??
                  this.CalcKnownDigitLength();
            if (new FastInteger(digits).Decrement().CompareTo(this.knownDigitLength)
            >= 0)
            {
                // Shifting more bits than available
                this.bitsAfterLeftmost |= this.shiftedBigInt.IsZero ? 0 : 1;
                this.isSmall = true;
                this.shiftedSmall = 0;
                this.knownDigitLength = new FastInteger(1);
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                return;
            }
            if (this.shiftedBigInt.CanFitInInt32())
            {
                this.isSmall = true;
                this.shiftedSmall = (int)this.shiftedBigInt;
                this.ShiftRightSmall(digits);
                return;
            }
            if (this.shiftedBigInt.CanFitInInt64())
            {
                this.ShiftRightLong(this.shiftedBigInt.ToInt64Unchecked(), digits);
                return;
            }
            string str = this.shiftedBigInt.ToString();
            // NOTE: Will be 1 if the value is 0
            int digitLength = str.Length;
            int bitDiff = 0;
            if (digits > digitLength)
            {
                bitDiff = digits - digitLength;
            }
            this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
            this.discardedBitCount.AddInt(digits);
            this.bitsAfterLeftmost |= this.bitLeftmost;
            int digitShift = Math.Min(digitLength, digits);
            if (digits >= digitLength)
            {
                this.isSmall = true;
                this.shiftedSmall = 0;
                this.knownDigitLength = new FastInteger(1);
            }
            else
            {
                int newLength = (int)(digitLength - digitShift);
                if (newLength <= 9)
                {
                    // Fits in a small number
                    this.isSmall = true;
                    this.shiftedSmall = FastParseLong(str, 0, newLength);
                }
                else
                {
                    this.shiftedBigInt = EInteger.FromSubstring(str, 0, newLength);
                }
                this.UpdateKnownLengthInt(digitShift);
            }
            for (int i = str.Length - 1; i >= 0; --i)
            {
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = (int)(str[i] - '0');
                --digitShift;
                if (digitShift <= 0)
                {
                    break;
                }
            }
            this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            if (bitDiff > 0)
            {
                // Shifted more digits than the digit length
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
            }
        }

        private void ShiftRightLong(long shiftedLong, int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (shiftedLong == 0)
            {
                this.shiftedSmall = 0;
                this.isSmall = true;
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (digits >= 2 && digits <= 8)
            {
                if (shiftedLong >= ValueTenPowers[digits])
                {
                    long bigPower = ValueTenPowers[digits];
                    long smallPower = ValueTenPowers[digits - 1];
                    this.discardedBitCount = this.discardedBitCount ?? (new
                        FastInteger(0));
                    this.discardedBitCount.AddInt(digits);
                    long div = shiftedLong / bigPower;
                    long rem = shiftedLong - (div * bigPower);
                    long rem2 = rem / smallPower;
                    this.bitLeftmost = (int)rem2;
                    this.bitsAfterLeftmost |= ((rem - (rem2 * smallPower)) == 0) ? 0 : 1;
                    this.isSmall = div <= Int32.MaxValue;
                    if (this.isSmall)
                    {
                        this.shiftedSmall = (int)div;
                        this.knownDigitLength = (div < 10) ? (new FastInteger(1)) :
                          new FastInteger(LongDigitLength(div));
                    }
                    else
                    {
                        this.shiftedBigInt = EInteger.FromInt64(div);
                        this.knownDigitLength = (div < 10) ? (new FastInteger(1)) :
                          this.CalcKnownDigitLength();
                    }
                    return;
                }
                else if (this.shiftedSmall >= ValueTenPowers[digits - 1])
                {
                    int smallPower = ValueTenPowers[digits - 1];
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    long rem = shiftedLong;
                    long rem2 = rem / smallPower;
                    this.bitLeftmost = (int)rem2;
                    this.bitsAfterLeftmost |= ((rem - (rem2 * smallPower)) == 0) ? 0 : 1;
                    this.isSmall = true;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
                else
                {
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    this.bitLeftmost = 0;
                    this.bitsAfterLeftmost |= (shiftedLong == 0) ? 0 : 1;
                    this.isSmall = true;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
            }
            this.knownDigitLength = new FastInteger(
              LongDigitLength(shiftedLong));
            if (this.discardedBitCount != null)
            {
                this.discardedBitCount.AddInt(digits);
            }
            else
            {
                this.discardedBitCount = new FastInteger(digits);
            }
            int digitsShifted = 0;
            while (digits > 0)
            {
                if (shiftedLong == 0)
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = 0;
                    break;
                }
                else
                {
                    long newShift = (shiftedLong < 43698) ? ((shiftedLong * 26215) >>
                        18) : (shiftedLong / 10);
                    int digit = (int)(shiftedLong - (newShift * 10));
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = digit;
                    --digits;
                    ++digitsShifted;
                    shiftedLong = newShift;
                }
            }
            this.isSmall = shiftedLong <= Int32.MaxValue;
            if (this.isSmall)
            {
                this.shiftedSmall = (int)shiftedLong;
            }
            else
            {
                this.shiftedBigInt = EInteger.FromInt64(shiftedLong);
            }
            this.UpdateKnownLengthInt(digitsShifted);
            this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
        }

        private void ShiftRightSmall(int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (this.shiftedSmall == 0)
            {
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (digits >= 2 && digits <= 8)
            {
                if (this.shiftedSmall >= ValueTenPowers[digits])
                {
                    int bigPower = ValueTenPowers[digits];
                    int smallPower = ValueTenPowers[digits - 1];
                    this.discardedBitCount = this.discardedBitCount ?? (new
                        FastInteger(0));
                    this.discardedBitCount.AddInt(digits);
                    int div = this.shiftedSmall / bigPower;
                    int rem = this.shiftedSmall - (div * bigPower);
                    int rem2 = rem / smallPower;
                    this.bitLeftmost = rem2;
                    this.bitsAfterLeftmost |= rem - (rem2 * smallPower);
                    this.shiftedSmall = div;
                    this.knownDigitLength = (div < 10) ? (new FastInteger(1)) :
                      this.CalcKnownDigitLength();
                    return;
                }
                else if (this.shiftedSmall >= ValueTenPowers[digits - 1])
                {
                    int smallPower = ValueTenPowers[digits - 1];
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    int rem = this.shiftedSmall;
                    int rem2 = rem / smallPower;
                    this.bitLeftmost = rem2;
                    this.bitsAfterLeftmost |= rem - (rem2 * smallPower);
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
                else
                {
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    int rem = this.shiftedSmall;
                    this.bitLeftmost = 0;
                    this.bitsAfterLeftmost |= rem;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
            }
            int v2 = this.shiftedSmall;
            int kb = (v2 >= 1000000000) ? 10 : ((v2 >= 100000000) ? 9 : ((v2 >=
            10000000) ? 8 : ((v2 >= 1000000) ? 7 : ((v2 >= 100000) ? 6 : ((v2 >=
            10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ? 3 : ((v2 >= 10) ? 2 :
            1))))))));
            this.knownDigitLength = new FastInteger(kb);
            if (this.discardedBitCount != null)
            {
                this.discardedBitCount.AddInt(digits);
            }
            else
            {
                this.discardedBitCount = new FastInteger(digits);
            }
            int digitsShifted = 0;
            while (digits > 0)
            {
                if (this.shiftedSmall == 0)
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = 0;
                    this.knownDigitLength = new FastInteger(1);
                    break;
                }
                else
                {
                    int digit = (int)(this.shiftedSmall % 10);
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = digit;
                    --digits;
                    ++digitsShifted;
                    this.shiftedSmall /= 10;
                }
            }
            this.UpdateKnownLengthInt(digitsShifted);
            this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
        }

        private void ShiftToDigitsBig(int digits, bool truncate)
        {
            // Shifts a number until it reaches the given number of digits,
            // gathering information on whether the last digit discarded is set
            // and whether the discarded digits to the right of that digit are set.
            // Assumes that the big integer being shifted is positive.
            if (this.knownDigitLength != null)
            {
                if (this.knownDigitLength.CompareToInt(digits) <= 0)
                {
                    return;
                }
            }
            string str;
            this.knownDigitLength = this.knownDigitLength ??
                  this.CalcKnownDigitLength();
            if (this.knownDigitLength.CompareToInt(digits) <= 0)
            {
                return;
            }
            FastInteger digitDiff = this.knownDigitLength.Copy().SubtractInt(digits);
            if (truncate && digitDiff.CanFitInInt32())
            {
                this.TruncateRight(digitDiff);
                return;
            }
            if (digitDiff.CompareToInt(1) == 0)
            {
                EInteger bigrem;
                EInteger bigquo;
                EInteger[] divrem = this.shiftedBigInt.DivRem(ValueTen);
                bigquo = divrem[0];
                bigrem = divrem[1];
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = (int)bigrem;
                this.shiftedBigInt = bigquo;
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.Add(digitDiff);
                this.UpdateKnownLength(digitDiff);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                return;
            }
            if (digitDiff.CompareToInt(9) <= 0)
            {
                EInteger bigrem;
                int diffInt = digitDiff.AsInt32();
                EInteger radixPower = NumberUtility.FindPowerOfTen(diffInt);
                EInteger bigquo;
                EInteger[] divrem = this.shiftedBigInt.DivRem(radixPower);
                bigquo = divrem[0];
                bigrem = divrem[1];
                int rem = (int)bigrem;
                this.bitsAfterLeftmost |= this.bitLeftmost;
                for (int i = 0; i < diffInt; ++i)
                {
                    if (i == diffInt - 1)
                    {
                        this.bitLeftmost = rem % 10;
                    }
                    else
                    {
                        int intQuot = (rem < 43698) ? ((rem * 26215) >> 18) : (rem / 10);
                        this.bitsAfterLeftmost |= rem - (intQuot * 10);
                        rem = intQuot;
                    }
                }
                this.shiftedBigInt = bigquo;
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.Add(digitDiff);
                this.UpdateKnownLength(digitDiff);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                return;
            }
            if (digitDiff.CanFitInInt32())
            {
#if DEBUG
                if (!(digitDiff.CompareToInt(2) > 0))
                {
                    throw new ArgumentException(
                  "doesn't satisfy digitDiff.CompareToInt(2)>0");
                }
#endif
                EInteger bigrem = null;
                EInteger bigquo;
                EInteger[] divrem;
                if (!this.shiftedBigInt.IsEven || this.bitsAfterLeftmost != 0)
                {
                    EInteger radixPower =
                    NumberUtility.FindPowerOfTen(digitDiff.AsInt32() - 1);
                    this.bitsAfterLeftmost |= 1;
                    bigquo = this.shiftedBigInt.Divide(radixPower);
                }
                else
                {
                    EInteger radixPower =
                    NumberUtility.FindPowerOfTen(digitDiff.AsInt32() - 1);
                    divrem = this.shiftedBigInt.DivRem(radixPower);
                    bigquo = divrem[0];
                    bigrem = divrem[1];
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    if (!bigrem.IsZero)
                    {
                        this.bitsAfterLeftmost |= 1;
                    }
                }
                EInteger bigquo2;
                divrem = bigquo.DivRem(ValueTen);
                bigquo2 = divrem[0];
                bigrem = divrem[1];
                this.bitLeftmost = (int)bigrem;
                this.shiftedBigInt = bigquo2;
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.Add(digitDiff);
                this.UpdateKnownLength(digitDiff);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                return;
            }
            str = this.shiftedBigInt.ToString();
            // NOTE: Will be 1 if the value is 0
            int digitLength = str.Length;
            this.knownDigitLength = new FastInteger(digitLength);
            // Shift by the difference in digit length
            if (digitLength > digits)
            {
                int digitShift = digitLength - digits;
                this.UpdateKnownLengthInt(digitShift);
                int newLength = (int)(digitLength - digitShift);
                // Console.WriteLine("dlen= " + digitLength + " dshift=" +
                // digitShift + " newlen= " + newLength);
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                if (digitShift <= Int32.MaxValue)
                {
                    this.discardedBitCount.AddInt((int)digitShift);
                }
                else
                {
                    this.discardedBitCount.AddBig((EInteger)digitShift);
                }
                for (int i = str.Length - 1; i >= 0; --i)
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = (int)(str[i] - '0');
                    --digitShift;
                    if (digitShift <= 0)
                    {
                        break;
                    }
                }
                if (newLength <= 9)
                {
                    this.isSmall = true;
                    this.shiftedSmall = FastParseLong(str, 0, newLength);
                }
                else
                {
                    this.shiftedBigInt = EInteger.FromSubstring(str, 0, newLength);
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
        }

        private void ShiftToDigitsSmall(int digits)
        {
            int kb = 0;
            int v2 = this.shiftedSmall;
            kb = (v2 >= 1000000000) ? 10 : ((v2 >= 100000000) ? 9 : ((v2 >=
            10000000) ? 8 : ((v2 >= 1000000) ? 7 : ((v2 >= 100000) ? 6 : ((v2 >=
            10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ? 3 : ((v2 >= 10) ? 2 :
            1))))))));
            this.knownDigitLength = new FastInteger(kb);
            if (kb > digits)
            {
                int digitShift = (int)(kb - digits);
                this.UpdateKnownLengthInt(digitShift);
                this.discardedBitCount = this.discardedBitCount != null ?
                  this.discardedBitCount.AddInt(digitShift) :
                  (new FastInteger(digitShift));
                for (int i = 0; i < digitShift; ++i)
                {
                    int digit = (int)(this.shiftedSmall % 10);
                    this.shiftedSmall /= 10;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = digit;
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
        }

        private void TruncateRightLong(long shiftedLong, int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (shiftedLong == 0 || digits >= 21)
            {
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = shiftedLong == 0 ? 0 : 1;
                this.shiftedSmall = 0;
                this.isSmall = true;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (digits >= 1 && digits <= TenPowersLong.Length - 1)
            {
                if (shiftedLong >= TenPowersLong[digits])
                {
                    long bigPower = TenPowersLong[digits];
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    long quo = shiftedLong / bigPower;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = (shiftedLong & 1) == 1 ? 1 :
                      (shiftedLong - (quo * bigPower) == 0 ? 0 : 1);
                    shiftedLong = quo;
                    this.isSmall = shiftedLong <= Int32.MaxValue;
                    if (this.isSmall)
                    {
                        this.shiftedSmall = (int)shiftedLong;
                    }
                    else
                    {
                        this.shiftedBigInt = EInteger.FromInt64(shiftedLong);
                    }
                    this.UpdateKnownLengthInt(digits);
                    return;
                }
                else
                {
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = shiftedLong == 0 ? 0 : 1;
                    shiftedLong = 0;
                    this.isSmall = shiftedLong <= Int32.MaxValue;
                    if (this.isSmall)
                    {
                        this.shiftedSmall = (int)shiftedLong;
                    }
                    else
                    {
                        this.shiftedBigInt = EInteger.FromInt64(shiftedLong);
                    }
                    this.UpdateKnownLengthInt(digits);
                    return;
                }
            }
            this.ShiftRightInt(digits);
        }

        private void TruncateRightSmall(int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (this.shiftedSmall == 0 || digits >= 11)
            {
                this.discardedBitCount = this.discardedBitCount ?? (new FastInteger(0));
                this.discardedBitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = (this.shiftedSmall == 0) ? 0 : 1;
                this.shiftedSmall = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (digits >= 1 && digits <= 8)
            {
                if (this.shiftedSmall >= ValueTenPowers[digits])
                {
                    int bigPower = ValueTenPowers[digits];
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    if ((this.shiftedSmall & 1) == 1)
                    {
                        this.bitLeftmost = 1;
                        this.shiftedSmall /= bigPower;
                    }
                    else
                    {
                        int quo = this.shiftedSmall / bigPower;
                        int rem = this.shiftedSmall - (quo * bigPower);
                        this.shiftedSmall = quo;
                        this.bitLeftmost |= (rem == 0) ? 0 : 1;
                    }
                    this.UpdateKnownLengthInt(digits);
                    return;
                }
                else
                {
                    if (this.discardedBitCount != null)
                    {
                        this.discardedBitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedBitCount = new FastInteger(digits);
                    }
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = (this.shiftedSmall == 0) ? 0 : 1;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
            }
            this.ShiftRightSmall(digits);
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EContext"]/*'/>
    public sealed class EContext
    {
        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagClamped"]/*'/>
        public const int FlagClamped = 32;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagDivideByZero"]/*'/>
        public const int FlagDivideByZero = 128;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagInexact"]/*'/>
        public const int FlagInexact = 1;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagInvalid"]/*'/>
        public const int FlagInvalid = 64;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagLostDigits"]/*'/>
        public const int FlagLostDigits = 256;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagOverflow"]/*'/>
        public const int FlagOverflow = 16;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagRounded"]/*'/>
        public const int FlagRounded = 2;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagSubnormal"]/*'/>
        public const int FlagSubnormal = 4;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.FlagUnderflow"]/*'/>
        public const int FlagUnderflow = 8;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Basic"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Basic =
          EContext.ForPrecisionAndRounding(9, ERounding.HalfUp);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.BigDecimalJava"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext BigDecimalJava =
          new EContext(0, ERounding.HalfUp, 0, 0, true)
          .WithExponentClamp(true).WithAdjustExponent(false)
          .WithBigExponentRange(
      EInteger.Zero - (EInteger)Int32.MaxValue,
      EInteger.One + (EInteger)Int32.MaxValue);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Binary128"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary128 =
          EContext.ForPrecisionAndRounding(113, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-16382, 16383);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Binary16"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary16 =
          EContext.ForPrecisionAndRounding(11, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-14, 15);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Binary32"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary32 =
          EContext.ForPrecisionAndRounding(24, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-126, 127);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Binary64"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary64 =
          EContext.ForPrecisionAndRounding(53, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-1022, 1023);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.CliDecimal"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif

        public static readonly EContext CliDecimal =
          new EContext(96, ERounding.HalfEven, 0, 28, true)
          .WithPrecisionInBits(true);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Decimal128"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif

        public static readonly EContext Decimal128 =
          new EContext(34, ERounding.HalfEven, -6143, 6144, true);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Decimal32"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif

        public static readonly EContext Decimal32 =
          new EContext(7, ERounding.HalfEven, -95, 96, true);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Decimal64"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif

        public static readonly EContext Decimal64 =
          new EContext(16, ERounding.HalfEven, -383, 384, true);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.Unlimited"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif

        public static readonly EContext Unlimited =
          EContext.ForPrecision(0);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EContext.UnlimitedHalfEven"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif

        public static readonly EContext UnlimitedHalfEven =
          EContext.ForPrecision(0).WithRounding(ERounding.HalfEven);

        // TODO: Improve API's immutability (make all
        // fields except flags and traps readonly/final)
        // and include a construtor setting all fields
        private bool adjustExponent;

        private EInteger bigintPrecision;

        private bool clampNormalExponents;
        private EInteger exponentMax;

        private EInteger exponentMin;

        private int flags;

        private bool hasExponentRange;
        private bool hasFlags;

        private bool precisionInBits;

        private ERounding rounding;

        private bool simplified;

        private int traps;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.#ctor(System.Int32,PeterO.Numbers.ERounding,System.Int32,System.Int32,System.Boolean)"]/*'/>
        public EContext(
      int precision,
      ERounding rounding,
      int exponentMinSmall,
      int exponentMaxSmall,
      bool clampNormalExponents)
        {
            if (precision < 0)
            {
                throw new ArgumentException("precision (" + precision +
                  ") is less than 0");
            }
            if (exponentMinSmall > exponentMaxSmall)
            {
                throw new ArgumentException("exponentMinSmall (" + exponentMinSmall +
                  ") is more than " + exponentMaxSmall);
            }
            this.bigintPrecision = precision == 0 ? EInteger.Zero :
              (EInteger)precision;
            this.rounding = rounding;
            this.clampNormalExponents = clampNormalExponents;
            this.hasExponentRange = true;
            this.adjustExponent = true;
            this.exponentMax = exponentMaxSmall == 0 ? EInteger.Zero :
              (EInteger)exponentMaxSmall;
            this.exponentMin = exponentMinSmall == 0 ? EInteger.Zero :
              (EInteger)exponentMinSmall;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.AdjustExponent"]/*'/>
        public bool AdjustExponent
        {
            get
            {
                return this.adjustExponent;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.ClampNormalExponents"]/*'/>
        public bool ClampNormalExponents
        {
            get
            {
                return this.hasExponentRange && this.clampNormalExponents;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.EMax"]/*'/>
        public EInteger EMax
        {
            get
            {
                return this.hasExponentRange ? this.exponentMax : EInteger.Zero;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.EMin"]/*'/>
        public EInteger EMin
        {
            get
            {
                return this.hasExponentRange ? this.exponentMin : EInteger.Zero;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.Flags"]/*'/>
        public int Flags
        {
            get
            {
                return this.flags;
            }

            set
            {
                if (!this.HasFlags)
                {
                    throw new InvalidOperationException("Can't set flags");
                }
                this.flags = value;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.HasExponentRange"]/*'/>
        public bool HasExponentRange
        {
            get
            {
                return this.hasExponentRange;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.HasFlags"]/*'/>
        public bool HasFlags
        {
            get
            {
                return this.hasFlags;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.HasMaxPrecision"]/*'/>
        public bool HasMaxPrecision
        {
            get
            {
                return !this.bigintPrecision.IsZero;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.IsPrecisionInBits"]/*'/>
        public bool IsPrecisionInBits
        {
            get
            {
                return this.precisionInBits;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.IsSimplified"]/*'/>
        public bool IsSimplified
        {
            get
            {
                return this.simplified;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.Precision"]/*'/>
        public EInteger Precision
        {
            get
            {
                return this.bigintPrecision;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.Rounding"]/*'/>
        public ERounding Rounding
        {
            get
            {
                return this.rounding;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EContext.Traps"]/*'/>
        public int Traps
        {
            get
            {
                return this.traps;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.ForPrecision(System.Int32)"]/*'/>
        public static EContext ForPrecision(int precision)
        {
            return new EContext(
        precision,
        ERounding.HalfUp,
        0,
        0,
        false).WithUnlimitedExponents();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.ForPrecisionAndRounding(System.Int32,PeterO.Numbers.ERounding)"]/*'/>
        public static EContext ForPrecisionAndRounding(
          int precision,
          ERounding rounding)
        {
            return new EContext(
        precision,
        rounding,
        0,
        0,
        false).WithUnlimitedExponents();
        }

        private static readonly EContext ForRoundingHalfEven = new EContext(
      0,
      ERounding.HalfEven,
      0,
      0,
      false).WithUnlimitedExponents();

        private static readonly EContext ForRoundingDown = new EContext(
      0,
      ERounding.Down,
      0,
      0,
      false).WithUnlimitedExponents();

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.ForRounding(PeterO.Numbers.ERounding)"]/*'/>
        public static EContext ForRounding(ERounding rounding)
        {
            if (rounding == ERounding.HalfEven)
            {
                return ForRoundingHalfEven;
            }
            if (rounding == ERounding.Down)
            {
                return ForRoundingDown;
            }
            return new EContext(
        0,
        rounding,
        0,
        0,
        false).WithUnlimitedExponents();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.Copy"]/*'/>
        public EContext Copy()
        {
            EContext pcnew = new EContext(
              0,
              this.rounding,
              0,
              0,
              this.clampNormalExponents)
            {
                hasFlags = this.hasFlags,
                precisionInBits = this.precisionInBits,
                adjustExponent = this.adjustExponent,
                simplified = this.simplified,
                flags = this.flags,
                exponentMax = this.exponentMax,
                exponentMin = this.exponentMin,
                hasExponentRange = this.hasExponentRange,
                bigintPrecision = this.bigintPrecision,
                rounding = this.rounding,
                clampNormalExponents = this.clampNormalExponents
            };
            return pcnew;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.ExponentWithinRange(PeterO.Numbers.EInteger)"]/*'/>
        public bool ExponentWithinRange(EInteger exponent)
        {
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            if (!this.HasExponentRange)
            {
                return true;
            }
            if (this.bigintPrecision.IsZero)
            {
                // Only check EMax, since with an unlimited
                // precision, any exponent less than EMin will exceed EMin if
                // the mantissa is the right size
                return exponent.CompareTo(this.EMax) <= 0;
            }
            else
            {
                EInteger bigint = exponent;
                if (this.adjustExponent)
                {
                    bigint += (EInteger)this.bigintPrecision;
                    bigint -= EInteger.One;
                }
                return (bigint.CompareTo(this.EMin) >= 0) &&
                  (exponent.CompareTo(this.EMax) <= 0);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.ToString"]/*'/>
        public override string ToString()
        {
            return "[PrecisionContext ExponentMax=" + this.exponentMax +
              ", Traps=" + this.traps + ", ExponentMin=" + this.exponentMin +
              ", HasExponentRange=" + this.hasExponentRange + ", BigintPrecision=" +
              this.bigintPrecision + ", Rounding=" + this.rounding +
              ", ClampNormalExponents=" + this.clampNormalExponents + ", Flags=" +
              this.flags + ", HasFlags=" + this.hasFlags + "]";
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithAdjustExponent(System.Boolean)"]/*'/>
        public EContext WithAdjustExponent(bool adjustExponent)
        {
            EContext pc = this.Copy();
            pc.adjustExponent = adjustExponent;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithBigExponentRange(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public EContext WithBigExponentRange(
          EInteger exponentMin,
          EInteger exponentMax)
        {
            if (exponentMin == null)
            {
                throw new ArgumentNullException(nameof(exponentMin));
            }
            if (exponentMax == null)
            {
                throw new ArgumentNullException(nameof(exponentMax));
            }
            if (exponentMin.CompareTo(exponentMax) > 0)
            {
                throw new ArgumentException("exponentMin greater than exponentMax");
            }
            EContext pc = this.Copy();
            pc.hasExponentRange = true;
            pc.exponentMin = exponentMin;
            pc.exponentMax = exponentMax;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithBigPrecision(PeterO.Numbers.EInteger)"]/*'/>
        public EContext WithBigPrecision(EInteger bigintPrecision)
        {
            if (bigintPrecision == null)
            {
                throw new ArgumentNullException(nameof(bigintPrecision));
            }
            if (bigintPrecision.Sign < 0)
            {
                throw new ArgumentException("bigintPrecision's sign (" +
                  bigintPrecision.Sign + ") is less than 0");
            }
            EContext pc = this.Copy();
            pc.bigintPrecision = bigintPrecision;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithBlankFlags"]/*'/>
        public EContext WithBlankFlags()
        {
            EContext pc = this.Copy();
            pc.hasFlags = true;
            pc.flags = 0;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithExponentClamp(System.Boolean)"]/*'/>
        public EContext WithExponentClamp(bool clamp)
        {
            EContext pc = this.Copy();
            pc.clampNormalExponents = clamp;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithExponentRange(System.Int32,System.Int32)"]/*'/>
        public EContext WithExponentRange(
          int exponentMinSmall,
          int exponentMaxSmall)
        {
            if (exponentMinSmall > exponentMaxSmall)
            {
                throw new ArgumentException("exponentMinSmall (" + exponentMinSmall +
                  ") is more than " + exponentMaxSmall);
            }
            EContext pc = this.Copy();
            pc.hasExponentRange = true;
            pc.exponentMin = (EInteger)exponentMinSmall;
            pc.exponentMax = (EInteger)exponentMaxSmall;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithNoFlags"]/*'/>
        public EContext WithNoFlags()
        {
            EContext pc = this.Copy();
            pc.hasFlags = false;
            pc.flags = 0;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithPrecision(System.Int32)"]/*'/>
        public EContext WithPrecision(int precision)
        {
            if (precision < 0)
            {
                throw new ArgumentException("precision (" + precision +
                  ") is less than 0");
            }
            EContext pc = this.Copy();
            pc.bigintPrecision = (EInteger)precision;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithPrecisionInBits(System.Boolean)"]/*'/>
        public EContext WithPrecisionInBits(bool isPrecisionBits)
        {
            EContext pc = this.Copy();
            pc.precisionInBits = isPrecisionBits;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithRounding(PeterO.Numbers.ERounding)"]/*'/>
        public EContext WithRounding(ERounding rounding)
        {
            EContext pc = this.Copy();
            pc.rounding = rounding;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithSimplified(System.Boolean)"]/*'/>
        public EContext WithSimplified(bool simplified)
        {
            EContext pc = this.Copy();
            pc.simplified = simplified;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithTraps(System.Int32)"]/*'/>
        public EContext WithTraps(int traps)
        {
            EContext pc = this.Copy();
            pc.hasFlags = true;
            pc.traps = traps;
            return pc;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EContext.WithUnlimitedExponents"]/*'/>
        public EContext WithUnlimitedExponents()
        {
            EContext pc = this.Copy();
            pc.hasExponentRange = false;
            return pc;
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EDecimal"]/*'/>
    public sealed partial class EDecimal : IComparable<EDecimal>,
    IEquatable<EDecimal>
    {
        //----------------------------------------------------------------

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.NaN"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal NaN = CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagQuietNaN);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.NegativeInfinity"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal NegativeInfinity =
          CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.NegativeZero"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal NegativeZero =
          CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagNegative);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.One"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal One =
          EDecimal.Create(EInteger.One, EInteger.Zero);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.PositiveInfinity"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal PositiveInfinity =
          CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagInfinity);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.SignalingNaN"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal SignalingNaN =
              CreateWithFlags(
                EInteger.Zero,
                EInteger.Zero,
                BigNumberFlags.FlagSignalingNaN);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.Ten"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif

        public static readonly EDecimal Ten =
          EDecimal.Create((EInteger)10, EInteger.Zero);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EDecimal.Zero"]/*'/>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",
                "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal Zero =
          EDecimal.Create(EInteger.Zero, EInteger.Zero);

        private const int MaxSafeInt = 214748363;

        private static readonly IRadixMath<EDecimal> ExtendedMathValue = new
          RadixMath<EDecimal>(new DecimalMathHelper());

        private static readonly FastIntegerFixed FastIntZero = new
              FastIntegerFixed(0);
        //----------------------------------------------------------------
        private static readonly IRadixMath<EDecimal> MathValue = new
          TrappableRadixMath<EDecimal>(
            new ExtendedOrSimpleRadixMath<EDecimal>(new
                        DecimalMathHelper()));

        private static readonly int[] ValueTenPowers = {
      1, 10, 100, 1000, 10000, 100000,
      1000000, 10000000, 100000000,
      1000000000
    };

        private readonly FastIntegerFixed exponent;
        private readonly int flags;
        private readonly FastIntegerFixed unsignedMantissa;

        private int sign;

        private EDecimal(
          FastIntegerFixed unsignedMantissa,
          FastIntegerFixed exponent,
          int flags)
        {
#if DEBUG
            if (unsignedMantissa == null)
            {
                throw new ArgumentNullException(nameof(unsignedMantissa));
            }

            if (unsignedMantissa.Sign < 0)
            {
                throw new ArgumentException("unsignedMantissa is less than 0.");
            }
#endif
            this.unsignedMantissa = unsignedMantissa;
            this.exponent = exponent ?? throw new ArgumentNullException(nameof(exponent));
            this.flags = flags;
            this.sign = (((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                      this.unsignedMantissa.IsValueZero) ? 0 : (((this.flags &
                          BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
        }

        private EDecimal(
          FastIntegerFixed unsignedMantissa,
          FastIntegerFixed exponent,
          int flags,
          int sign)
        {
#if DEBUG
            if (unsignedMantissa == null)
            {
                throw new ArgumentNullException(nameof(unsignedMantissa));
            }

            if (unsignedMantissa.Sign < 0)
            {
                throw new ArgumentException("unsignedMantissa is less than 0.");
            }
#endif
            this.unsignedMantissa = unsignedMantissa;
            this.exponent = exponent ?? throw new ArgumentNullException(nameof(exponent));
            this.flags = flags;
            this.sign = sign;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EDecimal.Exponent"]/*'/>
        public EInteger Exponent
        {
            get
            {
                return this.exponent.ToEInteger();
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EDecimal.IsFinite"]/*'/>
        public bool IsFinite
        {
            get
            {
                return (this.flags & (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNaN)) == 0;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EDecimal.IsNegative"]/*'/>
        public bool IsNegative
        {
            get
            {
                return (this.flags & BigNumberFlags.FlagNegative) != 0;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EDecimal.IsZero"]/*'/>
        public bool IsZero
        {
            get
            {
                return ((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                  this.sign == 0;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EDecimal.Mantissa"]/*'/>
        public EInteger Mantissa
        {
            get
            {
                return this.IsNegative ? this.unsignedMantissa.ToEInteger().Negate() :
                        this.unsignedMantissa.ToEInteger();
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EDecimal.Sign"]/*'/>
        public int Sign
        {
            get
            {
                return this.sign;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EDecimal.UnsignedMantissa"]/*'/>
        public EInteger UnsignedMantissa
        {
            get
            {
                return this.unsignedMantissa.ToEInteger();
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Create(System.Int32,System.Int32)"]/*'/>
        public static EDecimal Create(int mantissaSmall, int exponentSmall)
        {
            if (mantissaSmall == Int32.MinValue)
            {
                return Create((EInteger)mantissaSmall, (EInteger)exponentSmall);
            }
            else if (mantissaSmall < 0)
            {
                return new EDecimal(
          new FastIntegerFixed(mantissaSmall).Negate(),
          new FastIntegerFixed(exponentSmall),
          BigNumberFlags.FlagNegative,
          -1);
            }
            else if (mantissaSmall == 0)
            {
                return new EDecimal(
               FastIntZero,
               new FastIntegerFixed(exponentSmall),
               0,
               0);
            }
            else
            {
                return new EDecimal(
          new FastIntegerFixed(mantissaSmall),
          new FastIntegerFixed(exponentSmall),
          0,
          1);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EDecimal Create(
          EInteger mantissa,
          EInteger exponent)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            FastIntegerFixed fi = FastIntegerFixed.FromBig(mantissa);
            int sign = fi.Sign;
            return new EDecimal(
              sign < 0 ? fi.Negate() : fi,
              FastIntegerFixed.FromBig(exponent),
              (sign < 0) ? BigNumberFlags.FlagNegative : 0,
              sign);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger)"]/*'/>
        public static EDecimal CreateNaN(EInteger diag)
        {
            return CreateNaN(diag, false, false, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal CreateNaN(
          EInteger diag,
          bool signaling,
          bool negative,
          EContext ctx)
        {
            if (diag == null)
            {
                throw new ArgumentNullException(nameof(diag));
            }
            if (diag.Sign < 0)
            {
                throw new
               ArgumentException("Diagnostic information must be 0 or greater, was: " +
                            diag);
            }
            if (diag.IsZero && !negative)
            {
                return signaling ? SignalingNaN : NaN;
            }
            int flags = 0;
            if (negative)
            {
                flags |= BigNumberFlags.FlagNegative;
            }
            if (ctx != null && ctx.HasMaxPrecision)
            {
                flags |= BigNumberFlags.FlagQuietNaN;
                EDecimal ef = new EDecimal(
                FastIntegerFixed.FromBig(diag),
                FastIntZero,
                flags,
                negative ? -1 : 1).RoundToPrecision(ctx);
                int newFlags = ef.flags;
                newFlags &= ~BigNumberFlags.FlagQuietNaN;
                newFlags |= signaling ? BigNumberFlags.FlagSignalingNaN :
                  BigNumberFlags.FlagQuietNaN;
                return new EDecimal(
          ef.unsignedMantissa,
          ef.exponent,
          newFlags,
          negative ? -1 : 1);
            }
            flags |= signaling ? BigNumberFlags.FlagSignalingNaN :
              BigNumberFlags.FlagQuietNaN;
            return new EDecimal(
              FastIntegerFixed.FromBig(diag),
              FastIntZero,
              flags,
              negative ? -1 : 1);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromDouble(System.Double)"]/*'/>
        public static EDecimal FromDouble(double dbl)
        {
            int[] value = Extras.DoubleToIntegers(dbl);
            int floatExponent = (int)((value[1] >> 20) & 0x7ff);
            bool neg = (value[1] >> 31) != 0;
            long lvalue;
            if (floatExponent == 2047)
            {
                if ((value[1] & 0xfffff) == 0 && value[0] == 0)
                {
                    return neg ? NegativeInfinity : PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = (value[1] & 0x80000) != 0;
                value[1] &= 0x7ffff;
                lvalue = unchecked((value[0] & 0xffffffffL) | ((long)value[1] << 32));
                int flags = (neg ? BigNumberFlags.FlagNegative : 0) | (quiet ?
                        BigNumberFlags.FlagQuietNaN : BigNumberFlags.FlagSignalingNaN);
                return lvalue == 0 ? (quiet ? NaN : SignalingNaN) :
                  new EDecimal(
                    FastIntegerFixed.FromLong(lvalue),
                    FastIntZero,
                    flags,
                    neg ? -1 : 1);
            }
            value[1] &= 0xfffff;

            // Mask out the exponent and sign
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                value[1] |= 0x100000;
            }
            if ((value[1] | value[0]) != 0)
            {
                floatExponent += NumberUtility.ShiftAwayTrailingZerosTwoElements(value);
            }
            else
            {
                return neg ? EDecimal.NegativeZero : EDecimal.Zero;
            }
            floatExponent -= 1075;
            lvalue = unchecked((value[0] & 0xffffffffL) | ((long)value[1] << 32));
            if (floatExponent == 0)
            {
                if (neg)
                {
                    lvalue = -lvalue;
                }
                return EDecimal.FromInt64(lvalue);
            }
            if (floatExponent > 0)
            {
                // Value is an integer
                EInteger bigmantissa = (EInteger)lvalue;
                bigmantissa <<= floatExponent;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.FromEInteger(bigmantissa);
            }
            else
            {
                // Value has a fractional part
                EInteger bigmantissa = (EInteger)lvalue;
                EInteger exp = NumberUtility.FindPowerOfFive(-floatExponent);
                bigmantissa *= (EInteger)exp;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.Create(bigmantissa, (EInteger)floatExponent);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromEInteger(PeterO.Numbers.EInteger)"]/*'/>
        public static EDecimal FromEInteger(EInteger bigint)
        {
            return EDecimal.Create(bigint, EInteger.Zero);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromExtendedFloat(PeterO.Numbers.EFloat)"]/*'/>
        [Obsolete("Renamed to FromEFloat.")]
        public static EDecimal FromExtendedFloat(EFloat ef)
        {
            return FromEFloat(ef);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromEFloat(PeterO.Numbers.EFloat)"]/*'/>
        public static EDecimal FromEFloat(EFloat bigfloat)
        {
            if (bigfloat == null)
            {
                throw new ArgumentNullException(nameof(bigfloat));
            }
            if (bigfloat.IsNaN() || bigfloat.IsInfinity())
            {
                int flags = (bigfloat.IsNegative ? BigNumberFlags.FlagNegative : 0) |
                  (bigfloat.IsInfinity() ? BigNumberFlags.FlagInfinity : 0) |
                  (bigfloat.IsQuietNaN() ? BigNumberFlags.FlagQuietNaN : 0) |
                  (bigfloat.IsSignalingNaN() ? BigNumberFlags.FlagSignalingNaN : 0);
                return CreateWithFlags(
                  bigfloat.UnsignedMantissa,
                  bigfloat.Exponent,
                  flags);
            }
            EInteger bigintExp = bigfloat.Exponent;
            EInteger bigintMant = bigfloat.Mantissa;
            if (bigintMant.IsZero)
            {
                return bigfloat.IsNegative ? EDecimal.NegativeZero :
                  EDecimal.Zero;
            }
            if (bigintExp.IsZero)
            {
                // Integer
                return EDecimal.FromEInteger(bigintMant);
            }
            if (bigintExp.Sign > 0)
            {
                // Scaled integer
                FastInteger intcurexp = FastInteger.FromBig(bigintExp);
                EInteger bigmantissa = bigintMant;
                bool neg = bigmantissa.Sign < 0;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                while (intcurexp.Sign > 0)
                {
                    int shift = 1000000;
                    if (intcurexp.CompareToInt(1000000) < 0)
                    {
                        shift = intcurexp.AsInt32();
                    }
                    bigmantissa <<= shift;
                    intcurexp.AddInt(-shift);
                }
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.FromEInteger(bigmantissa);
            }
            else
            {
                // Fractional number
                EInteger bigmantissa = bigintMant;
                EInteger negbigintExp = -(EInteger)bigintExp;
                negbigintExp = NumberUtility.FindPowerOfFiveFromBig(negbigintExp);
                bigmantissa *= (EInteger)negbigintExp;
                return EDecimal.Create(bigmantissa, bigintExp);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromInt32(System.Int32)"]/*'/>
        public static EDecimal FromInt32(int valueSmaller)
        {
            if (valueSmaller == 0)
            {
                return EDecimal.Zero;
            }
            if (valueSmaller == Int32.MinValue)
            {
                return Create((EInteger)valueSmaller, EInteger.Zero);
            }
            if (valueSmaller < 0)
            {
                return new EDecimal(
          new FastIntegerFixed(valueSmaller).Negate(),
          FastIntZero,
          BigNumberFlags.FlagNegative,
          -1);
            }
            else
            {
                return new
                    EDecimal(new FastIntegerFixed(valueSmaller), FastIntZero, 0, 1);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromInt64(System.Int64)"]/*'/>
        public static EDecimal FromInt64(long valueSmall)
        {
            if (valueSmall == 0)
            {
                return EDecimal.Zero;
            }
            if (valueSmall > Int32.MinValue && valueSmall <= Int32.MaxValue)
            {
                if (valueSmall < 0)
                {
                    return new EDecimal(
            new FastIntegerFixed((int)valueSmall).Negate(),
            FastIntZero,
            BigNumberFlags.FlagNegative,
            -1);
                }
                else
                {
                    return new EDecimal(
            new FastIntegerFixed((int)valueSmall),
            FastIntZero,
            0,
            1);
                }
            }
            EInteger bigint = (EInteger)valueSmall;
            return EDecimal.Create(bigint, EInteger.Zero);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromSingle(System.Single)"]/*'/>
        public static EDecimal FromSingle(float flt)
        {
            int value = BitConverter.ToInt32(BitConverter.GetBytes((float)flt), 0);
            bool neg = (value >> 31) != 0;
            int floatExponent = (int)((value >> 23) & 0xff);
            int valueFpMantissa = value & 0x7fffff;
            if (floatExponent == 255)
            {
                if (valueFpMantissa == 0)
                {
                    return neg ? NegativeInfinity : PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = (valueFpMantissa & 0x400000) != 0;
                valueFpMantissa &= 0x3fffff;
                value = (neg ? BigNumberFlags.FlagNegative : 0) |
               (quiet ? BigNumberFlags.FlagQuietNaN : BigNumberFlags.FlagSignalingNaN);
                return valueFpMantissa == 0 ? (quiet ? NaN : SignalingNaN) :
                  new EDecimal(
                    new FastIntegerFixed(valueFpMantissa),
                    FastIntZero,
                    value,
                    neg ? -1 : 1);
            }
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                valueFpMantissa |= 1 << 23;
            }
            if (valueFpMantissa == 0)
            {
                return neg ? EDecimal.NegativeZero : EDecimal.Zero;
            }
            floatExponent -= 150;
            while ((valueFpMantissa & 1) == 0)
            {
                ++floatExponent;
                valueFpMantissa >>= 1;
            }
            if (floatExponent == 0)
            {
                if (neg)
                {
                    valueFpMantissa = -valueFpMantissa;
                }
                return EDecimal.FromInt64(valueFpMantissa);
            }
            if (floatExponent > 0)
            {
                // Value is an integer
                EInteger bigmantissa = (EInteger)valueFpMantissa;
                bigmantissa <<= floatExponent;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.FromEInteger(bigmantissa);
            }
            else
            {
                // Value has a fractional part
                EInteger bigmantissa = (EInteger)valueFpMantissa;
                EInteger bigexponent = NumberUtility.FindPowerOfFive(-floatExponent);
                bigmantissa *= (EInteger)bigexponent;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.Create(bigmantissa, (EInteger)floatExponent);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromString(System.String)"]/*'/>
        public static EDecimal FromString(string str)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromString(System.String,PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal FromString(string str, EContext ctx)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32)"]/*'/>
        public static EDecimal FromString(
          string str,
          int offset,
          int length)
        {
            return FromString(str, offset, length, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal FromString(
          string str,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset (" + tmpoffset + ") is less than " +
                            "0");
            }
            if (tmpoffset > str.Length)
            {
                throw new FormatException("offset (" + tmpoffset + ") is more than " +
                            str.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length (" + length + ") is less than " +
                            "0");
            }
            if (length > str.Length)
            {
                throw new FormatException("length (" + length + ") is more than " +
                            str.Length);
            }
            if (str.Length - tmpoffset < length)
            {
                throw new FormatException("str's length minus " + tmpoffset + " (" +
                            (str.Length - tmpoffset) + ") is less than " + length);
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            bool negative = false;
            int endStr = tmpoffset + length;
            if (str[0] == '+' || str[0] == '-')
            {
                negative = str[0] == '-';
                ++tmpoffset;
            }
            int mantInt = 0;
            FastInteger mant = null;
            int mantBuffer = 0;
            int mantBufferMult = 1;
            int expBuffer = 0;
            int expBufferMult = 1;
            bool haveDecimalPoint = false;
            bool haveDigits = false;
            bool haveExponent = false;
            int newScaleInt = 0;
            FastInteger newScale = null;
            int i = tmpoffset;
            if (i + 8 == endStr)
            {
                if ((str[i] == 'I' || str[i] == 'i') &&
                    (str[i + 1] == 'N' || str[i + 1] == 'n') &&
                    (str[i + 2] == 'F' || str[i + 2] == 'f') &&
                    (str[i + 3] == 'I' || str[i + 3] == 'i') && (str[i + 4] == 'N' ||
                            str[i + 4] == 'n') && (str[i + 5] ==
                            'I' || str[i + 5] == 'i') &&
                    (str[i + 6] == 'T' || str[i + 6] == 't') && (str[i + 7] == 'Y' ||
                            str[i + 7] == 'y'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? NegativeInfinity : PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((str[i] == 'I' || str[i] == 'i') &&
                    (str[i + 1] == 'N' || str[i + 1] == 'n') && (str[i + 2] == 'F' ||
                            str[i + 2] == 'f'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? NegativeInfinity : PositiveInfinity;
                }
            }
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((str[i] == 'N' || str[i] == 'n') && (str[i + 1] == 'A' || str[i +
                        1] == 'a') && (str[i + 2] == 'N' || str[i + 2] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? NaN : new EDecimal(
                          FastIntZero,
                          FastIntZero,
                          flags2,
                          -1);
                    }
                    i += 3;
                    FastInteger digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    for (; i < endStr; ++i)
                    {
                        if (str[i] >= '0' && str[i] <= '9')
                        {
                            int thisdigit = (int)(str[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt > MaxSafeInt)
                            {
                                if (mant == null)
                                {
                                    mant = new FastInteger(mantInt);
                                    mantBuffer = thisdigit;
                                    mantBufferMult = 10;
                                }
                                else
                                {
                                    if (mantBufferMult >= 1000000000)
                                    {
                                        mant.Multiply(mantBufferMult).AddInt(mantBuffer);
                                        mantBuffer = thisdigit;
                                        mantBufferMult = 10;
                                    }
                                    else
                                    {
                                        // multiply by 10
                                        mantBufferMult = (mantBufferMult << 3) + (mantBufferMult << 1);
                                        mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);
                                        mantBuffer += thisdigit;
                                    }
                                }
                            }
                            else
                            {
                                // multiply by 10
                                mantInt = (mantInt << 3) + (mantInt << 1);
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mant != null && (mantBufferMult != 1 || mantBuffer != 0))
                    {
                        mant.Multiply(mantBufferMult).AddInt(mantBuffer);
                    }
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant.AsEInteger();
                    flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    return CreateWithFlags(
                      FastIntegerFixed.FromBig(bigmant),
                      FastIntZero,
                      flags2);
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((str[i] == 'S' || str[i] == 's') && (str[i + 1] == 'N' || str[i +
                            1] == 'n') && (str[i + 2] == 'A' || str[i + 2] == 'a') &&
                        (str[i + 3] == 'N' || str[i + 3] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    if (i + 4 == endStr)
                    {
                        int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                          BigNumberFlags.FlagSignalingNaN;
                        return (!negative) ? SignalingNaN :
                          new EDecimal(
                            FastIntZero,
                            FastIntZero,
                            flags2,
                            -1);
                    }
                    i += 4;
                    FastInteger digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    for (; i < endStr; ++i)
                    {
                        if (str[i] >= '0' && str[i] <= '9')
                        {
                            int thisdigit = (int)(str[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt > MaxSafeInt)
                            {
                                if (mant == null)
                                {
                                    mant = new FastInteger(mantInt);
                                    mantBuffer = thisdigit;
                                    mantBufferMult = 10;
                                }
                                else
                                {
                                    if (mantBufferMult >= 1000000000)
                                    {
                                        mant.Multiply(mantBufferMult).AddInt(mantBuffer);
                                        mantBuffer = thisdigit;
                                        mantBufferMult = 10;
                                    }
                                    else
                                    {
                                        // multiply by 10
                                        mantBufferMult = (mantBufferMult << 3) + (mantBufferMult << 1);
                                        mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);
                                        mantBuffer += thisdigit;
                                    }
                                }
                            }
                            else
                            {
                                // multiply by 10
                                mantInt = (mantInt << 3) + (mantInt << 1);
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mant != null && (mantBufferMult != 1 || mantBuffer != 0))
                    {
                        mant.Multiply(mantBufferMult).AddInt(mantBuffer);
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant.AsEInteger();
                    return CreateWithFlags(
                      bigmant,
                      EInteger.Zero,
                      flags3);
                }
            }
            // Ordinary number
            for (; i < endStr; ++i)
            {
                char ch = str[i];
                if (ch >= '0' && ch <= '9')
                {
                    int thisdigit = (int)(ch - '0');
                    if (mantInt > MaxSafeInt)
                    {
                        if (mant == null)
                        {
                            mant = new FastInteger(mantInt);
                            mantBuffer = thisdigit;
                            mantBufferMult = 10;
                        }
                        else
                        {
                            if (mantBufferMult >= 1000000000)
                            {
                                mant.Multiply(mantBufferMult).AddInt(mantBuffer);
                                mantBuffer = thisdigit;
                                mantBufferMult = 10;
                            }
                            else
                            {
                                // multiply mantBufferMult and mantBuffer each by 10
                                mantBufferMult = (mantBufferMult << 3) + (mantBufferMult << 1);
                                mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);
                                mantBuffer += thisdigit;
                            }
                        }
                    }
                    else
                    {
                        // multiply by 10
                        mantInt = (mantInt << 3) + (mantInt << 1);
                        mantInt += thisdigit;
                    }
                    haveDigits = true;
                    if (haveDecimalPoint)
                    {
                        if (newScaleInt == Int32.MinValue)
                        {
                            newScale = newScale ?? (new FastInteger(newScaleInt));
                            newScale.Decrement();
                        }
                        else
                        {
                            --newScaleInt;
                        }
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (mant != null && (mantBufferMult != 1 || mantBuffer != 0))
            {
                mant.Multiply(mantBufferMult).AddInt(mantBuffer);
            }
            if (haveExponent)
            {
                FastInteger exp = null;
                int expInt = 0;
                tmpoffset = 1;
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                if (str[i] == '+' || str[i] == '-')
                {
                    if (str[i] == '-')
                    {
                        tmpoffset = -1;
                    }
                    ++i;
                }
                for (; i < endStr; ++i)
                {
                    char ch = str[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        int thisdigit = (int)(ch - '0');
                        if (expInt > MaxSafeInt)
                        {
                            if (exp == null)
                            {
                                exp = new FastInteger(expInt);
                                expBuffer = thisdigit;
                                expBufferMult = 10;
                            }
                            else
                            {
                                if (expBufferMult >= 1000000000)
                                {
                                    exp.Multiply(expBufferMult).AddInt(expBuffer);
                                    expBuffer = thisdigit;
                                    expBufferMult = 10;
                                }
                                else
                                {
                                    // multiply expBufferMult and expBuffer each by 10
                                    expBufferMult = (expBufferMult << 3) + (expBufferMult << 1);
                                    expBuffer = (expBuffer << 3) + (expBuffer << 1);
                                    expBuffer += thisdigit;
                                }
                            }
                        }
                        else
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                if (exp != null && (expBufferMult != 1 || expBuffer != 0))
                {
                    exp.Multiply(expBufferMult).AddInt(expBuffer);
                }
                if (tmpoffset >= 0 && newScaleInt == 0 && newScale == null && exp == null)
                {
                    newScaleInt = expInt;
                }
                else if (exp == null)
                {
                    newScale = newScale ?? (new FastInteger(newScaleInt));
                    if (tmpoffset < 0)
                    {
                        newScale.SubtractInt(expInt);
                    }
                    else if (expInt != 0)
                    {
                        newScale.AddInt(expInt);
                    }
                }
                else
                {
                    newScale = newScale ?? (new FastInteger(newScaleInt));
                    if (tmpoffset < 0)
                    {
                        newScale.Subtract(exp);
                    }
                    else
                    {
                        newScale.Add(exp);
                    }
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            FastIntegerFixed fastIntScale;
            FastIntegerFixed fastIntMant;
            fastIntScale = (newScale == null) ? (new FastIntegerFixed(newScaleInt)) :
              FastIntegerFixed.FromFastInteger(newScale);
            int sign = negative ? -1 : 1;
            if (mant == null)
            {
                fastIntMant = new FastIntegerFixed(mantInt);
                if (mantInt == 0)
                {
                    sign = 0;
                }
            }
            else if (mant.CanFitInInt32())
            {
                mantInt = mant.AsInt32();
                fastIntMant = new FastIntegerFixed(mantInt);
                if (mantInt == 0)
                {
                    sign = 0;
                }
            }
            else
            {
                fastIntMant = FastIntegerFixed.FromFastInteger(mant);
            }
            EDecimal ret = new EDecimal(
        fastIntMant,
        fastIntScale,
        negative ? BigNumberFlags.FlagNegative : 0,
        sign);
            if (ctx != null)
            {
                ret = GetMathValue(ctx).RoundAfterConversion(ret, ctx);
            }
            return ret;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal Max(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            return GetMathValue(ctx).Max(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal Max(
          EDecimal first,
          EDecimal second)
        {
            return Max(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal MaxMagnitude(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            return GetMathValue(ctx).MaxMagnitude(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal MaxMagnitude(
          EDecimal first,
          EDecimal second)
        {
            return MaxMagnitude(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal Min(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            return GetMathValue(ctx).Min(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal Min(
          EDecimal first,
          EDecimal second)
        {
            return Min(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal MinMagnitude(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            return GetMathValue(ctx).MinMagnitude(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal MinMagnitude(
          EDecimal first,
          EDecimal second)
        {
            return MinMagnitude(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.PI(PeterO.Numbers.EContext)"]/*'/>
        public static EDecimal PI(EContext ctx)
        {
            return GetMathValue(ctx).Pi(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Abs"]/*'/>
        public EDecimal Abs()
        {
            if (this.IsNegative)
            {
                EDecimal er = new EDecimal(
          this.unsignedMantissa,
          this.exponent,
          this.flags & ~BigNumberFlags.FlagNegative,
          Math.Abs(this.sign));
                return er;
            }
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CopySign(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal CopySign(EDecimal other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (this.IsNegative)
            {
                return other.IsNegative ? this : this.Negate();
            }
            else
            {
                return other.IsNegative ? this.Negate() : this;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Abs(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Abs(EContext context)
        {
            return ((context == null || context == EContext.UnlimitedHalfEven) ?
              ExtendedMathValue : MathValue).Abs(this, context);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal Add(EDecimal otherValue)
        {
            if (this.IsFinite && otherValue != null && otherValue.IsFinite &&
              ((this.flags | otherValue.flags) & BigNumberFlags.FlagNegative) == 0 &&
                  this.exponent.CompareTo(otherValue.exponent) == 0)
            {
                FastIntegerFixed result = FastIntegerFixed.Add(
          this.unsignedMantissa,
          otherValue.unsignedMantissa);
                int sign = result.IsValueZero ? 0 : 1;
                return new EDecimal(result, this.exponent, 0, sign);
            }
            return this.Add(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Add(
          EDecimal otherValue,
          EContext ctx)
        {
            return GetMathValue(ctx).Add(this, otherValue, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CompareTo(PeterO.Numbers.EDecimal)"]/*'/>
        public int CompareTo(EDecimal other)
        {
            return ExtendedMathValue.CompareTo(this, other);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CompareToBinary(PeterO.Numbers.EFloat)"]/*'/>
        public int CompareToBinary(EFloat other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsNaN())
            {
                return other.IsNaN() ? 0 : 1;
            }
            int signA = this.Sign;
            int signB = other.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (this.IsInfinity())
            {
                if (other.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return this.IsNegative ? -1 : 1;
            }
            if (other.IsInfinity())
            {
                return other.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!this.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy this.IsFinite");
            }
            if (!other.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy other.IsFinite");
            }
#endif
            if (other.Exponent.CompareTo((EInteger)(-1000)) < 0)
            {
                // For very low exponents, the conversion to decimal can take
                // very long, so try this approach
                if (other.Abs(null).CompareTo(EFloat.One) < 0)
                {
                    // Abs less than 1
                    if (this.Abs(null).CompareTo(EDecimal.One) >= 0)
                    {
                        // Abs 1 or more
                        return (signA > 0) ? 1 : -1;
                    }
                }
            }
            if (other.Exponent.CompareTo((EInteger)1000) > 0)
            {
                // Very high exponents
                EInteger bignum = EInteger.One.ShiftLeft(999);
                if (this.Abs(null).CompareTo(EDecimal.FromEInteger(bignum)) <=
                    0)
                {
                    // this object's absolute value is less
                    return (signA > 0) ? -1 : 1;
                }
                // NOTE: The following check assumes that both
                // operands are nonzero
                EInteger thisAdjExp = this.GetAdjustedExponent();
                EInteger otherAdjExp = GetAdjustedExponentBinary(other);
                if (thisAdjExp.Sign > 0 && thisAdjExp.CompareTo(otherAdjExp) >= 0)
                {
                    // This object's adjusted exponent is greater and is positive;
                    // so this object's absolute value is greater, since exponents
                    // have a greater value in decimal than in binary
                    return (signA > 0) ? 1 : -1;
                }
                if (thisAdjExp.Sign > 0 && thisAdjExp.CompareTo((EInteger)1000) >= 0 &&
                        otherAdjExp.CompareTo((EInteger)1000) >= 0)
                {
                    thisAdjExp = thisAdjExp.Add(EInteger.One);
                    otherAdjExp = thisAdjExp.Add(EInteger.One);
                    EInteger ratio = otherAdjExp / thisAdjExp;
                    // Check the ratio of the binary exponent to the decimal exponent.
                    // If the ratio is less than 3, the decimal's absolute value is
                    // greater. If it's 4 or greater, the binary' s absolute value is
                    // greater.
                    // (If the two absolute values are equal, the ratio will approach
                    // ln(10)/ln(2), or about 3.322, as the exponents get higher and
                    // higher.) This check assumes that both exponents are 1000 or
                    // greater,
                    // when the ratio between exponents of equal values is close to
                    // ln(10)/ln(2).
                    if (ratio.CompareTo((EInteger)3) < 0)
                    {
                        // Decimal abs. value is greater
                        return (signA > 0) ? 1 : -1;
                    }
                    if (ratio.CompareTo((EInteger)4) >= 0)
                    {
                        return (signA > 0) ? -1 : 1;
                    }
                }
            }
            EDecimal otherDec = EDecimal.FromEFloat(other);
            return this.CompareTo(otherDec);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CompareToSignal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal CompareToSignal(
          EDecimal other,
          EContext ctx)
        {
            return GetMathValue(ctx).CompareToWithContext(this, other, true, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CompareToTotalMagnitude(PeterO.Numbers.EDecimal)"]/*'/>
        public int CompareToTotalMagnitude(EDecimal other)
        {
            if (other == null)
            {
                return -1;
            }
            int valueIThis = 0;
            int valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return 1;
            }
            else if (valueIThis < valueIOther)
            {
                return -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                 other.unsignedMantissa);
                return cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.Abs().CompareTo(other.Abs());
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                     other.exponent);
                    return cmp;
                }
                return cmp;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public int CompareToTotal(EDecimal other, EContext ctx)
        {
            if (other == null)
            {
                return -1;
            }
            if (this.IsSignalingNaN() || other.IsSignalingNaN())
            {
                return this.CompareToTotal(other);
            }
            if (ctx != null && ctx.IsSimplified)
            {
                return this.RoundToPrecision(ctx)
                  .CompareToTotal(other.RoundToPrecision(ctx));
            }
            else
            {
                return this.CompareToTotal(other);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal)"]/*'/>
        public int CompareToTotal(EDecimal other)
        {
            if (other == null)
            {
                return -1;
            }
            bool neg1 = this.IsNegative;
            bool neg2 = other.IsNegative;
            if (neg1 != neg2)
            {
                return neg1 ? -1 : 1;
            }
            int valueIThis = 0;
            int valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return neg1 ? -1 : 1;
            }
            else if (valueIThis < valueIOther)
            {
                return neg1 ? 1 : -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                 other.unsignedMantissa);
                return neg1 ? -cmp : cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.CompareTo(other);
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                     other.exponent);
                    return neg1 ? -cmp : cmp;
                }
                return cmp;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.CompareToWithContext(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal CompareToWithContext(
          EDecimal other,
          EContext ctx)
        {
            return GetMathValue(ctx).CompareToWithContext(this, other, false, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal Divide(EDecimal divisor)
        {
            return this.Divide(
              divisor,
              EContext.ForRounding(ERounding.None));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Divide(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).Divide(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal)"]/*'/>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EDecimal[] DivideAndRemainderNaturalScale(EDecimal
          divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EDecimal[] DivideAndRemainderNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            return this.DivRemNaturalScale(divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal[] DivRemNaturalScale(EDecimal
          divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal[] DivRemNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            EDecimal[] result = new EDecimal[2];
            result[0] = this.DivideToIntegerNaturalScale(divisor, null);
            result[1] = this.Subtract(
              result[0].Multiply(divisor, null),
              ctx);
            result[0] = result[0].RoundToPrecision(ctx);
            return result;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          long desiredExponentSmall,
          EContext ctx)
        {
            return this.DivideToExponent(
              divisor,
              (EInteger)desiredExponentSmall,
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          int desiredExponentInt,
          EContext ctx)
        {
            return this.DivideToExponent(
              divisor,
              (EInteger)desiredExponentInt,
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          long desiredExponentSmall,
          ERounding rounding)
        {
            return this.DivideToExponent(
              divisor,
              (EInteger)desiredExponentSmall,
              EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          int desiredExponentInt,
          ERounding rounding)
        {
            return this.DivideToExponent(
              divisor,
              (EInteger)desiredExponentInt,
              EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          EInteger exponent,
          EContext ctx)
        {
            return GetMathValue(ctx).DivideToExponent(this, divisor, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          EInteger exponent)
        {
            return this.DivideToExponent(divisor, exponent, ERounding.HalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          long desiredExponentSmall)
        {
            return this.DivideToExponent(
        divisor,
        desiredExponentSmall,
        ERounding.HalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          int desiredExponentInt)
        {
            return this.DivideToExponent(
             divisor,
             desiredExponentInt,
             ERounding.HalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          EInteger desiredExponent,
          ERounding rounding)
        {
            return this.DivideToExponent(
              divisor,
              desiredExponent,
              EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal DivideToIntegerNaturalScale(EDecimal
                        divisor)
        {
            return this.DivideToIntegerNaturalScale(
              divisor,
              EContext.ForRounding(ERounding.Down));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal DivideToIntegerNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).DivideToIntegerNaturalScale(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToIntegerZeroScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal DivideToIntegerZeroScale(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).DivideToIntegerZeroScale(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DivideToSameExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal DivideToSameExponent(
          EDecimal divisor,
          ERounding rounding)
        {
            return this.DivideToExponent(
              divisor,
              this.exponent.ToEInteger(),
              EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Equals(PeterO.Numbers.EDecimal)"]/*'/>
        public bool Equals(EDecimal other)
        {
            return this.EqualsInternal(other);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Equals(System.Object)"]/*'/>
        public override bool Equals(object obj)
        {
            return this.EqualsInternal(obj as EDecimal);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Exp(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Exp(EContext ctx)
        {
            return GetMathValue(ctx).Exp(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.GetHashCode"]/*'/>
        public override int GetHashCode()
        {
            int hashCode = 964453631;
            unchecked
            {
                hashCode += 964453723 * this.exponent.GetHashCode();
                hashCode += 964453939 * this.unsignedMantissa.GetHashCode();
                hashCode += 964453967 * this.flags;
            }
            return hashCode;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.IsInfinity"]/*'/>
        public bool IsInfinity()
        {
            return (this.flags & BigNumberFlags.FlagInfinity) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.IsNaN"]/*'/>
        public bool IsNaN()
        {
            return (this.flags & (BigNumberFlags.FlagQuietNaN |
                          BigNumberFlags.FlagSignalingNaN)) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.IsNegativeInfinity"]/*'/>
        public bool IsNegativeInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                      BigNumberFlags.FlagNegative)) == (BigNumberFlags.FlagInfinity |
                          BigNumberFlags.FlagNegative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.IsPositiveInfinity"]/*'/>
        public bool IsPositiveInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                        BigNumberFlags.FlagNegative)) == BigNumberFlags.FlagInfinity;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.IsQuietNaN"]/*'/>
        public bool IsQuietNaN()
        {
            return (this.flags & BigNumberFlags.FlagQuietNaN) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.IsSignalingNaN"]/*'/>
        public bool IsSignalingNaN()
        {
            return (this.flags & BigNumberFlags.FlagSignalingNaN) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Log(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Log(EContext ctx)
        {
            return GetMathValue(ctx).Ln(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Log10(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Log10(EContext ctx)
        {
            return GetMathValue(ctx).Log10(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32)"]/*'/>
        public EDecimal MovePointLeft(int places)
        {
            return this.MovePointLeft((EInteger)places, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal MovePointLeft(int places, EContext ctx)
        {
            return this.MovePointLeft((EInteger)places, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger)"]/*'/>
        public EDecimal MovePointLeft(EInteger bigPlaces)
        {
            return this.MovePointLeft(bigPlaces, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal MovePointLeft(
      EInteger bigPlaces,
      EContext ctx)
        {
            return (!this.IsFinite) ? this.RoundToPrecision(ctx) :
              this.MovePointRight(-(EInteger)bigPlaces, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32)"]/*'/>
        public EDecimal MovePointRight(int places)
        {
            return this.MovePointRight((EInteger)places, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal MovePointRight(int places, EContext ctx)
        {
            return this.MovePointRight((EInteger)places, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger)"]/*'/>
        public EDecimal MovePointRight(EInteger bigPlaces)
        {
            return this.MovePointRight(bigPlaces, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal MovePointRight(
      EInteger bigPlaces,
      EContext ctx)
        {
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            if (bigExp.Sign > 0)
            {
                EInteger mant = this.unsignedMantissa.ToEInteger();
                EInteger bigPower = NumberUtility.FindPowerOfTenFromBig(bigExp);
                mant *= bigPower;
                return CreateWithFlags(
          mant,
          EInteger.Zero,
          this.flags).RoundToPrecision(ctx);
            }
            return CreateWithFlags(
              this.unsignedMantissa,
              FastIntegerFixed.FromBig(bigExp),
              this.flags).RoundToPrecision(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal Multiply(EDecimal otherValue)
        {
            if (this.IsFinite && otherValue.IsFinite)
            {
                int newflags = otherValue.flags ^ this.flags;
                if (this.unsignedMantissa.CanFitInInt32() &&
                  otherValue.unsignedMantissa.CanFitInInt32())
                {
                    int integerA = this.unsignedMantissa.AsInt32();
                    int integerB = otherValue.unsignedMantissa.AsInt32();
                    long longA = ((long)integerA) * ((long)integerB);
                    int sign = (longA == 0) ? 0 : (newflags == 0 ? 1 : -1);
                    FastIntegerFixed exp = FastIntegerFixed.Add(
            this.exponent,
            otherValue.exponent);
                    if ((longA >> 31) == 0)
                    {
                        return new EDecimal(
              new FastIntegerFixed((int)longA),
              exp,
              newflags,
              sign);
                    }
                    else
                    {
                        return new EDecimal(
              FastIntegerFixed.FromBig((EInteger)longA),
              exp,
              newflags,
              sign);
                    }
                }
                else
                {
                    EInteger eintA = this.unsignedMantissa.ToEInteger().Multiply(
                     otherValue.unsignedMantissa.ToEInteger());
                    int sign = eintA.IsZero ? 0 : (newflags == 0 ? 1 : -1);
                    return new EDecimal(
            FastIntegerFixed.FromBig(eintA),
            FastIntegerFixed.Add(this.exponent, otherValue.exponent),
            newflags,
            sign);
                }
            }
            return this.Multiply(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Multiply(EDecimal op, EContext ctx)
        {
            return GetMathValue(ctx).Multiply(this, op, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Add(System.Int32)"]/*'/>
        public EDecimal Add(int intValue)
        {
            return this.Add(EDecimal.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Subtract(System.Int32)"]/*'/>
        public EDecimal Subtract(int intValue)
        {
            return (intValue == Int32.MinValue) ?
              this.Subtract(EDecimal.FromInt32(intValue)) : this.Add(-intValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Multiply(System.Int32)"]/*'/>
        public EDecimal Multiply(int intValue)
        {
            return this.Multiply(EDecimal.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Divide(System.Int32)"]/*'/>
        public EDecimal Divide(int intValue)
        {
            return this.Divide(EDecimal.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal MultiplyAndAdd(
          EDecimal multiplicand,
          EDecimal augend)
        {
            return this.MultiplyAndAdd(multiplicand, augend, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal MultiplyAndAdd(
          EDecimal op,
          EDecimal augend,
          EContext ctx)
        {
            return GetMathValue(ctx).MultiplyAndAdd(this, op, augend, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.MultiplyAndSubtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal MultiplyAndSubtract(
          EDecimal op,
          EDecimal subtrahend,
          EContext ctx)
        {
            if (op == null)
            {
                throw new ArgumentNullException(nameof(op));
            }
            if (subtrahend == null)
            {
                throw new ArgumentNullException(nameof(subtrahend));
            }
            EDecimal negated = subtrahend;
            if ((subtrahend.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = subtrahend.flags ^ BigNumberFlags.FlagNegative;
                negated = CreateWithFlags(
                  subtrahend.unsignedMantissa,
                  subtrahend.exponent,
                  newflags);
            }
            return GetMathValue(ctx)
              .MultiplyAndAdd(this, op, negated, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Negate"]/*'/>
        public EDecimal Negate()
        {
            return new EDecimal(
        this.unsignedMantissa,
        this.exponent,
        this.flags ^ BigNumberFlags.FlagNegative,
        -this.sign);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Negate(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Negate(EContext context)
        {
            return ((context == null || context == EContext.UnlimitedHalfEven) ?
              ExtendedMathValue : MathValue).Negate(this, context);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.NextMinus(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal NextMinus(EContext ctx)
        {
            return GetMathValue(ctx).NextMinus(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.NextPlus(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal NextPlus(EContext ctx)
        {
            return GetMathValue(ctx)
              .NextPlus(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.NextToward(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal NextToward(
          EDecimal otherValue,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .NextToward(this, otherValue, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Plus(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Plus(EContext ctx)
        {
            return GetMathValue(ctx).Plus(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Pow(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Pow(EDecimal exponent, EContext ctx)
        {
            return GetMathValue(ctx).Power(this, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Pow(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Pow(int exponentSmall, EContext ctx)
        {
            return this.Pow(EDecimal.FromInt64(exponentSmall), ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Pow(System.Int32)"]/*'/>
        public EDecimal Pow(int exponentSmall)
        {
            return this.Pow(EDecimal.FromInt64(exponentSmall), null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Precision"]/*'/>
        public EInteger Precision()
        {
            if (!this.IsFinite)
            {
                return EInteger.Zero;
            }
            if (this.IsZero)
            {
                return EInteger.One;
            }
            int digcount = this.unsignedMantissa.ToEInteger().GetDigitCount();
            return (EInteger)digcount;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Quantize(
          EInteger desiredExponent,
          EContext ctx)
        {
            return this.Quantize(
              EDecimal.Create(EInteger.One, desiredExponent),
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal Quantize(
          int desiredExponentInt,
          ERounding rounding)
        {
            EDecimal ret = this.RoundToExponentFast(
        desiredExponentInt,
        rounding);
            if (ret != null)
            {
                return ret;
            }
            return this.Quantize(
            EDecimal.Create(EInteger.One, (EInteger)desiredExponentInt),
            EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Quantize(
          int desiredExponentInt,
          EContext ctx)
        {
            if (ctx == null ||
               (!ctx.HasExponentRange && !ctx.HasFlags && ctx.Traps == 0 &&
                !ctx.HasMaxPrecision && !ctx.IsSimplified))
            {
                EDecimal ret = this.RoundToExponentFast(
          desiredExponentInt,
          ctx == null ? ERounding.HalfEven : ctx.Rounding);
                if (ret != null)
                {
                    return ret;
                }
            }
            return this.Quantize(
            EDecimal.Create(EInteger.One, (EInteger)desiredExponentInt),
            ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Quantize(
          EDecimal otherValue,
          EContext ctx)
        {
            return GetMathValue(ctx).Quantize(this, otherValue, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Reduce(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Reduce(EContext ctx)
        {
            return GetMathValue(ctx).Reduce(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Remainder(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Remainder(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).Remainder(this, divisor, ctx, true);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RemainderNoRoundAfterDivide(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RemainderNoRoundAfterDivide(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).Remainder(this, divisor, ctx, false);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal RemainderNaturalScale(EDecimal divisor)
        {
            return this.RemainderNaturalScale(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RemainderNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            return this.Subtract(
              this.DivideToIntegerNaturalScale(divisor, null).Multiply(divisor, null),
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RemainderNear(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RemainderNear(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .RemainderNear(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RoundToExponent(
          EInteger exponent,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentSimple(this, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger)"]/*'/>
        public EDecimal RoundToExponent(
          EInteger exponent)
        {
            return this.RoundToExponent(
        exponent,
        EContext.ForRounding(ERounding.HalfEven));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal RoundToExponent(
          EInteger exponent,
          ERounding rounding)
        {
            return this.RoundToExponent(
        exponent,
        EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32)"]/*'/>
        public EDecimal RoundToExponent(
          int exponentSmall)
        {
            return this.RoundToExponent(exponentSmall, ERounding.HalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RoundToExponent(
          int exponentSmall,
          EContext ctx)
        {
            if (ctx == null ||
               (!ctx.HasExponentRange && !ctx.HasFlags && ctx.Traps == 0 &&
                !ctx.HasMaxPrecision && !ctx.IsSimplified))
            {
                EDecimal ret = this.RoundToExponentFast(
          exponentSmall,
          ctx == null ? ERounding.HalfEven : ctx.Rounding);
                if (ret != null)
                {
                    return ret;
                }
            }
            return this.RoundToExponent((EInteger)exponentSmall, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal RoundToExponent(
          int exponentSmall,
          ERounding rounding)
        {
            EDecimal ret = this.RoundToExponentFast(
        exponentSmall,
        rounding);
            if (ret != null)
            {
                return ret;
            }
            return this.RoundToExponent(
        exponentSmall,
        EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RoundToExponentExact(
          EInteger exponent,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentExact(this, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RoundToExponentExact(
          int exponentSmall,
          EContext ctx)
        {
            return this.RoundToExponentExact((EInteger)exponentSmall, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.ERounding)"]/*'/>
        public EDecimal RoundToExponentExact(
          int exponentSmall,
          ERounding rounding)
        {
            return this.RoundToExponentExact(
             (EInteger)exponentSmall,
             EContext.Unlimited.WithRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToIntegerExact(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RoundToIntegerExact(EContext ctx)
        {
            return GetMathValue(ctx).RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RoundToIntegerNoRoundedFlag(EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToIntegralExact(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to RoundToIntegerExact.")]
        public EDecimal RoundToIntegralExact(EContext ctx)
        {
            return GetMathValue(ctx).RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to RoundToIntegerNoRoundedFlag.")]
        public EDecimal RoundToIntegralNoRoundedFlag(EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.RoundToPrecision(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal RoundToPrecision(EContext ctx)
        {
            return GetMathValue(ctx).RoundToPrecision(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32)"]/*'/>
        public EDecimal ScaleByPowerOfTen(int places)
        {
            return this.ScaleByPowerOfTen((EInteger)places, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal ScaleByPowerOfTen(int places, EContext ctx)
        {
            return this.ScaleByPowerOfTen((EInteger)places, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger)"]/*'/>
        public EDecimal ScaleByPowerOfTen(EInteger bigPlaces)
        {
            return this.ScaleByPowerOfTen(bigPlaces, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal ScaleByPowerOfTen(
      EInteger bigPlaces,
      EContext ctx)
        {
            if (bigPlaces.IsZero)
            {
                return this.RoundToPrecision(ctx);
            }
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            return CreateWithFlags(
              this.unsignedMantissa,
              FastIntegerFixed.FromBig(bigExp),
              this.flags).RoundToPrecision(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Sqrt(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Sqrt(EContext ctx)
        {
            return GetMathValue(ctx).SquareRoot(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.SquareRoot(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to Sqrt.")]
        public EDecimal SquareRoot(EContext ctx)
        {
            return GetMathValue(ctx).SquareRoot(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal)"]/*'/>
        public EDecimal Subtract(EDecimal otherValue)
        {
            return this.Subtract(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"]/*'/>
        public EDecimal Subtract(
          EDecimal otherValue,
          EContext ctx)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            EDecimal negated = otherValue;
            if ((otherValue.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = otherValue.flags ^ BigNumberFlags.FlagNegative;
                negated = CreateWithFlags(
                  otherValue.unsignedMantissa,
                  otherValue.exponent,
                  newflags);
            }
            return this.Add(negated, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToDouble"]/*'/>
        public double ToDouble()
        {
            if (this.IsPositiveInfinity())
            {
                return Double.PositiveInfinity;
            }
            if (this.IsNegativeInfinity())
            {
                return Double.NegativeInfinity;
            }
            if (this.IsNegative && this.IsZero)
            {
                return Extras.IntegersToDouble(new[] { 0, unchecked((int)(1 << 31)) });
            }
            if (this.IsZero)
            {
                return 0.0;
            }
            if (this.IsFinite)
            {
                EInteger adjExp = this.GetAdjustedExponent();
                if (adjExp.CompareTo((EInteger)(-326)) < 0)
                {
                    // Very low exponent, treat as 0
                    return this.IsNegative ? Extras.IntegersToDouble(new[] { 0,
            unchecked((int)(1 << 31)) }) : 0.0;
                }
                if (adjExp.CompareTo((EInteger)309) > 0)
                {
                    // Very high exponent, treat as infinity
                    return this.IsNegative ? Double.NegativeInfinity :
                      Double.PositiveInfinity;
                }
            }
            return this.ToEFloat(EContext.Binary64).ToDouble();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToEInteger"]/*'/>
        public EInteger ToEInteger()
        {
            return this.ToEIntegerInternal(false);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToEIntegerExact"]/*'/>
        [Obsolete("Renamed to ToEIntegerIfExact.")]
        public EInteger ToEIntegerExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToEIntegerIfExact"]/*'/>
        public EInteger ToEIntegerIfExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToEngineeringString"]/*'/>
        public string ToEngineeringString()
        {
            return this.ToStringInternal(1);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToExtendedFloat"]/*'/>
        [Obsolete("Renamed to ToEFloat.")]
        public EFloat ToExtendedFloat()
        {
            return this.ToEFloat(EContext.UnlimitedHalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToEFloat"]/*'/>
        public EFloat ToEFloat()
        {
            return this.ToEFloat(EContext.UnlimitedHalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToPlainString"]/*'/>
        public string ToPlainString()
        {
            return this.ToStringInternal(2);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToSingle"]/*'/>
        public float ToSingle()
        {
            if (this.IsPositiveInfinity())
            {
                return Single.PositiveInfinity;
            }
            if (this.IsNegativeInfinity())
            {
                return Single.NegativeInfinity;
            }
            if (this.IsNegative && this.IsZero)
            {
                return BitConverter.ToSingle(BitConverter.GetBytes((int)1 << 31), 0);
            }
            if (this.IsZero)
            {
                return 0.0f;
            }
            EInteger adjExp = this.GetAdjustedExponent();
            if (adjExp.CompareTo((EInteger)(-47)) < 0)
            {
                // Very low exponent, treat as 0
                return this.IsNegative ?
                  BitConverter.ToSingle(BitConverter.GetBytes((int)1 << 31), 0) :
                  0.0f;
            }
            if (adjExp.CompareTo((EInteger)39) > 0)
            {
                // Very high exponent, treat as infinity
                return this.IsNegative ? Single.NegativeInfinity :
                  Single.PositiveInfinity;
            }
            return this.ToEFloat(EContext.Binary32).ToSingle();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToString"]/*'/>
        public override string ToString()
        {
            return this.ToStringInternal(0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.Ulp"]/*'/>
        public EDecimal Ulp()
        {
            return (!this.IsFinite) ? EDecimal.One :
              EDecimal.Create(EInteger.One, this.Exponent);
        }

        internal static EDecimal CreateWithFlags(
          FastIntegerFixed mantissa,
          FastIntegerFixed exponent,
          int flags)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
#if DEBUG
            if (!(mantissa.Sign >= 0))
            {
                throw new ArgumentException("doesn't satisfy mantissa.Sign >= 0");
            }
#endif
            int sign = (((flags & BigNumberFlags.FlagSpecial) == 0) &&
                      mantissa.IsValueZero) ? 0 : (((flags &
                          BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
            return new EDecimal(
              mantissa,
              exponent,
              flags,
              sign);
        }

        internal static EDecimal CreateWithFlags(
          EInteger mantissa,
          EInteger exponent,
          int flags)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
#if DEBUG
            if (!(mantissa.Sign >= 0))
            {
                throw new ArgumentException("doesn't satisfy mantissa.Sign >= 0");
            }
#endif
            int sign = (((flags & BigNumberFlags.FlagSpecial) == 0) &&
                      mantissa.IsZero) ? 0 : (((flags &
                          BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
            return new EDecimal(
              FastIntegerFixed.FromBig(mantissa),
              FastIntegerFixed.FromBig(exponent),
              flags,
              sign);
        }

        private static bool AppendString(
          StringBuilder builder,
          char c,
          FastInteger count)
        {
            if (count.CompareToInt(Int32.MaxValue) > 0 || count.Sign < 0)
            {
                throw new NotSupportedException();
            }
            int icount = count.AsInt32();
            for (int i = icount - 1; i >= 0; --i)
            {
                builder.Append(c);
            }
            return true;
        }

        private static EInteger GetAdjustedExponentBinary(EFloat ef)
        {
            if (!ef.IsFinite)
            {
                return EInteger.Zero;
            }
            if (ef.IsZero)
            {
                return EInteger.Zero;
            }
            EInteger retEInt = ef.Exponent;
            int smallPrecision = ef.UnsignedMantissa.GetSignedBitLength();
            --smallPrecision;
            retEInt = retEInt.Add(EInteger.FromInt32(smallPrecision));
            return retEInt;
        }

        private static IRadixMath<EDecimal> GetMathValue(EContext ctx)
        {
            if (ctx == null || ctx == EContext.UnlimitedHalfEven)
            {
                return ExtendedMathValue;
            }
            return (!ctx.IsSimplified && ctx.Traps == 0) ? ExtendedMathValue :
              MathValue;
        }

        private bool EqualsInternal(EDecimal otherValue)
        {
            return (otherValue != null) && (this.flags == otherValue.flags &&
                          this.unsignedMantissa.Equals(otherValue.unsignedMantissa) &&
                      this.exponent.Equals(otherValue.exponent));
        }

        private EInteger GetAdjustedExponent()
        {
            if (!this.IsFinite)
            {
                return EInteger.Zero;
            }
            if (this.IsZero)
            {
                return EInteger.Zero;
            }
            EInteger retEInt = this.Exponent;
            int smallPrecision = this.UnsignedMantissa.GetDigitCount();
            --smallPrecision;
            retEInt = retEInt.Add(EInteger.FromInt32(smallPrecision));
            return retEInt;
        }

        private EDecimal RoundToExponentFast(
      int exponentSmall,
      ERounding rounding)
        {
            if (this.IsFinite && this.exponent.CanFitInInt32() &&
              this.unsignedMantissa.CanFitInInt32())
            {
                int thisExponentSmall = this.exponent.AsInt32();
                if (thisExponentSmall == exponentSmall)
                {
                    return this;
                }
                int thisMantissaSmall = this.unsignedMantissa.AsInt32();
                if (thisExponentSmall >= -100 && thisExponentSmall <= 100 &&
                  exponentSmall >= -100 && exponentSmall <= 100)
                {
                    if (rounding == ERounding.Down)
                    {
                        int diff = exponentSmall - thisExponentSmall;
                        if (diff >= 1 && diff <= 9)
                        {
                            thisMantissaSmall /= ValueTenPowers[diff];
                            return new EDecimal(
                              new FastIntegerFixed(thisMantissaSmall),
                              new FastIntegerFixed(exponentSmall),
                              this.flags,
                              thisMantissaSmall == 0 ? 0 : ((this.flags == 0) ? 1 : -1));
                        }
                    }
                    else if (rounding == ERounding.HalfEven &&
                      thisMantissaSmall != Int32.MaxValue)
                    {
                        int diff = exponentSmall - thisExponentSmall;
                        if (diff >= 1 && diff <= 9)
                        {
                            int pwr = ValueTenPowers[diff - 1];
                            int div = thisMantissaSmall / pwr;
                            int div2 = (div > 43698) ? (div / 10) : ((div * 26215) >> 18);
                            int rem = div - (div2 * 10);
                            if (rem > 5)
                            {
                                ++div2;
                            }
                            else if (rem == 5 && (thisMantissaSmall - (div * pwr)) != 0)
                            {
                                ++div2;
                            }
                            else if (rem == 5 && (div2 & 1) == 1)
                            {
                                ++div2;
                            }
                            return new EDecimal(
                              new FastIntegerFixed(div2),
                              new FastIntegerFixed(exponentSmall),
                              this.flags,
                              div2 == 0 ? 0 : ((this.flags == 0) ? 1 : -1));
                        }
                    }
                }
            }
            return null;
        }

        private bool IsIntegerPartZero()
        {
            if (!this.IsFinite)
            {
                return false;
            }
            if (this.unsignedMantissa.IsValueZero)
            {
                return true;
            }
            int sign = this.Exponent.Sign;
            if (sign >= 0)
            {
                return false;
            }
            else
            {
                FastInteger bigexponent = this.exponent.ToFastInteger().Negate();
                EInteger bigmantissa = this.unsignedMantissa.ToEInteger();
                DigitShiftAccumulator acc = new DigitShiftAccumulator(bigmantissa, 0, 0);
                return (acc.GetDigitLength().CompareTo(bigexponent) <= 0) ? true :
                        false;
            }
        }

        private EInteger ToEIntegerInternal(bool exact)
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            int sign = this.Exponent.Sign;
            if (this.IsZero)
            {
                return EInteger.Zero;
            }
            if (sign == 0)
            {
                EInteger bigmantissa = this.Mantissa;
                return bigmantissa;
            }
            if (sign > 0)
            {
                EInteger bigmantissa = this.Mantissa;
                EInteger bigexponent =
                  NumberUtility.FindPowerOfTenFromBig(this.Exponent);
                bigmantissa *= (EInteger)bigexponent;
                return bigmantissa;
            }
            else
            {
                if (exact && !this.unsignedMantissa.IsEvenNumber)
                {
                    // Mantissa is odd and will have to shift a nonzero
                    // number of digits, so can't be an exact integer
                    throw new ArithmeticException("Not an exact integer");
                }
                FastInteger bigexponent = this.exponent.ToFastInteger().Negate();
                EInteger bigmantissa = this.unsignedMantissa.ToEInteger();
                DigitShiftAccumulator acc = new DigitShiftAccumulator(bigmantissa, 0, 0);
                acc.TruncateRight(bigexponent);
                if (exact && (acc.LastDiscardedDigit != 0 || acc.OlderDiscardedDigits !=
                            0))
                {
                    // Some digits were discarded
                    throw new ArithmeticException("Not an exact integer");
                }
                bigmantissa = acc.ShiftedInt;
                if (this.IsNegative)
                {
                    bigmantissa = -bigmantissa;
                }
                return bigmantissa;
            }
        }

        private static bool HasTerminatingBinaryExpansion(EInteger
          den)
        {
            if (den.IsZero)
            {
                return false;
            }
            if (den.GetUnsignedBit(0) && den.CompareTo(EInteger.One) != 0)
            {
                return false;
            }
            int lowBit = den.GetLowBit();
            den >>= lowBit;
            return den.Equals(EInteger.One);
        }

        private EFloat WithThisSign(EFloat ef)
        {
            return this.IsNegative ? ef.Negate() : ef;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToEFloat(PeterO.Numbers.EContext)"]/*'/>
        public EFloat ToEFloat(EContext ec)
        {
            // TODO: Investigate speeding up Binary64 case
            EInteger bigintExp = this.Exponent;
            EInteger bigintMant = this.UnsignedMantissa;
            if (this.IsNaN())
            {
                return EFloat.CreateNaN(
          this.UnsignedMantissa,
          this.IsSignalingNaN(),
          this.IsNegative,
          ec);
            }
            if (this.IsPositiveInfinity())
            {
                return EFloat.PositiveInfinity.RoundToPrecision(ec);
            }
            if (this.IsNegativeInfinity())
            {
                return EFloat.NegativeInfinity.RoundToPrecision(ec);
            }
            if (bigintMant.IsZero)
            {
                return this.IsNegative ? EFloat.NegativeZero.RoundToPrecision(ec) :
                  EFloat.Zero.RoundToPrecision(ec);
            }
            if (bigintExp.IsZero)
            {
                // Integer
                // DebugUtility.Log("Integer");
                return this.WithThisSign(EFloat.FromEInteger(bigintMant))
             .RoundToPrecision(ec);
            }
            if (bigintExp.Sign > 0)
            {
                // Scaled integer
                // DebugUtility.Log("Scaled integer");
                EInteger bigmantissa = bigintMant;
                bigintExp = NumberUtility.FindPowerOfTenFromBig(bigintExp);
                bigmantissa *= (EInteger)bigintExp;
                return this.WithThisSign(EFloat.FromEInteger(bigmantissa))
              .RoundToPrecision(ec);
            }
            else
            {
                // Fractional number
                // DebugUtility.Log("Fractional");
                EInteger scale = bigintExp;
                EInteger bigmantissa = bigintMant;
                bool neg = bigmantissa.Sign < 0;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                EInteger negscale = -scale;
                // DebugUtility.Log("" + negscale);
                EInteger divisor = NumberUtility.FindPowerOfTenFromBig(negscale);
                EInteger desiredHigh;
                EInteger desiredLow;
                bool haveCopy = false;
                ec = ec ?? EContext.UnlimitedHalfEven;
                EContext originalEc = ec;
                if (!ec.HasMaxPrecision)
                {
                    EInteger num = bigmantissa;
                    EInteger den = divisor;
                    EInteger gcd = num.Gcd(den);
                    if (gcd.CompareTo(EInteger.One) != 0)
                    {
                        den /= gcd;
                    }
                    // DebugUtility.Log("num=" + (num/gcd));
                    // DebugUtility.Log("den=" + den);
                    if (!HasTerminatingBinaryExpansion(den))
                    {
                        // DebugUtility.Log("Approximate");
                        // DebugUtility.Log("=>{0}\r\n->{1}", bigmantissa, divisor);
                        ec = ec.WithPrecision(53).WithBlankFlags();
                        haveCopy = true;
                    }
                    else
                    {
                        bigmantissa /= gcd;
                        divisor = den;
                    }
                }
                // NOTE: Precision added by 2 to accommodate rounding
                // to odd
                EInteger valueEcPrec = ec.HasMaxPrecision ? ec.Precision +
                  EInteger.FromInt32(2) : EInteger.Zero;
                int valueEcPrecInt = 0;
                if (!valueEcPrec.CanFitInInt32())
                {
                    EInteger precm1 = valueEcPrec - EInteger.One;
                    desiredLow = EInteger.One;
                    while (precm1.Sign > 0)
                    {
                        int shift = 1000000;
                        if (precm1.CompareTo((EInteger)1000000) < 0)
                        {
                            shift = precm1.ToInt32Checked();
                        }
                        desiredLow <<= shift;
                        precm1 -= (EInteger)shift;
                    }
                    desiredHigh = desiredLow << 1;
                }
                else
                {
                    int prec = valueEcPrec.ToInt32Checked();
                    valueEcPrecInt = prec;
                    desiredHigh = EInteger.One << prec;
                    int precm1 = prec - 1;
                    desiredLow = EInteger.One << precm1;
                }
                // DebugUtility.Log("=>{0}\r\n->{1}", bigmantissa, divisor);
                EInteger[] quorem = ec.HasMaxPrecision ?
                  bigmantissa.DivRem(divisor) : null;
                // DebugUtility.Log("=>{0}\r\n->{1}", quorem[0], desiredHigh);
                FastInteger adjust = new FastInteger(0);
                if (!ec.HasMaxPrecision)
                {
                    int term = divisor.GetLowBit();
                    bigmantissa <<= term;
                    adjust.SubtractInt(term);
                    quorem = bigmantissa.DivRem(divisor);
                }
                else if (quorem[0].CompareTo(desiredHigh) >= 0)
                {
                    do
                    {
                        bool optimized = false;
                        if (divisor.CompareTo(bigmantissa) < 0)
                        {
                            if (ec.ClampNormalExponents && valueEcPrecInt > 0 &&
                                valueEcPrecInt != Int32.MaxValue)
                            {
                                int valueBmBits = bigmantissa.GetUnsignedBitLength();
                                int divBits = divisor.GetUnsignedBitLength();
                                if (divBits < valueBmBits)
                                {
                                    int bitdiff = valueBmBits - divBits;
                                    if (bitdiff > valueEcPrecInt + 1)
                                    {
                                        bitdiff -= valueEcPrecInt + 1;
                                        divisor <<= bitdiff;
                                        adjust.AddInt(bitdiff);
                                        optimized = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (ec.ClampNormalExponents && valueEcPrecInt > 0)
                            {
                                int valueBmBits = bigmantissa.GetUnsignedBitLength();
                                int divBits = divisor.GetUnsignedBitLength();
                                if (valueBmBits >= divBits && valueEcPrecInt <= Int32.MaxValue -
                                     divBits)
                                {
                                    int vbb = divBits + valueEcPrecInt;
                                    if (valueBmBits < vbb)
                                    {
                                        valueBmBits = vbb - valueBmBits;
                                        divisor <<= valueBmBits;
                                        adjust.AddInt(valueBmBits);
                                        optimized = true;
                                    }
                                }
                            }
                        }
                        if (!optimized)
                        {
                            divisor <<= 1;
                            adjust.Increment();
                        }
                        // DebugUtility.Log("deshigh\n==>" + (//
                        // bigmantissa) + "\n-->" + (//
                        // divisor));
                        // DebugUtility.Log("deshigh " + (//
                        // bigmantissa.GetUnsignedBitLength()) + "/" + (//
                        // divisor.GetUnsignedBitLength()));
                        quorem = bigmantissa.DivRem(divisor);
                        if (quorem[1].IsZero)
                        {
                            int valueBmBits = quorem[0].GetUnsignedBitLength();
                            int divBits = desiredLow.GetUnsignedBitLength();
                            if (valueBmBits < divBits)
                            {
                                valueBmBits = divBits - valueBmBits;
                                quorem[0] = quorem[0].ShiftLeft(valueBmBits);
                                adjust.AddInt(valueBmBits);
                            }
                        }
                        // DebugUtility.Log("quorem[0]="+quorem[0]);
                        // DebugUtility.Log("quorem[1]="+quorem[1]);
                        // DebugUtility.Log("desiredLow="+desiredLow);
                        // DebugUtility.Log("desiredHigh="+desiredHigh);
                    } while (quorem[0].CompareTo(desiredHigh) >= 0);
                }
                else if (quorem[0].CompareTo(desiredLow) < 0)
                {
                    do
                    {
                        bool optimized = false;
                        if (bigmantissa.CompareTo(divisor) < 0)
                        {
                            int valueBmBits = bigmantissa.GetUnsignedBitLength();
                            int divBits = divisor.GetUnsignedBitLength();
                            if (valueBmBits < divBits)
                            {
                                valueBmBits = divBits - valueBmBits;
                                bigmantissa <<= valueBmBits;
                                adjust.SubtractInt(valueBmBits);
                                optimized = true;
                            }
                        }
                        else
                        {
                            if (ec.ClampNormalExponents && valueEcPrecInt > 0)
                            {
                                int valueBmBits = bigmantissa.GetUnsignedBitLength();
                                int divBits = divisor.GetUnsignedBitLength();
                                if (valueBmBits >= divBits && valueEcPrecInt <= Int32.MaxValue -
                                     divBits)
                                {
                                    int vbb = divBits + valueEcPrecInt;
                                    if (valueBmBits < vbb)
                                    {
                                        valueBmBits = vbb - valueBmBits;
                                        bigmantissa <<= valueBmBits;
                                        adjust.SubtractInt(valueBmBits);
                                        optimized = true;
                                    }
                                }
                            }
                        }
                        if (!optimized)
                        {
                            bigmantissa <<= 1;
                            adjust.Decrement();
                        }
                        // DebugUtility.Log("deslow " + (//
                        // bigmantissa.GetUnsignedBitLength()) + "/" + (//
                        // divisor.GetUnsignedBitLength()));
                        quorem = bigmantissa.DivRem(divisor);
                        if (quorem[1].IsZero)
                        {
                            int valueBmBits = quorem[0].GetUnsignedBitLength();
                            int divBits = desiredLow.GetUnsignedBitLength();
                            if (valueBmBits < divBits)
                            {
                                valueBmBits = divBits - valueBmBits;
                                quorem[0] = quorem[0].ShiftLeft(valueBmBits);
                                adjust.SubtractInt(valueBmBits);
                            }
                        }
                    } while (quorem[0].CompareTo(desiredLow) < 0);
                }
                // Round to odd to avoid rounding errors
                if (!quorem[1].IsZero && quorem[0].IsEven)
                {
                    quorem[0] = quorem[0].Add(EInteger.One);
                }
                EFloat efret = this.WithThisSign(
          EFloat.Create(
          quorem[0],
          adjust.AsEInteger()));
                // DebugUtility.Log("-->" + (efret.Mantissa.ToRadixString(2)) + " " +
                // (// efret.Exponent));
                efret = efret.RoundToPrecision(ec);
                if (haveCopy && originalEc.HasFlags)
                {
                    originalEc.Flags |= ec.Flags;
                }
                return efret;
            }
        }

        private string ToStringInternal(int mode)
        {
            bool negative = (this.flags & BigNumberFlags.FlagNegative) != 0;
            if (!this.IsFinite)
            {
                if ((this.flags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return negative ? "-Infinity" : "Infinity";
                }
                if ((this.flags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.unsignedMantissa.IsValueZero ?
                      (negative ? "-sNaN" : "sNaN") :
                      (negative ? "-sNaN" + this.unsignedMantissa :
                              "sNaN" + this.unsignedMantissa);
                }
                if ((this.flags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    return this.unsignedMantissa.IsValueZero ? (negative ?
                   "-NaN" : "NaN") : (negative ? "-NaN" + this.unsignedMantissa :
                        "NaN" + this.unsignedMantissa);
                }
            }
            int scaleSign = -this.exponent.Sign;
            string mantissaString = this.unsignedMantissa.ToString();
            if (scaleSign == 0)
            {
                return negative ? "-" + mantissaString : mantissaString;
            }
            bool iszero = this.unsignedMantissa.IsValueZero;
            if (mode == 2 && iszero && scaleSign < 0)
            {
                // special case for zero in plain
                return negative ? "-" + mantissaString : mantissaString;
            }
            StringBuilder builder = null;
            if (mode == 0 && mantissaString.Length < 100 &&
              this.exponent.CanFitInInt32())
            {
                int intExp = this.exponent.AsInt32();
                if (intExp > -100 && intExp < 100)
                {
                    int adj = (intExp + mantissaString.Length) - 1;
                    if (scaleSign >= 0 && adj >= -6)
                    {
                        if (scaleSign > 0)
                        {
                            int dp = intExp + mantissaString.Length;
                            if (dp < 0)
                            {
                                builder = new StringBuilder(mantissaString.Length + 6);
                                if (negative)
                                {
                                    builder.Append("-0.");
                                }
                                else
                                {
                                    builder.Append("0.");
                                }
                                dp = -dp;
                                for (int j = 0; j < dp; ++j)
                                {
                                    builder.Append('0');
                                }
                                builder.Append(mantissaString);
                                return builder.ToString();
                            }
                            else if (dp == 0)
                            {
                                builder = new StringBuilder(mantissaString.Length + 6);
                                if (negative)
                                {
                                    builder.Append("-0.");
                                }
                                else
                                {
                                    builder.Append("0.");
                                }
                                builder.Append(mantissaString);
                                return builder.ToString();
                            }
                            else if (dp > 0 && dp <= mantissaString.Length)
                            {
                                builder = new StringBuilder(mantissaString.Length + 6);
                                if (negative)
                                {
                                    builder.Append('-');
                                }
                                builder.Append(mantissaString, 0, dp);
                                builder.Append('.');
                                builder.Append(
                                  mantissaString,
                                  dp,
                                  mantissaString.Length - dp);
                                return builder.ToString();
                            }
                        }
                    }
                }
            }
            FastInteger adjustedExponent = FastInteger.FromBig(this.Exponent);
            FastInteger builderLength = new FastInteger(mantissaString.Length);
            FastInteger thisExponent = adjustedExponent.Copy();
            adjustedExponent.Add(builderLength).Decrement();
            FastInteger decimalPointAdjust = new FastInteger(1);
            FastInteger threshold = new FastInteger(-6);
            if (mode == 1)
            {
                // engineering string adjustments
                FastInteger newExponent = adjustedExponent.Copy();
                bool adjExponentNegative = adjustedExponent.Sign < 0;
                int intphase = adjustedExponent.Copy().Abs().Remainder(3).AsInt32();
                if (iszero && (adjustedExponent.CompareTo(threshold) < 0 || scaleSign <
                            0))
                {
                    if (intphase == 1)
                    {
                        if (adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Increment();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(2);
                        }
                    }
                    else if (intphase == 2)
                    {
                        if (!adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Increment();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(2);
                        }
                    }
                    threshold.Increment();
                }
                else
                {
                    if (intphase == 1)
                    {
                        if (!adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Decrement();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(-2);
                        }
                    }
                    else if (intphase == 2)
                    {
                        if (adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Decrement();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(-2);
                        }
                    }
                }
                adjustedExponent = newExponent;
            }
            if (mode == 2 || (adjustedExponent.CompareTo(threshold) >= 0 &&
                          scaleSign >= 0))
            {
                if (scaleSign > 0)
                {
                    FastInteger decimalPoint = thisExponent.Copy().Add(builderLength);
                    int cmp = decimalPoint.CompareToInt(0);
                    builder = null;
                    if (cmp < 0)
                    {
                        FastInteger tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                                0 ? Int32.MaxValue : tmpFast.AsInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append("0.");
                        AppendString(builder, '0', decimalPoint.Copy().Negate());
                        builder.Append(mantissaString);
                    }
                    else if (cmp == 0)
                    {
#if DEBUG
                        if (!decimalPoint.CanFitInInt32())
                        {
                            throw new
                           ArgumentException("doesn't satisfy decimalPoint.CanFitInInt32()");
                        }
                        if (decimalPoint.AsInt32() != 0)
                        {
                            throw new
                          ArgumentException("doesn't satisfy decimalPoint.AsInt32() == 0");
                        }
#endif

                        FastInteger tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                                0 ? Int32.MaxValue : tmpFast.AsInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append("0.");
                        builder.Append(mantissaString);
                    }
                    else if (decimalPoint.CompareToInt(mantissaString.Length) > 0)
                    {
                        FastInteger insertionPoint = builderLength;
                        if (!insertionPoint.CanFitInInt32())
                        {
                            throw new NotSupportedException();
                        }
                        int tmpInt = insertionPoint.AsInt32();
                        if (tmpInt < 0)
                        {
                            tmpInt = 0;
                        }
                        FastInteger tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                                0 ? Int32.MaxValue : tmpFast.AsInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString, 0, tmpInt);
                        AppendString(
                          builder,
                          '0',
                          decimalPoint.Copy().SubtractInt(builder.Length));
                        builder.Append('.');
                        builder.Append(
                          mantissaString,
                          tmpInt,
                          mantissaString.Length - tmpInt);
                    }
                    else
                    {
                        if (!decimalPoint.CanFitInInt32())
                        {
                            throw new NotSupportedException();
                        }
                        int tmpInt = decimalPoint.AsInt32();
                        if (tmpInt < 0)
                        {
                            tmpInt = 0;
                        }
                        FastInteger tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                                0 ? Int32.MaxValue : tmpFast.AsInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString, 0, tmpInt);
                        builder.Append('.');
                        builder.Append(
                          mantissaString,
                          tmpInt,
                          mantissaString.Length - tmpInt);
                    }
                    return builder.ToString();
                }
                if (mode == 2 && scaleSign < 0)
                {
                    FastInteger negscale = thisExponent.Copy();
                    builder = new StringBuilder();
                    if (negative)
                    {
                        builder.Append('-');
                    }
                    builder.Append(mantissaString);
                    AppendString(builder, '0', negscale);
                    return builder.ToString();
                }
                return (!negative) ? mantissaString : ("-" + mantissaString);
            }
            else
            {
                if (mode == 1 && iszero && decimalPointAdjust.CompareToInt(1) > 0)
                {
                    builder = new StringBuilder();
                    if (negative)
                    {
                        builder.Append('-');
                    }
                    builder.Append(mantissaString);
                    builder.Append('.');
                    AppendString(
                      builder,
                      '0',
                      decimalPointAdjust.Copy().Decrement());
                }
                else
                {
                    FastInteger tmp = decimalPointAdjust.Copy();
                    int cmp = tmp.CompareToInt(mantissaString.Length);
                    if (cmp > 0)
                    {
                        tmp.SubtractInt(mantissaString.Length);
                        builder = new StringBuilder();
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString);
                        AppendString(builder, '0', tmp);
                    }
                    else if (cmp < 0)
                    {
                        // Insert a decimal point at the right place
                        if (!tmp.CanFitInInt32())
                        {
                            throw new NotSupportedException();
                        }
                        int tmpInt = tmp.AsInt32();
                        if (tmp.Sign < 0)
                        {
                            tmpInt = 0;
                        }
                        FastInteger tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                                0 ? Int32.MaxValue : tmpFast.AsInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString, 0, tmpInt);
                        builder.Append('.');
                        builder.Append(
                          mantissaString,
                          tmpInt,
                          mantissaString.Length - tmpInt);
                    }
                    else if (adjustedExponent.Sign == 0 && !negative)
                    {
                        return mantissaString;
                    }
                    else if (adjustedExponent.Sign == 0 && negative)
                    {
                        return "-" + mantissaString;
                    }
                    else
                    {
                        builder = new StringBuilder();
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString);
                    }
                }
                if (adjustedExponent.Sign != 0)
                {
                    builder.Append(adjustedExponent.Sign < 0 ? "E-" : "E+");
                    adjustedExponent.Abs();
                    StringBuilder builderReversed = new StringBuilder();
                    while (adjustedExponent.Sign != 0)
                    {
                        int digit =
                          adjustedExponent.Copy().Remainder(10).AsInt32();
                        // Each digit is retrieved from right to left
                        builderReversed.Append((char)('0' + digit));
                        adjustedExponent.Divide(10);
                    }
                    int count = builderReversed.Length;
                    string builderReversedString = builderReversed.ToString();
                    for (int i = 0; i < count; ++i)
                    {
                        builder.Append(builderReversedString[count - 1 - i]);
                    }
                }
                return builder.ToString();
            }
        }

        private sealed class DecimalMathHelper : IRadixMathHelper<EDecimal>
        {
            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetRadix"]/*'/>
            public int GetRadix()
            {
                return 10;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetSign(PeterO.Numbers.EDecimal)"]/*'/>
            public int GetSign(EDecimal value)
            {
                return value.Sign;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetMantissa(PeterO.Numbers.EDecimal)"]/*'/>
            public EInteger GetMantissa(EDecimal value)
            {
                return value.unsignedMantissa.ToEInteger();
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetExponent(PeterO.Numbers.EDecimal)"]/*'/>
            public EInteger GetExponent(EDecimal value)
            {
                return value.exponent.ToEInteger();
            }

            public FastIntegerFixed GetMantissaFastInt(EDecimal value)
            {
                return value.unsignedMantissa;
            }

            public FastIntegerFixed GetExponentFastInt(EDecimal value)
            {
                return value.exponent;
            }

            public IShiftAccumulator CreateShiftAccumulatorWithDigits(
              EInteger bigint,
              int lastDigit,
              int olderDigits)
            {
                return new DigitShiftAccumulator(bigint, lastDigit, olderDigits);
            }

            public IShiftAccumulator CreateShiftAccumulatorWithDigitsFastInt(
              FastIntegerFixed fastInt,
              int lastDigit,
              int olderDigits)
            {
                if (fastInt.CanFitInInt32())
                {
                    return new DigitShiftAccumulator(
                   fastInt.AsInt32(),
                   lastDigit,
                   olderDigits);
                }
                else
                {
                    return new DigitShiftAccumulator(
                      fastInt.ToEInteger(),
                      lastDigit,
                      olderDigits);
                }
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)"]/*'/>
            public IShiftAccumulator CreateShiftAccumulator(EInteger bigint)
            {
                return new DigitShiftAccumulator(bigint, 0, 0);
            }

            public FastInteger DivisionShift(
                EInteger num,
                EInteger den)
            {
                if (den.IsZero)
                {
                    return null;
                }
                EInteger gcd = den.Gcd(EInteger.FromInt32(10));
                if (gcd.CompareTo(EInteger.One) == 0)
                {
                    return null;
                }
                if (den.IsZero)
                {
                    return null;
                }
                // Eliminate factors of 2
                int lowBit = den.GetLowBit();
                den >>= lowBit;
                // Eliminate factors of 5
                FastInteger fiveShift = new FastInteger(0);
                while (true)
                {
                    EInteger bigrem;
                    EInteger bigquo;
                    {
                        EInteger[] divrem = den.DivRem((EInteger)5);
                        bigquo = divrem[0];
                        bigrem = divrem[1];
                    }
                    if (!bigrem.IsZero)
                    {
                        break;
                    }
                    fiveShift.Increment();
                    den = bigquo;
                }
                if (den.CompareTo(EInteger.One) != 0)
                {
                    return null;
                }
                if (fiveShift.CompareToInt(lowBit) > 0)
                {
                    return fiveShift;
                }
                else
                {
                    return new FastInteger(lowBit);
                }
            }

            public EInteger MultiplyByRadixPower(
              EInteger bigint,
              FastInteger power)
            {
                EInteger tmpbigint = bigint;
                if (tmpbigint.IsZero)
                {
                    return tmpbigint;
                }
                bool fitsInInt32 = power.CanFitInInt32();
                int powerInt = fitsInInt32 ? power.AsInt32() : 0;
                if (fitsInInt32 && powerInt == 0)
                {
                    return tmpbigint;
                }
                EInteger bigtmp = null;
                if (tmpbigint.CompareTo(EInteger.One) != 0)
                {
                    if (fitsInInt32)
                    {
                        if (powerInt <= 10)
                        {
                            bigtmp = NumberUtility.FindPowerOfTen(powerInt);
                            tmpbigint *= (EInteger)bigtmp;
                        }
                        else
                        {
                            bigtmp = NumberUtility.FindPowerOfFive(powerInt);
                            tmpbigint *= (EInteger)bigtmp;
                            tmpbigint <<= powerInt;
                        }
                    }
                    else
                    {
                        bigtmp = NumberUtility.FindPowerOfTenFromBig(power.AsEInteger());
                        tmpbigint *= (EInteger)bigtmp;
                    }
                    return tmpbigint;
                }
                return fitsInInt32 ? NumberUtility.FindPowerOfTen(powerInt) :
                  NumberUtility.FindPowerOfTenFromBig(power.AsEInteger());
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetFlags(PeterO.Numbers.EDecimal)"]/*'/>
            public int GetFlags(EDecimal value)
            {
                return value.flags;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)"]/*'/>
            public EDecimal CreateNewWithFlags(
              EInteger mantissa,
              EInteger exponent,
              int flags)
            {
                return CreateWithFlags(
          FastIntegerFixed.FromBig(mantissa),
          FastIntegerFixed.FromBig(exponent),
          flags);
            }

            public EDecimal CreateNewWithFlagsFastInt(
              FastIntegerFixed fmantissa,
              FastIntegerFixed fexponent,
              int flags)
            {
                return CreateWithFlags(fmantissa, fexponent, flags);
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetArithmeticSupport"]/*'/>
            public int GetArithmeticSupport()
            {
                return BigNumberFlags.FiniteAndNonFinite;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.ValueOf(System.Int32)"]/*'/>
            public EDecimal ValueOf(int val)
            {
                return (val == 0) ? Zero : ((val == 1) ? One : FromInt64(val));
            }
        }

        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToByteChecked"]/*'/>
        public byte ToByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (byte)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(3) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToByteUnchecked"]/*'/>
        public byte ToByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToByteUnchecked() : (byte)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToByteIfExact"]/*'/>
        public byte ToByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (byte)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(3) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromByte(System.Byte)"]/*'/>
        public static EDecimal FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt16Checked"]/*'/>
        public short ToInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (short)0;
            }
            if (this.exponent.CompareToInt(5) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt16Unchecked"]/*'/>
        public short ToInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt16Unchecked() : (short)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt16IfExact"]/*'/>
        public short ToInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (short)0;
            }
            if (this.exponent.CompareToInt(5) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromInt16(System.Int16)"]/*'/>
        public static EDecimal FromInt16(short inputInt16)
        {
            int val = (int)inputInt16;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt32Checked"]/*'/>
        public int ToInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (int)0;
            }
            if (this.exponent.CompareToInt(10) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt32Unchecked"]/*'/>
        public int ToInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt32Unchecked() : (int)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt32IfExact"]/*'/>
        public int ToInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (int)0;
            }
            if (this.exponent.CompareToInt(10) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt64Checked"]/*'/>
        public long ToInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (long)0;
            }
            if (this.exponent.CompareToInt(19) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt64Unchecked"]/*'/>
        public long ToInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt64Unchecked() : (long)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToInt64IfExact"]/*'/>
        public long ToInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (long)0;
            }
            if (this.exponent.CompareToInt(19) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToInt64Checked();
        }

        // End integer conversions
    }

    public sealed partial class EDecimal
    {
        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToDecimal"]/*'/>
        public decimal ToDecimal()
        {
            EDecimal extendedNumber = this;
            if (extendedNumber.IsInfinity() || extendedNumber.IsNaN())
            {
                throw new OverflowException("This object's value is out of range");
            }
            System.Globalization.NumberStyles
                    ns = System.Globalization.NumberStyles.Number |
                      System.Globalization.NumberStyles.AllowExponent;
            if (
        Decimal.TryParse(
        this.ToString(),
        ns,
        System.Globalization.CultureInfo.InvariantCulture,
        out decimal ret))
            {
                return ret;
            }
            throw new OverflowException("This object's value is out of range");
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromDecimal(System.Decimal)"]/*'/>
        public static EDecimal FromDecimal(decimal dec)
        {
            return

        EDecimal.FromString(dec.ToString(System.Globalization.CultureInfo.InvariantCulture));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Decimal)~PeterO.Numbers.EDecimal"]/*'/>
        public static implicit operator EDecimal(decimal dec)
        {
            return FromDecimal(dec);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Decimal"]/*'/>
        public static explicit operator decimal(EDecimal bigValue)
        {
            return bigValue.ToDecimal();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EDecimal"]/*'/>
        public static implicit operator EDecimal(EInteger eint)
        {
            return FromEInteger(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Addition(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal operator +(EDecimal bthis, EDecimal otherValue)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(otherValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Subtraction(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal operator -(
       EDecimal bthis,
       EDecimal subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal operator *(
        EDecimal operand1,
        EDecimal operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Division(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal operator /(
       EDecimal dividend,
       EDecimal divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Modulus(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal operator %(
       EDecimal dividend,
       EDecimal divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_UnaryNegation(PeterO.Numbers.EDecimal)"]/*'/>
        public static EDecimal operator -(EDecimal bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.EInteger"]/*'/>
        public static explicit operator EInteger(EDecimal bigValue)
        {
            return bigValue.ToEInteger();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Double"]/*'/>
        public static explicit operator double(EDecimal bigValue)
        {
            return bigValue.ToDouble();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Single"]/*'/>
        public static explicit operator float(EDecimal bigValue)
        {
            return bigValue.ToSingle();
        }

        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Byte"]/*'/>
        public static explicit operator byte(EDecimal input)
        {
            return input.ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Byte)~PeterO.Numbers.EDecimal"]/*'/>
        public static implicit operator EDecimal(byte inputByte)
        {
            return EDecimal.FromByte(inputByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToSByteChecked"]/*'/>
        public sbyte ToSByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (sbyte)0;
            }
            if (this.exponent.CompareToInt(3) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToSByteUnchecked"]/*'/>
        public sbyte ToSByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToSByteUnchecked() : (sbyte)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToSByteIfExact"]/*'/>
        public sbyte ToSByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (sbyte)0;
            }
            if (this.exponent.CompareToInt(3) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromSByte(System.SByte)"]/*'/>
        public static EDecimal FromSByte(sbyte inputSByte)
        {
            int val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.SByte"]/*'/>
        
        public static explicit operator sbyte(EDecimal input)
        {
            return input.ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.SByte)~PeterO.Numbers.EDecimal"]/*'/>
        
        public static implicit operator EDecimal(sbyte inputSByte)
        {
            return EDecimal.FromSByte(inputSByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int16"]/*'/>
        public static explicit operator short(EDecimal input)
        {
            return input.ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int16)~PeterO.Numbers.EDecimal"]/*'/>
        public static implicit operator EDecimal(short inputInt16)
        {
            return EDecimal.FromInt16(inputInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt16Checked"]/*'/>
        public ushort ToUInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (ushort)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(5) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt16Unchecked"]/*'/>
        public ushort ToUInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt16Unchecked() : (ushort)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt16IfExact"]/*'/>
        public ushort ToUInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (ushort)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(5) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromUInt16(System.UInt16)"]/*'/>
        public static EDecimal FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt16"]/*'/>
        
        public static explicit operator ushort(EDecimal input)
        {
            return input.ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt16)~PeterO.Numbers.EDecimal"]/*'/>
        
        public static implicit operator EDecimal(ushort inputUInt16)
        {
            return EDecimal.FromUInt16(inputUInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int32"]/*'/>
        public static explicit operator int(EDecimal input)
        {
            return input.ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int32)~PeterO.Numbers.EDecimal"]/*'/>
        public static implicit operator EDecimal(int inputInt32)
        {
            return EDecimal.FromInt32(inputInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt32Checked"]/*'/>
        public uint ToUInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (uint)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(10) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt32Unchecked"]/*'/>
        public uint ToUInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt32Unchecked() : (uint)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt32IfExact"]/*'/>
        public uint ToUInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (uint)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(10) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromUInt32(System.UInt32)"]/*'/>
        public static EDecimal FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt32"]/*'/>
        
        public static explicit operator uint(EDecimal input)
        {
            return input.ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt32)~PeterO.Numbers.EDecimal"]/*'/>
        
        public static implicit operator EDecimal(uint inputUInt32)
        {
            return EDecimal.FromUInt32(inputUInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int64"]/*'/>
        public static explicit operator long(EDecimal input)
        {
            return input.ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int64)~PeterO.Numbers.EDecimal"]/*'/>
        public static implicit operator EDecimal(long inputInt64)
        {
            return EDecimal.FromInt64(inputInt64);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt64Checked"]/*'/>
        public ulong ToUInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (ulong)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(20) >= 0)
            {
                throw new OverflowException("Value out of range: ");
            }
            return this.ToEInteger().ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt64Unchecked"]/*'/>
        public ulong ToUInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt64Unchecked() : (ulong)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.ToUInt64IfExact"]/*'/>
        public ulong ToUInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (ulong)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(20) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.FromUInt64(System.UInt64)"]/*'/>
        public static EDecimal FromUInt64(ulong inputUInt64)
        {
            return FromEInteger(EInteger.FromUInt64(inputUInt64));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt64"]/*'/>
        public static explicit operator ulong(EDecimal input)
        {
            return input.ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt64)~PeterO.Numbers.EDecimal"]/*'/>
        
        public static implicit operator EDecimal(ulong inputUInt64)
        {
            return EDecimal.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EFloat"]/*'/>
    public sealed partial class EFloat : IComparable<EFloat>,
    IEquatable<EFloat>
    {
        //----------------------------------------------------------------

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.NaN"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat NaN = CreateWithFlags(
          EInteger.Zero,
          EInteger.Zero,
          BigNumberFlags.FlagQuietNaN);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.NegativeInfinity"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat NegativeInfinity = CreateWithFlags(
          EInteger.Zero,
          EInteger.Zero,
          BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.NegativeZero"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat NegativeZero = CreateWithFlags(
          EInteger.Zero,
          EInteger.Zero,
          BigNumberFlags.FlagNegative);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.One"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat One =
          EFloat.Create(EInteger.One, EInteger.Zero);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.PositiveInfinity"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat PositiveInfinity = CreateWithFlags(
          EInteger.Zero,
          EInteger.Zero,
          BigNumberFlags.FlagInfinity);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.SignalingNaN"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat SignalingNaN = CreateWithFlags(
          EInteger.Zero,
          EInteger.Zero,
          BigNumberFlags.FlagSignalingNaN);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.Ten"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat Ten =
          EFloat.Create((EInteger)10, EInteger.Zero);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.EFloat.Zero"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "EFloat is immutable")]
        public static readonly EFloat Zero =
          EFloat.Create(EInteger.Zero, EInteger.Zero);
        //----------------------------------------------------------------
        private static readonly IRadixMath<EFloat> MathValue = new
          TrappableRadixMath<EFloat>(
            new ExtendedOrSimpleRadixMath<EFloat>(new BinaryMathHelper()));

        private readonly EInteger exponent;
        private readonly int flags;
        private readonly EInteger unsignedMantissa;

        private EFloat(
          EInteger unsignedMantissa,
          EInteger exponent,
          int flags)
        {
#if DEBUG
            if (unsignedMantissa == null)
            {
                throw new ArgumentNullException(nameof(unsignedMantissa));
            }

            if (unsignedMantissa.Sign < 0)
            {
                throw new ArgumentException("unsignedMantissa is less than 0.");
            }
#endif
            this.unsignedMantissa = unsignedMantissa;
            this.exponent = exponent ?? throw new ArgumentNullException(nameof(exponent));
            this.flags = flags;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EFloat.Exponent"]/*'/>
        public EInteger Exponent
        {
            get
            {
                return this.exponent;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EFloat.IsFinite"]/*'/>
        public bool IsFinite
        {
            get
            {
                return (this.flags & (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNaN)) == 0;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EFloat.IsNegative"]/*'/>
        public bool IsNegative
        {
            get
            {
                return (this.flags & BigNumberFlags.FlagNegative) != 0;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EFloat.IsZero"]/*'/>
        public bool IsZero
        {
            get
            {
                return ((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                  this.unsignedMantissa.IsZero;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EFloat.Mantissa"]/*'/>
        public EInteger Mantissa
        {
            get
            {
                return this.IsNegative ? (-(EInteger)this.unsignedMantissa) :
                  this.unsignedMantissa;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EFloat.Sign"]/*'/>
        public int Sign
        {
            get
            {
                return (((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                        this.unsignedMantissa.IsZero) ? 0 :
                  (((this.flags & BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EFloat.UnsignedMantissa"]/*'/>
        public EInteger UnsignedMantissa
        {
            get
            {
                return this.unsignedMantissa;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Create(System.Int32,System.Int32)"]/*'/>
        public static EFloat Create(int mantissaSmall, int exponentSmall)
        {
            return Create((EInteger)mantissaSmall, (EInteger)exponentSmall);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EFloat Create(
          EInteger mantissa,
          EInteger exponent)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            int sign = mantissa.Sign;
            return new EFloat(
              sign < 0 ? (-(EInteger)mantissa) : mantissa,
              exponent,
              (sign < 0) ? BigNumberFlags.FlagNegative : 0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger)"]/*'/>
        public static EFloat CreateNaN(EInteger diag)
        {
            return CreateNaN(diag, false, false, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)"]/*'/>
        public static EFloat CreateNaN(
          EInteger diag,
          bool signaling,
          bool negative,
          EContext ctx)
        {
            if (diag == null)
            {
                throw new ArgumentNullException(nameof(diag));
            }
            if (diag.Sign < 0)
            {
                throw new
          ArgumentException("Diagnostic information must be 0 or greater, was: " +
                            diag);
            }
            if (diag.IsZero && !negative)
            {
                return signaling ? SignalingNaN : NaN;
            }
            int flags = 0;
            if (negative)
            {
                flags |= BigNumberFlags.FlagNegative;
            }
            if (ctx != null && ctx.HasMaxPrecision)
            {
                flags |= BigNumberFlags.FlagQuietNaN;
                EFloat ef = CreateWithFlags(
                  diag,
                  EInteger.Zero,
                  flags).RoundToPrecision(ctx);
                int newFlags = ef.flags;
                newFlags &= ~BigNumberFlags.FlagQuietNaN;
                newFlags |= signaling ? BigNumberFlags.FlagSignalingNaN :
                  BigNumberFlags.FlagQuietNaN;
                return new EFloat(ef.unsignedMantissa, ef.exponent, newFlags);
            }
            flags |= signaling ? BigNumberFlags.FlagSignalingNaN :
              BigNumberFlags.FlagQuietNaN;
            return CreateWithFlags(diag, EInteger.Zero, flags);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromDouble(System.Double)"]/*'/>
        public static EFloat FromDouble(double dbl)
        {
            int[] value = Extras.DoubleToIntegers(dbl);
            int floatExponent = (int)((value[1] >> 20) & 0x7ff);
            bool neg = (value[1] >> 31) != 0;
            long lvalue;
            if (floatExponent == 2047)
            {
                if ((value[1] & 0xfffff) == 0 && value[0] == 0)
                {
                    return neg ? NegativeInfinity : PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = (value[1] & 0x80000) != 0;
                value[1] &= 0x7ffff;
                lvalue = unchecked((value[0] & 0xffffffffL) | ((long)value[1] << 32));
                if (lvalue == 0)
                {
                    return quiet ? NaN : SignalingNaN;
                }
                value[0] = (neg ? BigNumberFlags.FlagNegative : 0) |
               (quiet ? BigNumberFlags.FlagQuietNaN : BigNumberFlags.FlagSignalingNaN);
                return CreateWithFlags(
                  EInteger.FromInt64(lvalue),
                  EInteger.Zero,
                  value[0]);
            }
            value[1] &= 0xfffff;  // Mask out the exponent and sign
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                value[1] |= 0x100000;
            }
            if ((value[1] | value[0]) != 0)
            {
                floatExponent += NumberUtility.ShiftAwayTrailingZerosTwoElements(value);
            }
            else
            {
                return neg ? EFloat.NegativeZero : EFloat.Zero;
            }
            lvalue = unchecked((value[0] & 0xffffffffL) | ((long)value[1] << 32));
            return CreateWithFlags(
              EInteger.FromInt64(lvalue),
              (EInteger)(floatExponent - 1075),
              neg ? BigNumberFlags.FlagNegative : 0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromEInteger(PeterO.Numbers.EInteger)"]/*'/>
        public static EFloat FromEInteger(EInteger bigint)
        {
            return EFloat.Create(bigint, EInteger.Zero);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromSingle(System.Single)"]/*'/>
        public static EFloat FromSingle(float flt)
        {
            int value = BitConverter.ToInt32(BitConverter.GetBytes((float)flt), 0);
            bool neg = (value >> 31) != 0;
            int floatExponent = (int)((value >> 23) & 0xff);
            int valueFpMantissa = value & 0x7fffff;
            EInteger bigmant;
            if (floatExponent == 255)
            {
                if (valueFpMantissa == 0)
                {
                    return neg ? NegativeInfinity : PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = (valueFpMantissa & 0x400000) != 0;
                valueFpMantissa &= 0x3fffff;
                bigmant = (EInteger)valueFpMantissa;
                value = (neg ? BigNumberFlags.FlagNegative : 0) | (quiet ?
                        BigNumberFlags.FlagQuietNaN : BigNumberFlags.FlagSignalingNaN);
                if (bigmant.IsZero)
                {
                    return quiet ? NaN : SignalingNaN;
                }
                return CreateWithFlags(
                  bigmant,
                  EInteger.Zero,
                  value);
            }
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                valueFpMantissa |= 1 << 23;
            }
            if (valueFpMantissa == 0)
            {
                return neg ? EFloat.NegativeZero : EFloat.Zero;
            }
            while ((valueFpMantissa & 1) == 0)
            {
                ++floatExponent;
                valueFpMantissa >>= 1;
            }
            if (neg)
            {
                valueFpMantissa = -valueFpMantissa;
            }
            bigmant = (EInteger)valueFpMantissa;
            return EFloat.Create(
              bigmant,
              (EInteger)(floatExponent - 150));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public static EFloat FromString(
          string str,
          int offset,
          int length,
          EContext ctx)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return EDecimal.FromString(
              str,
              offset,
              length,
              EContext.Unlimited.WithSimplified(ctx != null && ctx.IsSimplified))
              .ToEFloat(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromString(System.String)"]/*'/>
        public static EFloat FromString(string str)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromString(System.String,PeterO.Numbers.EContext)"]/*'/>
        public static EFloat FromString(string str, EContext ctx)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32)"]/*'/>
        public static EFloat FromString(string str, int offset, int length)
        {
            return FromString(str, offset, length, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public static EFloat Max(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            return MathValue.Max(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat Max(
          EFloat first,
          EFloat second)
        {
            return Max(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public static EFloat MaxMagnitude(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            return MathValue.MaxMagnitude(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat MaxMagnitude(
          EFloat first,
          EFloat second)
        {
            return MaxMagnitude(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public static EFloat Min(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            return MathValue.Min(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat Min(
          EFloat first,
          EFloat second)
        {
            return Min(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public static EFloat MinMagnitude(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            return MathValue.MinMagnitude(first, second, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat MinMagnitude(
          EFloat first,
          EFloat second)
        {
            return MinMagnitude(first, second, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.PI(PeterO.Numbers.EContext)"]/*'/>
        public static EFloat PI(EContext ctx)
        {
            return MathValue.Pi(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Abs"]/*'/>
        public EFloat Abs()
        {
            if (this.IsNegative)
            {
                EFloat er = new EFloat(
          this.unsignedMantissa,
          this.exponent,
          this.flags & ~BigNumberFlags.FlagNegative);
                return er;
            }
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Abs(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Abs(EContext context)
        {
            return MathValue.Abs(this, context);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Add(System.Int32)"]/*'/>
        public EFloat Add(int intValue)
        {
            return this.Add(EFloat.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Subtract(System.Int32)"]/*'/>
        public EFloat Subtract(int intValue)
        {
            return (intValue == Int32.MinValue) ?
              this.Subtract(EFloat.FromInt32(intValue)) : this.Add(-intValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Multiply(System.Int32)"]/*'/>
        public EFloat Multiply(int intValue)
        {
            return this.Multiply(EFloat.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Divide(System.Int32)"]/*'/>
        public EFloat Divide(int intValue)
        {
            return this.Divide(EFloat.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat Add(EFloat otherValue)
        {
            return this.Add(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Add(
          EFloat otherValue,
          EContext ctx)
        {
            return MathValue.Add(this, otherValue, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CompareTo(PeterO.Numbers.EFloat)"]/*'/>
        public int CompareTo(EFloat other)
        {
            return MathValue.CompareTo(this, other);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CompareToSignal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat CompareToSignal(
          EFloat other,
          EContext ctx)
        {
            return MathValue.CompareToWithContext(this, other, true, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public int CompareToTotal(EFloat other, EContext ctx)
        {
            if (other == null)
            {
                return -1;
            }
            if (this.IsSignalingNaN() || other.IsSignalingNaN())
            {
                return this.CompareToTotal(other);
            }
            if (ctx != null && ctx.IsSimplified)
            {
                return this.RoundToPrecision(ctx)
                  .CompareToTotal(other.RoundToPrecision(ctx));
            }
            else
            {
                return this.CompareToTotal(other);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat)"]/*'/>
        public int CompareToTotal(EFloat other)
        {
            if (other == null)
            {
                return -1;
            }
            bool neg1 = this.IsNegative;
            bool neg2 = other.IsNegative;
            if (neg1 != neg2)
            {
                return neg1 ? -1 : 1;
            }
            int valueIThis = 0;
            int valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return neg1 ? -1 : 1;
            }
            else if (valueIThis < valueIOther)
            {
                return neg1 ? 1 : -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                 other.unsignedMantissa);
                return neg1 ? -cmp : cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.CompareTo(other);
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                     other.exponent);
                    return neg1 ? -cmp : cmp;
                }
                return cmp;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CompareToTotalMagnitude(PeterO.Numbers.EFloat)"]/*'/>
        public int CompareToTotalMagnitude(EFloat other)
        {
            if (other == null)
            {
                return -1;
            }
            int valueIThis = 0;
            int valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return 1;
            }
            else if (valueIThis < valueIOther)
            {
                return -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                 other.unsignedMantissa);
                return cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.Abs().CompareTo(other.Abs());
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                     other.exponent);
                    return cmp;
                }
                return cmp;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CompareToWithContext(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat CompareToWithContext(
          EFloat other,
          EContext ctx)
        {
            return MathValue.CompareToWithContext(this, other, false, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.CopySign(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat CopySign(EFloat other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (this.IsNegative)
            {
                return other.IsNegative ? this : this.Negate();
            }
            else
            {
                return other.IsNegative ? this.Negate() : this;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat Divide(EFloat divisor)
        {
            return this.Divide(
              divisor,
              EContext.ForRounding(ERounding.None));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Divide(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.Divide(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat)"]/*'/>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EFloat[] DivideAndRemainderNaturalScale(EFloat
          divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EFloat[] DivideAndRemainderNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            return this.DivRemNaturalScale(divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.EContext)"]/*'/>
        public EFloat DivideToExponent(
          EFloat divisor,
          long desiredExponentSmall,
          EContext ctx)
        {
            return this.DivideToExponent(
              divisor,
              EInteger.FromInt64(desiredExponentSmall),
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.ERounding)"]/*'/>
        public EFloat DivideToExponent(
          EFloat divisor,
          long desiredExponentSmall,
          ERounding rounding)
        {
            return this.DivideToExponent(
              divisor,
              EInteger.FromInt64(desiredExponentSmall),
              EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EFloat DivideToExponent(
          EFloat divisor,
          EInteger exponent,
          EContext ctx)
        {
            return MathValue.DivideToExponent(this, divisor, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)"]/*'/>
        public EFloat DivideToExponent(
          EFloat divisor,
          EInteger desiredExponent,
          ERounding rounding)
        {
            return this.DivideToExponent(
              divisor,
              desiredExponent,
              EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat DivideToIntegerNaturalScale(
          EFloat divisor)
        {
            return this.DivideToIntegerNaturalScale(
              divisor,
              EContext.ForRounding(ERounding.Down));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat DivideToIntegerNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.DivideToIntegerNaturalScale(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToIntegerZeroScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat DivideToIntegerZeroScale(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.DivideToIntegerZeroScale(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivideToSameExponent(PeterO.Numbers.EFloat,PeterO.Numbers.ERounding)"]/*'/>
        public EFloat DivideToSameExponent(
          EFloat divisor,
          ERounding rounding)
        {
            return this.DivideToExponent(
              divisor,
              this.exponent,
              EContext.ForRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat[] DivRemNaturalScale(EFloat divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat[] DivRemNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            EFloat[] result = new EFloat[2];
            result[0] = this.DivideToIntegerNaturalScale(divisor, null);
            result[1] = this.Subtract(
              result[0].Multiply(divisor, null),
              ctx);
            result[0] = result[0].RoundToPrecision(ctx);
            return result;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Equals(PeterO.Numbers.EFloat)"]/*'/>
        public bool Equals(EFloat other)
        {
            return this.EqualsInternal(other);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Equals(System.Object)"]/*'/>
        public override bool Equals(object obj)
        {
            return this.EqualsInternal(obj as EFloat);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.EqualsInternal(PeterO.Numbers.EFloat)"]/*'/>
        public bool EqualsInternal(EFloat otherValue)
        {
            if (otherValue == null)
            {
                return false;
            }
            return this.exponent.Equals(otherValue.exponent) &&
              this.unsignedMantissa.Equals(otherValue.unsignedMantissa) &&
              this.flags == otherValue.flags;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Exp(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Exp(EContext ctx)
        {
            return MathValue.Exp(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.GetHashCode"]/*'/>
        public override int GetHashCode()
        {
            int hashCode = 403796923;
            unchecked
            {
                hashCode += 403797019 * this.exponent.GetHashCode();
                hashCode += 403797059 * this.unsignedMantissa.GetHashCode();
                hashCode += 403797127 * this.flags;
            }
            return hashCode;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.IsInfinity"]/*'/>
        public bool IsInfinity()
        {
            return (this.flags & BigNumberFlags.FlagInfinity) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.IsNaN"]/*'/>
        public bool IsNaN()
        {
            return (this.flags & (BigNumberFlags.FlagQuietNaN |
                          BigNumberFlags.FlagSignalingNaN)) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.IsNegativeInfinity"]/*'/>
        public bool IsNegativeInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                          BigNumberFlags.FlagNegative)) ==
              (BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.IsPositiveInfinity"]/*'/>
        public bool IsPositiveInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                      BigNumberFlags.FlagNegative)) == BigNumberFlags.FlagInfinity;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.IsQuietNaN"]/*'/>
        public bool IsQuietNaN()
        {
            return (this.flags & BigNumberFlags.FlagQuietNaN) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.IsSignalingNaN"]/*'/>
        public bool IsSignalingNaN()
        {
            return (this.flags & BigNumberFlags.FlagSignalingNaN) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Log(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Log(EContext ctx)
        {
            return MathValue.Ln(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Log10(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Log10(EContext ctx)
        {
            return MathValue.Log10(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32)"]/*'/>
        public EFloat MovePointLeft(int places)
        {
            return this.MovePointLeft((EInteger)places, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EFloat MovePointLeft(int places, EContext ctx)
        {
            return this.MovePointLeft((EInteger)places, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger)"]/*'/>
        public EFloat MovePointLeft(EInteger bigPlaces)
        {
            return this.MovePointLeft(bigPlaces, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EFloat MovePointLeft(
      EInteger bigPlaces,
      EContext ctx)
        {
            return (!this.IsFinite) ? this.RoundToPrecision(ctx) :
              this.MovePointRight(-(EInteger)bigPlaces, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32)"]/*'/>
        public EFloat MovePointRight(int places)
        {
            return this.MovePointRight((EInteger)places, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EFloat MovePointRight(int places, EContext ctx)
        {
            return this.MovePointRight((EInteger)places, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger)"]/*'/>
        public EFloat MovePointRight(EInteger bigPlaces)
        {
            return this.MovePointRight(bigPlaces, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EFloat MovePointRight(
      EInteger bigPlaces,
      EContext ctx)
        {
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            if (bigExp.Sign > 0)
            {
                EInteger mant = NumberUtility.ShiftLeft(
                  this.unsignedMantissa,
                  bigExp);
                return CreateWithFlags(
          mant,
          EInteger.Zero,
          this.flags).RoundToPrecision(ctx);
            }
            return CreateWithFlags(
              this.unsignedMantissa,
              bigExp,
              this.flags).RoundToPrecision(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat Multiply(EFloat otherValue)
        {
            if (this.IsFinite && otherValue.IsFinite)
            {
                EInteger exp = this.exponent.Add(otherValue.exponent);
                int newflags = otherValue.flags ^ this.flags;
                if (this.unsignedMantissa.CanFitInInt32() &&
                  otherValue.unsignedMantissa.CanFitInInt32())
                {
                    int integerA = this.unsignedMantissa.ToInt32Unchecked();
                    int integerB = otherValue.unsignedMantissa.ToInt32Unchecked();
                    long longA = ((long)integerA) * ((long)integerB);
                    return CreateWithFlags((EInteger)longA, exp, newflags);
                }
                else
                {
                    EInteger eintA = this.unsignedMantissa.Multiply(
                     otherValue.unsignedMantissa);
                    return CreateWithFlags(eintA, exp, newflags);
                }
            }
            return this.Multiply(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Multiply(
          EFloat op,
          EContext ctx)
        {
            return MathValue.Multiply(this, op, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public EFloat MultiplyAndAdd(
          EFloat multiplicand,
          EFloat augend)
        {
            return this.MultiplyAndAdd(multiplicand, augend, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat MultiplyAndAdd(
          EFloat op,
          EFloat augend,
          EContext ctx)
        {
            return MathValue.MultiplyAndAdd(this, op, augend, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.MultiplyAndSubtract(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat MultiplyAndSubtract(
          EFloat op,
          EFloat subtrahend,
          EContext ctx)
        {
            if (op == null)
            {
                throw new ArgumentNullException(nameof(op));
            }
            if (subtrahend == null)
            {
                throw new ArgumentNullException(nameof(subtrahend));
            }
            EFloat negated = subtrahend;
            if ((subtrahend.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = subtrahend.flags ^ BigNumberFlags.FlagNegative;
                negated = CreateWithFlags(
                  subtrahend.unsignedMantissa,
                  subtrahend.exponent,
                  newflags);
            }
            return MathValue.MultiplyAndAdd(this, op, negated, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Negate"]/*'/>
        public EFloat Negate()
        {
            return new EFloat(
        this.unsignedMantissa,
        this.exponent,
        this.flags ^ BigNumberFlags.FlagNegative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Negate(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Negate(EContext context)
        {
            return MathValue.Negate(this, context);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.NextMinus(PeterO.Numbers.EContext)"]/*'/>
        public EFloat NextMinus(EContext ctx)
        {
            return MathValue.NextMinus(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.NextPlus(PeterO.Numbers.EContext)"]/*'/>
        public EFloat NextPlus(EContext ctx)
        {
            return MathValue.NextPlus(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.NextToward(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat NextToward(
          EFloat otherValue,
          EContext ctx)
        {
            return MathValue.NextToward(this, otherValue, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Plus(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Plus(EContext ctx)
        {
            return MathValue.Plus(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Pow(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Pow(EFloat exponent, EContext ctx)
        {
            return MathValue.Power(this, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Pow(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Pow(int exponentSmall, EContext ctx)
        {
            return this.Pow(EFloat.FromInt64(exponentSmall), ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Pow(System.Int32)"]/*'/>
        public EFloat Pow(int exponentSmall)
        {
            return this.Pow(EFloat.FromInt64(exponentSmall), null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Precision"]/*'/>
        public EInteger Precision()
        {
            if (!this.IsFinite)
            {
                return EInteger.Zero;
            }
            if (this.IsZero)
            {
                return EInteger.One;
            }
            int bitlen = this.unsignedMantissa.GetSignedBitLength();
            return (EInteger)bitlen;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Quantize(
          EInteger desiredExponent,
          EContext ctx)
        {
            return this.Quantize(
              EFloat.Create(EInteger.One, desiredExponent),
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Quantize(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Quantize(
          int desiredExponentInt,
          EContext ctx)
        {
            return this.Quantize(
              EFloat.Create(EInteger.One, (EInteger)desiredExponentInt),
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Quantize(
          EFloat otherValue,
          EContext ctx)
        {
            return MathValue.Quantize(this, otherValue, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Reduce(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Reduce(EContext ctx)
        {
            return MathValue.Reduce(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Remainder(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Remainder(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.Remainder(this, divisor, ctx, true);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Remainder(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat RemainderNoRoundAfterDivide(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.Remainder(this, divisor, ctx, false);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat RemainderNaturalScale(
          EFloat divisor)
        {
            return this.RemainderNaturalScale(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat RemainderNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            return this.Subtract(
              this.DivideToIntegerNaturalScale(divisor, null).Multiply(divisor, null),
              ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RemainderNear(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat RemainderNear(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.RemainderNear(this, divisor, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EFloat RoundToExponent(
          EInteger exponent,
          EContext ctx)
        {
            return MathValue.RoundToExponentSimple(this, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToExponent(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EFloat RoundToExponent(
          int exponentSmall,
          EContext ctx)
        {
            return this.RoundToExponent((EInteger)exponentSmall, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EFloat RoundToExponentExact(
          EInteger exponent,
          EContext ctx)
        {
            return MathValue.RoundToExponentExact(this, exponent, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)"]/*'/>
        public EFloat RoundToExponentExact(
          EInteger exponent,
          ERounding rounding)
        {
            return MathValue.RoundToExponentExact(
       this,
       exponent,
       EContext.Unlimited.WithRounding(rounding));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EFloat RoundToExponentExact(
          int exponentSmall,
          EContext ctx)
        {
            return this.RoundToExponentExact((EInteger)exponentSmall, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToIntegerExact(PeterO.Numbers.EContext)"]/*'/>
        public EFloat RoundToIntegerExact(EContext ctx)
        {
            return MathValue.RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)"]/*'/>
        public EFloat RoundToIntegerNoRoundedFlag(EContext ctx)
        {
            return MathValue.RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToIntegralExact(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to RoundToIntegerExact.")]
        public EFloat RoundToIntegralExact(EContext ctx)
        {
            return MathValue.RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to RoundToIntegerNoRoundedFlag.")]
        public EFloat RoundToIntegralNoRoundedFlag(EContext ctx)
        {
            return MathValue.RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.RoundToPrecision(PeterO.Numbers.EContext)"]/*'/>
        public EFloat RoundToPrecision(EContext ctx)
        {
            return MathValue.RoundToPrecision(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32)"]/*'/>
        public EFloat ScaleByPowerOfTwo(int places)
        {
            return this.ScaleByPowerOfTwo((EInteger)places, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32,PeterO.Numbers.EContext)"]/*'/>
        public EFloat ScaleByPowerOfTwo(int places, EContext ctx)
        {
            return this.ScaleByPowerOfTwo((EInteger)places, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger)"]/*'/>
        public EFloat ScaleByPowerOfTwo(EInteger bigPlaces)
        {
            return this.ScaleByPowerOfTwo(bigPlaces, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)"]/*'/>
        public EFloat ScaleByPowerOfTwo(
      EInteger bigPlaces,
      EContext ctx)
        {
            if (bigPlaces.IsZero)
            {
                return this.RoundToPrecision(ctx);
            }
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            return CreateWithFlags(
              this.unsignedMantissa,
              bigExp,
              this.flags).RoundToPrecision(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Sqrt(PeterO.Numbers.EContext)"]/*'/>
        public EFloat Sqrt(EContext ctx)
        {
            return MathValue.SquareRoot(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.SquareRoot(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to Sqrt.")]
        public EFloat SquareRoot(EContext ctx)
        {
            return MathValue.SquareRoot(this, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat)"]/*'/>
        public EFloat Subtract(EFloat otherValue)
        {
            return this.Subtract(otherValue, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)"]/*'/>
        public EFloat Subtract(
          EFloat otherValue,
          EContext ctx)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            EFloat negated = otherValue;
            if ((otherValue.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = otherValue.flags ^ BigNumberFlags.FlagNegative;
                negated = CreateWithFlags(
                  otherValue.unsignedMantissa,
                  otherValue.exponent,
                  newflags);
            }
            return this.Add(negated, ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToDouble"]/*'/>
        public double ToDouble()
        {
            if (this.IsPositiveInfinity())
            {
                return Double.PositiveInfinity;
            }
            if (this.IsNegativeInfinity())
            {
                return Double.NegativeInfinity;
            }
            if (this.IsNaN())
            {
                int[] nan = { 0, 0x7ff00000 };
                if (this.IsNegative)
                {
                    nan[1] |= unchecked((int)(1 << 31));
                }
                if (this.IsQuietNaN())
                {
                    nan[1] |= 0x80000;
                }
                else if (this.UnsignedMantissa.IsZero)
                {
                    // Set the 0x40000 bit to keep the mantissa from
                    // being zero if this is a signaling NaN
                    nan[1] |= 0x40000;
                }
                if (!this.UnsignedMantissa.IsZero)
                {
                    // Copy diagnostic information
                    int[] words = FastInteger.GetLastWords(this.UnsignedMantissa, 2);
                    nan[0] = words[0];
                    nan[1] |= words[1] & 0x7ffff;
                    if ((words[0] | (words[1] & 0x7ffff)) == 0 && !this.IsQuietNaN())
                    {
                        // Set the 0x40000 bit to keep the mantissa from
                        // being zero if this is a signaling NaN
                        nan[1] |= 0x40000;
                    }
                }
                return Extras.IntegersToDouble(nan);
            }
            EFloat thisValue = this.RoundToPrecision(EContext.Binary64);
            if (!thisValue.IsFinite)
            {
                return thisValue.ToDouble();
            }
            EInteger mant = thisValue.unsignedMantissa;
            if (thisValue.IsNegative && mant.IsZero)
            {
                return Extras.IntegersToDouble(new[] { 0, unchecked((int)(1 << 31)) });
            }
            else if (mant.IsZero)
            {
                return 0.0;
            }
            // DebugUtility.Log("-->" + (//
            // thisValue.unsignedMantissa.ToRadixString(2)) + ", " + (//
            // thisValue.exponent));
            int bitLength = mant.GetUnsignedBitLength();
            int expo = thisValue.exponent.ToInt32Checked();
            bool subnormal = false;
            if (bitLength < 53)
            {
                int diff = 53 - bitLength;
                expo -= diff;
                if (expo < -1074)
                {
                    // DebugUtility.Log("Diff changed from " + diff + " to " + (diff -
                    // (-1074 - expo)));
                    diff -= -1074 - expo;
                    expo = -1074;
                    subnormal = true;
                }
                mant <<= diff;
                bitLength += diff;
            }
            // DebugUtility.Log("2->" + (mant.ToRadixString(2)) + ", " + expo);
            int[] mantissaBits;
            mantissaBits = FastInteger.GetLastWords(mant, 2);
            // Clear the high bits where the exponent and sign are
            mantissaBits[1] &= 0xfffff;
            if (!subnormal)
            {
                int smallexponent = (expo + 1075) << 20;
                mantissaBits[1] |= smallexponent;
            }
            if (this.IsNegative)
            {
                mantissaBits[1] |= unchecked((int)(1 << 31));
            }
            return Extras.IntegersToDouble(mantissaBits);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToEDecimal"]/*'/>
        public EDecimal ToEDecimal()
        {
            return EDecimal.FromEFloat(this);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToEInteger"]/*'/>
        public EInteger ToEInteger()
        {
            return this.ToEIntegerInternal(false);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToEIntegerExact"]/*'/>
        [Obsolete("Renamed to ToEIntegerIfExact.")]
        public EInteger ToEIntegerExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToEIntegerIfExact"]/*'/>
        public EInteger ToEIntegerIfExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToEngineeringString"]/*'/>
        public string ToEngineeringString()
        {
            return this.ToEDecimal().ToEngineeringString();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToExtendedDecimal"]/*'/>
        [Obsolete("Renamed to ToEDecimal.")]
        public EDecimal ToExtendedDecimal()
        {
            return EDecimal.FromEFloat(this);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToPlainString"]/*'/>
        public string ToPlainString()
        {
            return this.ToEDecimal().ToPlainString();
        }

        private string ToDebugString()
        {
            return "[" + this.Mantissa.ToRadixString(2) +
              "," + this.Mantissa.GetUnsignedBitLength() +
              "," + this.Exponent + "]";
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToShortestString(PeterO.Numbers.EContext)"]/*'/>
        public string ToShortestString(EContext ctx)
        {
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return this.ToString();
            }
            if (this.IsNaN())
            {
                return CreateNaN(
          this.UnsignedMantissa,
          this.IsSignalingNaN(),
          this.IsNegative,
          ctx).ToString();
            }
            if (this.IsInfinity())
            {
                return this.RoundToPrecision(ctx).ToString();
            }
            EContext ctx2 = ctx.WithNoFlags();
            EFloat valueEfRnd = this.RoundToPrecision(ctx);
            if (valueEfRnd.IsInfinity())
            {
                return valueEfRnd.ToString();
            }
            // NOTE: The original EFloat is converted to decimal,
            // not the rounded version, to avoid double rounding issues
            bool mantissaIsPowerOfTwo = this.unsignedMantissa.IsPowerOfTwo;
            EDecimal dec = this.ToEDecimal();
            if (ctx.Precision.CompareTo(EInteger.FromInt32(10)) >= 0)
            {
                // Preround the decimal so the significand has closer to the
                // number of decimal digits of the maximum possible
                // decimal significand, to speed up further rounding
                EInteger roundedPrec = ctx.Precision.ShiftRight(1).Add(
                  EInteger.FromInt32(3));
                dec = dec.RoundToPrecision(
                  ctx2.WithRounding(ERounding.Odd).WithBigPrecision(roundedPrec));
            }
            // int precision = dec.UnsignedMantissa.GetDigitCount();
            EInteger eprecision = EInteger.Zero;
            while (true)
            {
                EInteger nextPrecision = eprecision.Add(EInteger.One);
                EContext nextCtx = ctx2.WithBigPrecision(nextPrecision);
                EDecimal nextDec = dec.RoundToPrecision(nextCtx);
                EFloat newFloat = nextDec.ToEFloat(ctx2);
                if (newFloat.CompareTo(valueEfRnd) == 0)
                {
                    if (mantissaIsPowerOfTwo)
                    {
                        nextPrecision = eprecision;
                        nextCtx = ctx2.WithBigPrecision(nextPrecision);
                        EDecimal nextDec2 = dec.RoundToPrecision(nextCtx);
                        nextDec2 = nextDec2.NextPlus(nextCtx);
                        newFloat = nextDec2.ToEFloat(ctx2);
                        if (newFloat.CompareTo(valueEfRnd) == 0)
                        {
                            nextDec = nextDec2;
                        }
                    }
                    return (nextDec.Exponent.Sign > 0 &&
                        nextDec.Abs().CompareTo(EDecimal.FromInt32(10000000)) < 0) ?
                          nextDec.ToPlainString() : nextDec.ToString();
                }
                eprecision = nextPrecision;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToSingle"]/*'/>
        public float ToSingle()
        {
            if (this.IsPositiveInfinity())
            {
                return Single.PositiveInfinity;
            }
            if (this.IsNegativeInfinity())
            {
                return Single.NegativeInfinity;
            }
            if (this.IsNaN())
            {
                int nan = 0x7f800000;
                if (this.IsNegative)
                {
                    nan |= unchecked((int)(1 << 31));
                }
                // IsQuietNaN(): the quiet bit for X86 at least
                // If signaling NaN and mantissa is 0: set 0x200000
                // bit to keep the mantissa from being zero
                if (this.IsQuietNaN())
                {
                    nan |= 0x400000;
                }
                else if (this.UnsignedMantissa.IsZero)
                {
                    nan |= 0x200000;
                }
                if (!this.UnsignedMantissa.IsZero)
                {
                    // Transfer diagnostic information
                    EInteger bigdata = this.UnsignedMantissa % (EInteger)0x400000;
                    int intData = (int)bigdata;
                    nan |= intData;
                    if (intData == 0 && !this.IsQuietNaN())
                    {
                        nan |= 0x200000;
                    }
                }
                return BitConverter.ToSingle(BitConverter.GetBytes(nan), 0);
            }
            EFloat thisValue = this.RoundToPrecision(EContext.Binary32);
            if (!thisValue.IsFinite)
            {
                return thisValue.ToSingle();
            }
            EInteger mant = thisValue.unsignedMantissa;
            if (thisValue.IsNegative && mant.IsZero)
            {
                return BitConverter.ToSingle(BitConverter.GetBytes((int)1 << 31), 0);
            }
            else if (mant.IsZero)
            {
                return 0.0f;
            }
            // DebugUtility.Log("-->" + (//
            // thisValue.unsignedMantissa.ToRadixString(2)) + ", " + (//
            // thisValue.exponent));
            int bitLength = mant.GetUnsignedBitLength();
            int expo = thisValue.exponent.ToInt32Checked();
            bool subnormal = false;
            if (bitLength < 24)
            {
                int diff = 24 - bitLength;
                expo -= diff;
                if (expo < -149)
                {
                    // DebugUtility.Log("Diff changed from " + diff + " to " + (diff -
                    // (-149 - expo)));
                    diff -= -149 - expo;
                    expo = -149;
                    subnormal = true;
                }
                mant <<= diff;
                bitLength += diff;
            }
            // DebugUtility.Log("2->" + (mant.ToRadixString(2)) + ", " + expo);
            int smallmantissa = ((int)mant.ToInt32Checked()) & 0x7fffff;
            if (!subnormal)
            {
                smallmantissa |= (expo + 150) << 23;
            }
            if (this.IsNegative)
            {
                smallmantissa |= 1 << 31;
            }
            return BitConverter.ToSingle(
                BitConverter.GetBytes((int)smallmantissa),
                0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToString"]/*'/>
        public override string ToString()
        {
            return EDecimal.FromEFloat(this).ToString();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.Ulp"]/*'/>
        public EFloat Ulp()
        {
            return (!this.IsFinite) ? EFloat.One :
              EFloat.Create(EInteger.One, this.exponent);
        }

        internal static EFloat CreateWithFlags(
          EInteger mantissa,
          EInteger exponent,
          int flags)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            int sign = mantissa == null ? 0 : mantissa.Sign;
            return new EFloat(
              sign < 0 ? (-(EInteger)mantissa) : mantissa,
              exponent,
              flags);
        }

        private EInteger ToEIntegerInternal(bool exact)
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return EInteger.Zero;
            }
            int expsign = this.Exponent.Sign;
            if (expsign == 0)
            {
                // Integer
                return this.Mantissa;
            }
            if (expsign > 0)
            {
                // Integer with trailing zeros
                EInteger curexp = this.Exponent;
                EInteger bigmantissa = this.Mantissa;
                if (bigmantissa.IsZero)
                {
                    return bigmantissa;
                }
                bool neg = bigmantissa.Sign < 0;
                if (neg)
                {
                    bigmantissa = -bigmantissa;
                }
                bigmantissa = NumberUtility.ShiftLeft(bigmantissa, curexp);
                if (neg)
                {
                    bigmantissa = -bigmantissa;
                }
                return bigmantissa;
            }
            else
            {
                if (exact && !this.unsignedMantissa.IsEven)
                {
                    // Mantissa is odd and will have to shift a nonzero
                    // number of bits, so can't be an exact integer
                    throw new ArithmeticException("Not an exact integer");
                }
                FastInteger bigexponent = FastInteger.FromBig(this.Exponent).Negate();
                EInteger bigmantissa = this.unsignedMantissa;
                BitShiftAccumulator acc = new BitShiftAccumulator(bigmantissa, 0, 0);
                acc.ShiftRight(bigexponent);
                if (exact && (acc.LastDiscardedDigit != 0 || acc.OlderDiscardedDigits !=
                            0))
                {
                    // Some digits were discarded
                    throw new ArithmeticException("Not an exact integer");
                }
                bigmantissa = acc.ShiftedInt;
                if (this.IsNegative)
                {
                    bigmantissa = -bigmantissa;
                }
                return bigmantissa;
            }
        }

        private sealed class BinaryMathHelper : IRadixMathHelper<EFloat>
        {
            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetRadix"]/*'/>
            public int GetRadix()
            {
                return 2;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetSign(PeterO.Numbers.EFloat)"]/*'/>
            public int GetSign(EFloat value)
            {
                return value.Sign;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetMantissa(PeterO.Numbers.EFloat)"]/*'/>
            public EInteger GetMantissa(EFloat value)
            {
                return value.unsignedMantissa;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetExponent(PeterO.Numbers.EFloat)"]/*'/>
            public EInteger GetExponent(EFloat value)
            {
                return value.exponent;
            }

            public FastIntegerFixed GetMantissaFastInt(EFloat value)
            {
                return FastIntegerFixed.FromBig(value.unsignedMantissa);
            }

            public FastIntegerFixed GetExponentFastInt(EFloat value)
            {
                return FastIntegerFixed.FromBig(value.exponent);
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulatorWithDigits(PeterO.Numbers.EInteger,System.Int32,System.Int32)"]/*'/>
            public IShiftAccumulator CreateShiftAccumulatorWithDigits(
              EInteger bigint,
              int lastDigit,
              int olderDigits)
            {
                return new BitShiftAccumulator(bigint, lastDigit, olderDigits);
            }

            public IShiftAccumulator CreateShiftAccumulatorWithDigitsFastInt(
              FastIntegerFixed fastInt,
              int lastDigit,
              int olderDigits)
            {
                if (fastInt.CanFitInInt32())
                {
                    return new BitShiftAccumulator(
                 fastInt.AsInt32(),
                 lastDigit,
                 olderDigits);
                }
                else
                {
                    return new BitShiftAccumulator(
                    fastInt.ToEInteger(),
                    lastDigit,
                    olderDigits);
                }
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)"]/*'/>
            public IShiftAccumulator CreateShiftAccumulator(EInteger bigint)
            {
                return new BitShiftAccumulator(bigint, 0, 0);
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.DivisionShift(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
            public FastInteger DivisionShift(EInteger num, EInteger den)
            {
                if (den.IsZero)
                {
                    return null;
                }
                if (den.GetUnsignedBit(0) && den.CompareTo(EInteger.One) != 0)
                {
                    return null;
                }
                int lowBit = den.GetLowBit();
                den >>= lowBit;
                return den.Equals(EInteger.One) ? new FastInteger(lowBit) : null;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.MultiplyByRadixPower(PeterO.Numbers.EInteger,PeterO.Numbers.FastInteger)"]/*'/>
            public EInteger MultiplyByRadixPower(
              EInteger bigint,
              FastInteger power)
            {
                EInteger tmpbigint = bigint;
                if (power.Sign <= 0)
                {
                    return tmpbigint;
                }
                if (tmpbigint.Sign < 0)
                {
                    tmpbigint = -tmpbigint;
                    if (power.CanFitInInt32())
                    {
                        tmpbigint = NumberUtility.ShiftLeftInt(tmpbigint, power.AsInt32());
                        tmpbigint = -tmpbigint;
                    }
                    else
                    {
                        tmpbigint = NumberUtility.ShiftLeft(
                          tmpbigint,
                          power.AsEInteger());
                        tmpbigint = -tmpbigint;
                    }
                    return tmpbigint;
                }
                return power.CanFitInInt32() ? NumberUtility.ShiftLeftInt(
                  tmpbigint,
                  power.AsInt32()) : NumberUtility.ShiftLeft(
                  tmpbigint,
                  power.AsEInteger());
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetFlags(PeterO.Numbers.EFloat)"]/*'/>
            public int GetFlags(EFloat value)
            {
                return value.flags;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)"]/*'/>
            public EFloat CreateNewWithFlags(
              EInteger mantissa,
              EInteger exponent,
              int flags)
            {
                return EFloat.CreateWithFlags(mantissa, exponent, flags);
            }

            public EFloat CreateNewWithFlagsFastInt(
              FastIntegerFixed fmantissa,
              FastIntegerFixed fexponent,
              int flags)
            {
                return CreateWithFlags(
          fmantissa.ToEInteger(),
          fexponent.ToEInteger(),
          flags);
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetArithmeticSupport"]/*'/>
            public int GetArithmeticSupport()
            {
                return BigNumberFlags.FiniteAndNonFinite;
            }

            /// <include file='../../docs.xml'
            /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.BinaryMathHelper.ValueOf(System.Int32)"]/*'/>
            public EFloat ValueOf(int val)
            {
                return FromInt64(val);
            }
        }
        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToByteChecked"]/*'/>
        public byte ToByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((byte)0) : this.ToEInteger().ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToByteUnchecked"]/*'/>
        public byte ToByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToByteUnchecked() : (byte)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToByteIfExact"]/*'/>
        public byte ToByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((byte)0) : this.ToEIntegerIfExact().ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromByte(System.Byte)"]/*'/>
        public static EFloat FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt16Checked"]/*'/>
        public short ToInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((short)0) : this.ToEInteger().ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt16Unchecked"]/*'/>
        public short ToInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt16Unchecked() : (short)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt16IfExact"]/*'/>
        public short ToInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((short)0) :
              this.ToEIntegerIfExact().ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromInt16(System.Int16)"]/*'/>
        public static EFloat FromInt16(short inputInt16)
        {
            int val = (int)inputInt16;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt32Checked"]/*'/>
        public int ToInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((int)0) : this.ToEInteger().ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt32Unchecked"]/*'/>
        public int ToInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt32Unchecked() : (int)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt32IfExact"]/*'/>
        public int ToInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((int)0) : this.ToEIntegerIfExact().ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromInt32(System.Int32)"]/*'/>
        public static EFloat FromInt32(int inputInt32)
        {
            return FromEInteger(EInteger.FromInt32(inputInt32));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt64Checked"]/*'/>
        public long ToInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((long)0) : this.ToEInteger().ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt64Unchecked"]/*'/>
        public long ToInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt64Unchecked() : (long)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToInt64IfExact"]/*'/>
        public long ToInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((long)0) : this.ToEIntegerIfExact().ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromInt64(System.Int64)"]/*'/>
        public static EFloat FromInt64(long inputInt64)
        {
            return FromEInteger(EInteger.FromInt64(inputInt64));
        }

        // End integer conversions
    }

    public sealed partial class EFloat
    {
        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.Single)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(float flt)
        {
            return FromSingle(flt);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.Double)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(double dbl)
        {
            return FromDouble(dbl);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(EInteger eint)
        {
            return FromEInteger(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Addition(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat operator +(EFloat bthis, EFloat otherValue)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(otherValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Subtraction(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat operator -(
       EFloat bthis,
       EFloat subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat operator *(
        EFloat operand1,
        EFloat operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Division(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat operator /(
       EFloat dividend,
       EFloat divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Modulus(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat operator %(
       EFloat dividend,
       EFloat divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor, null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_UnaryNegation(PeterO.Numbers.EFloat)"]/*'/>
        public static EFloat operator -(EFloat bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~PeterO.Numbers.EInteger"]/*'/>
        public static explicit operator EInteger(EFloat bigValue)
        {
            return bigValue.ToEInteger();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Double"]/*'/>
        public static explicit operator double(EFloat bigValue)
        {
            return bigValue.ToDouble();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Single"]/*'/>
        public static explicit operator float(EFloat bigValue)
        {
            return bigValue.ToSingle();
        }
        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Byte"]/*'/>
        public static explicit operator byte(EFloat input)
        {
            return input.ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.Byte)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(byte inputByte)
        {
            return EFloat.FromByte(inputByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToSByteChecked"]/*'/>
        
        public sbyte ToSByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) : this.ToEInteger().ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToSByteUnchecked"]/*'/>
        
        public sbyte ToSByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToSByteUnchecked() : (sbyte)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToSByteIfExact"]/*'/>
        
        public sbyte ToSByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) :
              this.ToEIntegerIfExact().ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromSByte(System.SByte)"]/*'/>
        
        public static EFloat FromSByte(sbyte inputSByte)
        {
            int val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.SByte"]/*'/>
        
        public static explicit operator sbyte(EFloat input)
        {
            return input.ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.SByte)~PeterO.Numbers.EFloat"]/*'/>
        
        public static implicit operator EFloat(sbyte inputSByte)
        {
            return EFloat.FromSByte(inputSByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int16"]/*'/>
        public static explicit operator short(EFloat input)
        {
            return input.ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int16)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(short inputInt16)
        {
            return EFloat.FromInt16(inputInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt16Checked"]/*'/>
        
        public ushort ToUInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ushort)0) : this.ToEInteger().ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt16Unchecked"]/*'/>
        
        public ushort ToUInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt16Unchecked() : (ushort)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt16IfExact"]/*'/>
        
        public ushort ToUInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ushort)0) :
              this.ToEIntegerIfExact().ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromUInt16(System.UInt16)"]/*'/>
        
        public static EFloat FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt16"]/*'/>
        
        public static explicit operator ushort(EFloat input)
        {
            return input.ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt16)~PeterO.Numbers.EFloat"]/*'/>
        
        public static implicit operator EFloat(ushort inputUInt16)
        {
            return EFloat.FromUInt16(inputUInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int32"]/*'/>
        public static explicit operator int(EFloat input)
        {
            return input.ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int32)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(int inputInt32)
        {
            return EFloat.FromInt32(inputInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt32Checked"]/*'/>
        
        public uint ToUInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((uint)0) : this.ToEInteger().ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt32Unchecked"]/*'/>
        
        public uint ToUInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt32Unchecked() : (uint)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt32IfExact"]/*'/>
        
        public uint ToUInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((uint)0) :
              this.ToEIntegerIfExact().ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromUInt32(System.UInt32)"]/*'/>
        public static EFloat FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt32"]/*'/>
        public static explicit operator uint(EFloat input)
        {
            return input.ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt32)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(uint inputUInt32)
        {
            return EFloat.FromUInt32(inputUInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int64"]/*'/>
        public static explicit operator long(EFloat input)
        {
            return input.ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int64)~PeterO.Numbers.EFloat"]/*'/>
        public static implicit operator EFloat(long inputInt64)
        {
            return EFloat.FromInt64(inputInt64);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt64Checked"]/*'/>
        public ulong ToUInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ulong)0) : this.ToEInteger().ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt64Unchecked"]/*'/>
        public ulong ToUInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt64Unchecked() : (ulong)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.ToUInt64IfExact"]/*'/>
        public ulong ToUInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ulong)0) :
              this.ToEIntegerIfExact().ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.FromUInt64(System.UInt64)"]/*'/>
        public static EFloat FromUInt64(ulong inputUInt64)
        {
            return FromEInteger(EInteger.FromUInt64(inputUInt64));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt64"]/*'/>
        
        public static explicit operator ulong(EFloat input)
        {
            return input.ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt64)~PeterO.Numbers.EFloat"]/*'/>
        
        public static implicit operator EFloat(ulong inputUInt64)
        {
            return EFloat.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EInteger"]/*'/>
    public sealed partial class EInteger : IComparable<EInteger>,
      IEquatable<EInteger>
    {
        // TODO: Investigate using 32-bit words instead of 16-bit
        private const string Digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        private const int RecursiveDivisionLimit = 40;

        private const int RecursionLimit = 10;

        private const int ShortMask = 0xffff;

        private static readonly int[] ValueCharToDigit = { 36, 36, 36, 36, 36, 36,
      36,
      36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 36, 36, 36, 36, 36, 36,
      36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36,
      36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36 };

        private static readonly int[] ValueMaxSafeInts = { 1073741823, 715827881,
      536870911, 429496728, 357913940, 306783377, 268435455, 238609293,
      214748363, 195225785, 178956969, 165191048, 153391688, 143165575,
      134217727, 126322566, 119304646, 113025454, 107374181, 102261125,
      97612892, 93368853, 89478484, 85899344, 82595523, 79536430, 76695843,
      74051159, 71582787, 69273665, 67108863, 65075261, 63161282, 61356674,
      59652322 };

        private static readonly EInteger ValueOne = new EInteger(
          1, new short[] { 1 }, false);

        private static readonly EInteger ValueTen = new EInteger(
          1, new short[] { 10 }, false);

        private static readonly EInteger ValueZero = new EInteger(
          0, new short[] { 0 }, false);

        private readonly bool negative;
        private readonly int wordCount;
        private readonly short[] words;

        private EInteger(int wordCount, short[] reg, bool negative)
        {
#if DEBUG
            if (wordCount > 0)
            {
                if (reg == null)
                {
                    throw new InvalidOperationException();
                }
                if (wordCount > reg.Length)
                {
                    throw new InvalidOperationException();
                }
                if (reg[wordCount - 1] == 0)
                {
                    throw new InvalidOperationException();
                }
            }
#endif
            this.wordCount = wordCount;
            this.words = reg;
            this.negative = negative;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EInteger.One"]/*'/>
        public static EInteger One
        {
            get
            {
                return ValueOne;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EInteger.Ten"]/*'/>
        public static EInteger Ten
        {
            get
            {
                return ValueTen;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EInteger.Zero"]/*'/>
        public static EInteger Zero
        {
            get
            {
                return ValueZero;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EInteger.IsEven"]/*'/>
        public bool IsEven
        {
            get
            {
                return !this.GetUnsignedBit(0);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EInteger.IsPowerOfTwo"]/*'/>
        public bool IsPowerOfTwo
        {
            get
            {
                if (this.negative)
                {
                    return false;
                }
                return (this.wordCount == 0) ? false : (this.GetUnsignedBitLength()
                  - 1 == this.GetLowBit());
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EInteger.IsZero"]/*'/>
        public bool IsZero
        {
            get
            {
                return this.wordCount == 0;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.EInteger.Sign"]/*'/>
        public int Sign
        {
            get
            {
                return (this.wordCount == 0) ? 0 : (this.negative ? -1 : 1);
            }
        }

        internal static EInteger FromInts(int[] intWords, int count)
        {
            short[] words = new short[count << 1];
            int j = 0;
            for (int i = 0; i < count; ++i, j += 2)
            {
                int w = intWords[i];
                words[j] = unchecked((short)w);
                words[j + 1] = unchecked((short)(w >> 16));
            }
            int newwordCount = words.Length;
            while (newwordCount != 0 && words[newwordCount - 1] == 0)
            {
                --newwordCount;
            }
            return (newwordCount == 0) ? EInteger.Zero : (new
                          EInteger(
                          newwordCount,
                          words,
                          false));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromBytes(System.Byte[],System.Boolean)"]/*'/>
        public static EInteger FromBytes(byte[] bytes, bool littleEndian)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            if (bytes.Length == 0)
            {
                return EInteger.Zero;
            }
            int len = bytes.Length;
            int wordLength = ((int)len + 1) >> 1;
            short[] newreg = new short[wordLength];
            int valueJIndex = littleEndian ? len - 1 : 0;
            bool numIsNegative = (bytes[valueJIndex] & 0x80) != 0;
            bool newnegative = numIsNegative;
            int j = 0;
            if (!numIsNegative)
            {
                if (littleEndian)
                {
                    bool odd = (len & 1) != 0;
                    if (odd)
                    {
                        --len;
                    }
                    for (int i = 0; i < len; i += 2, j++)
                    {
                        int index2 = i + 1;
                        int nrj = ((int)bytes[i]) & 0xff;
                        nrj |= ((int)bytes[index2]) << 8;
                        newreg[j] = unchecked((short)nrj);
                    }
                    if (odd)
                    {
                        newreg[len >> 1] = unchecked((short)(((int)bytes[len]) & 0xff));
                    }
                }
                else
                {
                    for (int i = 0; i < len; i += 2, j++)
                    {
                        int index = len - 1 - i;
                        int index2 = len - 2 - i;
                        int nrj = ((int)bytes[index]) & 0xff;
                        if (index2 >= 0 && index2 < len)
                        {
                            nrj |= ((int)bytes[index2]) << 8;
                        }
                        newreg[j] = unchecked((short)nrj);
                    }
                }
            }
            else
            {
                for (int i = 0; i < len; i += 2, j++)
                {
                    int index = littleEndian ? i : len - 1 - i;
                    int index2 = littleEndian ? i + 1 : len - 2 - i;
                    int nrj = ((int)bytes[index]) & 0xff;
                    if (index2 >= 0 && index2 < len)
                    {
                        nrj |= ((int)bytes[index2]) << 8;
                    }
                    else
                    {
                        // sign extend the last byte
                        nrj |= 0xff00;
                    }
                    newreg[j] = unchecked((short)nrj);
                }
                for (; j < newreg.Length; ++j)
                {
                    newreg[j] = unchecked((short)0xffff);  // sign extend remaining words
                }
                TwosComplement(newreg, 0, (int)newreg.Length);
            }
            int newwordCount = newreg.Length;
            while (newwordCount != 0 && newreg[newwordCount - 1] == 0)
            {
                --newwordCount;
            }
            return (newwordCount == 0) ? EInteger.Zero : (new
                          EInteger(
                          newwordCount,
                          newreg,
                          newnegative));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromInt32(System.Int32)"]/*'/>
        public static EInteger FromInt32(int intValue)
        {
            if (intValue == 0)
            {
                return ValueZero;
            }
            if (intValue == 1)
            {
                return ValueOne;
            }
            if (intValue == 10)
            {
                return ValueTen;
            }
            short[] retreg;
            bool retnegative;
            int retwordcount;
            retnegative = intValue < 0;
            if ((intValue >> 15) == 0)
            {
                retreg = new short[2];
                if (retnegative)
                {
                    intValue = -intValue;
                }
                retreg[0] = (short)(intValue & 0xffff);
                retwordcount = 1;
            }
            else if (intValue == Int32.MinValue)
            {
                retreg = new short[2];
                retreg[0] = 0;
                retreg[1] = unchecked((short)0x8000);
                retwordcount = 2;
            }
            else
            {
                unchecked
                {
                    retreg = new short[2];
                    if (retnegative)
                    {
                        intValue = -intValue;
                    }
                    retreg[0] = (short)(intValue & 0xffff);
                    intValue >>= 16;
                    retreg[1] = (short)(intValue & 0xffff);
                    retwordcount = (retreg[1] == 0) ? 1 : 2;
                }
            }
            return new EInteger(retwordcount, retreg, retnegative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromInt64(System.Int64)"]/*'/>
        public static EInteger FromInt64(long longerValue)
        {
            if (longerValue == 0)
            {
                return ValueZero;
            }
            if (longerValue == 1)
            {
                return ValueOne;
            }
            if (longerValue == 10)
            {
                return ValueTen;
            }
            short[] retreg;
            bool retnegative;
            int retwordcount;
            unchecked
            {
                retnegative = longerValue < 0;
                if ((longerValue >> 16) == 0)
                {
                    retreg = new short[1];
                    int intValue = (int)longerValue;
                    if (retnegative)
                    {
                        intValue = -intValue;
                    }
                    retreg[0] = (short)(intValue & 0xffff);
                    retwordcount = 1;
                }
                else if ((longerValue >> 31) == 0)
                {
                    retreg = new short[2];
                    int intValue = (int)longerValue;
                    if (retnegative)
                    {
                        intValue = -intValue;
                    }
                    retreg[0] = (short)(intValue & 0xffff);
                    retreg[1] = (short)((intValue >> 16) & 0xffff);
                    retwordcount = 2;
                }
                else if (longerValue == Int64.MinValue)
                {
                    retreg = new short[4];
                    retreg[0] = 0;
                    retreg[1] = 0;
                    retreg[2] = 0;
                    retreg[3] = unchecked((short)0x8000);
                    retwordcount = 4;
                }
                else
                {
                    retreg = new short[4];
                    long ut = longerValue;
                    if (retnegative)
                    {
                        ut = -ut;
                    }
                    retreg[0] = (short)(ut & 0xffff);
                    ut >>= 16;
                    retreg[1] = (short)(ut & 0xffff);
                    ut >>= 16;
                    retreg[2] = (short)(ut & 0xffff);
                    ut >>= 16;
                    retreg[3] = (short)(ut & 0xffff);
                    // at this point, the word count can't
                    // be 0 (the check for 0 was already done above)
                    retwordcount = 4;
                    while (retwordcount != 0 &&
                           retreg[retwordcount - 1] == 0)
                    {
                        --retwordcount;
                    }
                }
            }
            return new EInteger(retwordcount, retreg, retnegative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromRadixString(System.String,System.Int32)"]/*'/>
        public static EInteger FromRadixString(string str, int radix)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return FromRadixSubstring(str, radix, 0, str.Length);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromRadixSubstring(System.String,System.Int32,System.Int32,System.Int32)"]/*'/>
        public static EInteger FromRadixSubstring(
          string str,
          int radix,
          int index,
          int endIndex)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            if (radix < 2)
            {
                throw new ArgumentException("radix (" + radix +
                            ") is less than 2");
            }
            if (radix > 36)
            {
                throw new ArgumentException("radix (" + radix +
                            ") is more than 36");
            }
            if (index < 0)
            {
                throw new ArgumentException("index (" + index + ") is less than " +
                            "0");
            }
            if (index > str.Length)
            {
                throw new ArgumentException("index (" + index + ") is more than " +
                            str.Length);
            }
            if (endIndex < 0)
            {
                throw new ArgumentException("endIndex (" + endIndex +
                            ") is less than 0");
            }
            if (endIndex > str.Length)
            {
                throw new ArgumentException("endIndex (" + endIndex +
                            ") is more than " + str.Length);
            }
            if (endIndex < index)
            {
                throw new ArgumentException("endIndex (" + endIndex +
                            ") is less than " + index);
            }
            if (index == endIndex)
            {
                throw new FormatException("No digits");
            }
            bool negative = false;
            if (str[index] == '-')
            {
                ++index;
                if (index == endIndex)
                {
                    throw new FormatException("No digits");
                }
                negative = true;
            }
            // Skip leading zeros
            for (; index < endIndex; ++index)
            {
                char c = str[index];
                if (c != 0x30)
                {
                    break;
                }
            }
            int effectiveLength = endIndex - index;
            if (effectiveLength == 0)
            {
                return EInteger.Zero;
            }
            short[] bigint;
            if (radix == 16)
            {
                // Special case for hexadecimal radix
                int leftover = effectiveLength & 3;
                int wordCount = effectiveLength >> 2;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    int extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 4;
                        char c = str[index + i];
                        int digit = (c >= 0x80) ? 36 : ValueCharToDigit[(int)c];
                        if (digit >= 16)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
#if DEBUG
                if ((endIndex - index) % 4 != 0)
                {
                    throw new ArgumentException(
                      "doesn't satisfy (endIndex - index) % 4 == 0");
                }
#endif
                while (index < endIndex)
                {
                    char c = str[index + 3];
                    int digit = (c >= 0x80) ? 36 : ValueCharToDigit[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    int word = digit;
                    c = str[index + 2];
                    digit = (c >= 0x80) ? 36 : ValueCharToDigit[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 4;
                    c = str[index + 1];
                    digit = (c >= 0x80) ? 36 : ValueCharToDigit[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 8;
                    c = str[index];
                    digit = (c >= 0x80) ? 36 : ValueCharToDigit[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    word |= digit << 12;
                    index += 4;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
            }
            else if (radix == 2)
            {
                // Special case for binary radix
                int leftover = effectiveLength & 15;
                int wordCount = effectiveLength >> 4;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    int extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 1;
                        char c = str[index + i];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
                while (index < endIndex)
                {
                    int word = 0;
                    int idx = index + 15;
                    for (int i = 0; i < 16; ++i)
                    {
                        char c = str[idx];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        --idx;
                        word |= digit << i;
                    }
                    index += 16;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
            }
            else
            {
                bigint = new short[4];
                bool haveSmallInt = true;
                int maxSafeInt = ValueMaxSafeInts[radix - 2];
                int maxShortPlusOneMinusRadix = 65536 - radix;
                int smallInt = 0;
                for (int i = index; i < endIndex; ++i)
                {
                    char c = str[i];
                    int digit = (c >= 0x80) ? 36 : ValueCharToDigit[(int)c];
                    if (digit >= radix)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    if (haveSmallInt && smallInt < maxSafeInt)
                    {
                        smallInt *= radix;
                        smallInt += digit;
                    }
                    else
                    {
                        if (haveSmallInt)
                        {
                            bigint[0] = unchecked((short)(smallInt & 0xffff));
                            bigint[1] = unchecked((short)((smallInt >> 16) & 0xffff));
                            haveSmallInt = false;
                        }
                        // Multiply by the radix
                        short carry = 0;
                        int n = bigint.Length;
                        for (int j = 0; j < n; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & 0xffff) * radix);
                            int p2 = ((int)carry) & 0xffff;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                        if (carry != 0)
                        {
                            bigint = GrowForCarry(bigint, carry);
                        }
                        // Add the parsed digit
                        if (digit != 0)
                        {
                            int d = bigint[0] & 0xffff;
                            if (d <= maxShortPlusOneMinusRadix)
                            {
                                bigint[0] = unchecked((short)(d + digit));
                            }
                            else if (Increment(bigint, 0, bigint.Length, (short)digit) !=
                                0)
                            {
                                bigint = GrowForCarry(bigint, (short)1);
                            }
                        }
                    }
                }
                if (haveSmallInt)
                {
                    bigint[0] = unchecked((short)(smallInt & 0xffff));
                    bigint[1] = unchecked((short)((smallInt >> 16) & 0xffff));
                }
            }
            int count = CountWords(bigint);
            return (count == 0) ? EInteger.Zero : new EInteger(
              count,
              bigint,
              negative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromString(System.String)"]/*'/>
        public static EInteger FromString(string str)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return FromRadixSubstring(str, 10, 0, str.Length);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromSubstring(System.String,System.Int32,System.Int32)"]/*'/>
        public static EInteger FromSubstring(
          string str,
          int index,
          int endIndex)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return FromRadixSubstring(str, 10, index, endIndex);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Abs"]/*'/>
        public EInteger Abs()
        {
            return (this.wordCount == 0 || !this.negative) ? this : new
              EInteger(this.wordCount, this.words, false);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Add(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger Add(EInteger bigintAugend)
        {
            if (bigintAugend == null)
            {
                throw new ArgumentNullException(nameof(bigintAugend));
            }
            if (this.wordCount == 0)
            {
                return bigintAugend;
            }
            if (bigintAugend.wordCount == 0)
            {
                return this;
            }
            short[] sumreg;
            if (bigintAugend.wordCount == 1 && this.wordCount == 1)
            {
                if (this.negative == bigintAugend.negative)
                {
                    int intSum = (((int)this.words[0]) & 0xffff) +
                      (((int)bigintAugend.words[0]) & 0xffff);
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)intSum);
                    sumreg[1] = unchecked((short)(intSum >> 16));
                    return new EInteger(
                      ((intSum >> 16) == 0) ? 1 : 2,
                      sumreg,
                      this.negative);
                }
                else
                {
                    int a = ((int)this.words[0]) & 0xffff;
                    int b = ((int)bigintAugend.words[0]) & 0xffff;
                    if (a == b)
                    {
                        return EInteger.Zero;
                    }
                    if (a > b)
                    {
                        a -= b;
                        sumreg = new short[2];
                        sumreg[0] = unchecked((short)a);
                        return new EInteger(1, sumreg, this.negative);
                    }
                    b -= a;
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)b);
                    return new EInteger(1, sumreg, !this.negative);
                }
            }
            if ((!this.negative) == (!bigintAugend.negative))
            {
                // both nonnegative or both negative
                int addendCount = this.wordCount;
                int augendCount = bigintAugend.wordCount;
                if (augendCount <= 2 && addendCount <= 2 &&
                   (this.wordCount < 2 || (this.words[1] >> 15) == 0) &&
                   (bigintAugend.wordCount < 2 || (bigintAugend.words[1] >> 15) == 0))
                {
                    int a = ((int)this.words[0]) & 0xffff;
                    if (this.wordCount == 2)
                    {
                        a |= (((int)this.words[1]) & 0xffff) << 16;
                    }
                    int b = ((int)bigintAugend.words[0]) & 0xffff;
                    if (bigintAugend.wordCount == 2)
                    {
                        b |= (((int)bigintAugend.words[1]) & 0xffff) << 16;
                    }
                    a = unchecked((int)(a + b));
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)(a & 0xffff));
                    sumreg[1] = unchecked((short)((a >> 16) & 0xffff));
                    int wcount = (sumreg[1] == 0) ? 1 : 2;
                    return new EInteger(wcount, sumreg, this.negative);
                }
                if (augendCount <= 2 && addendCount <= 2)
                {
                    int a = ((int)this.words[0]) & 0xffff;
                    if (this.wordCount == 2)
                    {
                        a |= (((int)this.words[1]) & 0xffff) << 16;
                    }
                    int b = ((int)bigintAugend.words[0]) & 0xffff;
                    if (bigintAugend.wordCount == 2)
                    {
                        b |= (((int)bigintAugend.words[1]) & 0xffff) << 16;
                    }
                    long longResult = ((long)a) & 0xffffffffL;
                    longResult += ((long)b) & 0xffffffffL;
                    if ((longResult >> 32) == 0)
                    {
                        a = unchecked((int)longResult);
                        sumreg = new short[2];
                        sumreg[0] = unchecked((short)(a & 0xffff));
                        sumreg[1] = unchecked((short)((a >> 16) & 0xffff));
                        int wcount = (sumreg[1] == 0) ? 1 : 2;
                        return new EInteger(wcount, sumreg, this.negative);
                    }
                }
                // DebugUtility.Log("" + this + " + " + bigintAugend);
                sumreg = new short[(
                  int)Math.Max(
                            this.words.Length,
                            bigintAugend.words.Length)];
                int carry;
                int desiredLength = Math.Max(addendCount, augendCount);
                if (addendCount == augendCount)
                {
                    carry = AddInternal(
                      sumreg,
                      0,
                      this.words,
                      0,
                      bigintAugend.words,
                      0,
                      addendCount);
                }
                else if (addendCount > augendCount)
                {
                    // Addend is bigger
                    carry = AddInternal(
                      sumreg,
                      0,
                      this.words,
                      0,
                      bigintAugend.words,
                      0,
                      augendCount);
                    Array.Copy(
                      this.words,
                      augendCount,
                      sumreg,
                      augendCount,
                      addendCount - augendCount);
                    if (carry != 0)
                    {
                        carry = Increment(
                          sumreg,
                          augendCount,
                          addendCount - augendCount,
                          (short)carry);
                    }
                }
                else
                {
                    // Augend is bigger
                    carry = AddInternal(
                      sumreg,
                      0,
                      this.words,
                      0,
                      bigintAugend.words,
                      0,
                      (int)addendCount);
                    Array.Copy(
                      bigintAugend.words,
                      addendCount,
                      sumreg,
                      addendCount,
                      augendCount - addendCount);
                    if (carry != 0)
                    {
                        carry = Increment(
                          sumreg,
                          addendCount,
                          (int)(augendCount - addendCount),
                          (short)carry);
                    }
                }
                bool needShorten = true;
                if (carry != 0)
                {
                    int nextIndex = desiredLength;
                    int len = nextIndex + 1;
                    sumreg = CleanGrow(sumreg, len);
                    sumreg[nextIndex] = (short)carry;
                    needShorten = false;
                }
                int sumwordCount = CountWords(sumreg);
                if (sumwordCount == 0)
                {
                    return EInteger.Zero;
                }
                if (needShorten)
                {
                    sumreg = ShortenArray(sumreg, sumwordCount);
                }
                return new EInteger(sumwordCount, sumreg, this.negative);
            }
            EInteger minuend = this;
            EInteger subtrahend = bigintAugend;
            if (this.negative)
            {
                // this is negative, b is nonnegative
                minuend = bigintAugend;
                subtrahend = this;
            }
            // Do a subtraction
            int words1Size = minuend.wordCount;
            int words2Size = subtrahend.wordCount;
            bool diffNeg = false;
#if DEBUG
            if (words1Size > minuend.words.Length)
            {
                throw new InvalidOperationException();
            }
            if (words2Size > subtrahend.words.Length)
            {
                throw new InvalidOperationException();
            }
#endif
            short borrow;
            short[] diffReg = new short[(
              int)Math.Max(
                          minuend.words.Length,
                          subtrahend.words.Length)];
            if (words1Size == words2Size)
            {
                if (Compare(minuend.words, 0, subtrahend.words, 0, (int)words1Size) >=
                    0)
                {
                    // words1 is at least as high as words2
                    SubtractInternal(
                      diffReg,
                      0,
                      minuend.words,
                      0,
                      subtrahend.words,
                      0,
                      words1Size);
                }
                else
                {
                    // words1 is less than words2
                    SubtractInternal(
                      diffReg,
                      0,
                      subtrahend.words,
                      0,
                      minuend.words,
                      0,
                      words1Size);
                    diffNeg = true;  // difference will be negative
                }
            }
            else if (words1Size > words2Size)
            {
                // words1 is greater than words2
                borrow = (
                  short)SubtractInternal(
                  diffReg,
                  0,
                  minuend.words,
                  0,
                  subtrahend.words,
                  0,
                  words2Size);
                Array.Copy(
                  minuend.words,
                  words2Size,
                  diffReg,
                  words2Size,
                  words1Size - words2Size);
                Decrement(diffReg, words2Size, (int)(words1Size - words2Size), borrow);
            }
            else
            {
                // words1 is less than words2
                borrow = (
                  short)SubtractInternal(
                  diffReg,
                  0,
                  subtrahend.words,
                  0,
                  minuend.words,
                  0,
                  words1Size);
                Array.Copy(
                  subtrahend.words,
                  words1Size,
                  diffReg,
                  words1Size,
                  words2Size - words1Size);
                Decrement(diffReg, words1Size, (int)(words2Size - words1Size), borrow);
                diffNeg = true;
            }
            int count = CountWords(diffReg);
            if (count == 0)
            {
                return EInteger.Zero;
            }
            diffReg = ShortenArray(diffReg, count);
            return new EInteger(count, diffReg, diffNeg);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.AsInt32Checked"]/*'/>
        [Obsolete("Renamed to ToInt32Checked.")]
        public int AsInt32Checked()
        {
            return this.ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.AsInt32Unchecked"]/*'/>
        [Obsolete("Renamed to ToInt32Unchecked.")]
        public int AsInt32Unchecked()
        {
            return this.ToInt32Unchecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.AsInt64Checked"]/*'/>
        [Obsolete("Renamed to ToInt64Checked.")]
        public long AsInt64Checked()
        {
            return this.ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.AsInt64Unchecked"]/*'/>
        [Obsolete("Renamed to ToInt64Unchecked.")]
        public long AsInt64Unchecked()
        {
            return this.ToInt64Unchecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.CanFitInInt32"]/*'/>
        public bool CanFitInInt32()
        {
            int c = this.wordCount;
            if (c > 2)
            {
                return false;
            }
            if (c == 2 && (this.words[1] & 0x8000) != 0)
            {
                return this.negative && this.words[1] == unchecked((short)0x8000) &&
                  this.words[0] == 0;
            }
            return true;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.CanFitInInt64"]/*'/>
        public bool CanFitInInt64()
        {
            int c = this.wordCount;
            if (c > 4)
            {
                return false;
            }
            if (c == 4 && (this.words[3] & 0x8000) != 0)
            {
                return this.negative && this.words[3] == unchecked((short)0x8000) &&
                  this.words[0] == 0;
            }
            return true;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.CompareTo(PeterO.Numbers.EInteger)"]/*'/>
        public int CompareTo(EInteger other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this == other)
            {
                return 0;
            }
            int size = this.wordCount, tempSize = other.wordCount;
            int sa = size == 0 ? 0 : (this.negative ? -1 : 1);
            int sb = tempSize == 0 ? 0 : (other.negative ? -1 : 1);
            if (sa != sb)
            {
                return (sa < sb) ? -1 : 1;
            }
            if (sa == 0)
            {
                return 0;
            }
            if (size == tempSize)
            {
                if (size == 1 && this.words[0] == other.words[0])
                {
                    return 0;
                }
                else
                {
                    short[] words1 = this.words;
                    short[] words2 = other.words;
                    while (unchecked(size--) != 0)
                    {
                        int an = ((int)words1[size]) & 0xffff;
                        int bn = ((int)words2[size]) & 0xffff;
                        if (an > bn)
                        {
                            return (sa > 0) ? 1 : -1;
                        }
                        if (an < bn)
                        {
                            return (sa > 0) ? -1 : 1;
                        }
                    }
                    return 0;
                }
            }
            return ((size > tempSize) ^ (sa <= 0)) ? 1 : -1;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Add(System.Int32)"]/*'/>
        public EInteger Add(int intValue)
        {
            if (intValue == 0)
            {
                return this;
            }
            if (this.wordCount == 0)
            {
                return EInteger.FromInt32(intValue);
            }
            if (this.wordCount == 1 && intValue < 65535 && intValue >= -65535)
            {
                short[] sumreg;
                if (intValue > 0 && !this.negative)
                {
                    int intSum = (((int)this.words[0]) & 0xffff) + intValue;
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)intSum);
                    sumreg[1] = unchecked((short)(intSum >> 16));
                    return new EInteger(
                      ((intSum >> 16) == 0) ? 1 : 2,
                      sumreg,
                      this.negative);
                }
                else if (intValue < 0 && this.negative)
                {
                    int intSum = (((int)this.words[0]) & 0xffff) - intValue;
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)intSum);
                    sumreg[1] = unchecked((short)(intSum >> 16));
                    return new EInteger(
                      ((intSum >> 16) == 0) ? 1 : 2,
                      sumreg,
                      this.negative);
                }
                else
                {
                    int a = ((int)this.words[0]) & 0xffff;
                    int b = Math.Abs(intValue);
                    if (a > b)
                    {
                        a -= b;
                        sumreg = new short[2];
                        sumreg[0] = unchecked((short)a);
                        return new EInteger(1, sumreg, this.negative);
                    }
                    else if (a == b)
                    {
                        return EInteger.Zero;
                    }
                    else
                    {
                        b -= a;
                        sumreg = new short[2];
                        sumreg[0] = unchecked((short)b);
                        return new EInteger(1, sumreg, !this.negative);
                    }
                }
            }
            return this.Add(EInteger.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Subtract(System.Int32)"]/*'/>
        public EInteger Subtract(int intValue)
        {
            return (intValue == Int32.MinValue) ?
              this.Subtract(EInteger.FromInt32(intValue)) : ((intValue == 0) ? this :
                this.Add(-intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Multiply(System.Int32)"]/*'/>
        public EInteger Multiply(int intValue)
        {
            return this.Multiply(EInteger.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Divide(System.Int32)"]/*'/>
        public EInteger Divide(int intValue)
        {
            return this.Divide(EInteger.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Remainder(System.Int32)"]/*'/>
        public EInteger Remainder(int intValue)
        {
            return this.Remainder(EInteger.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.CompareTo(System.Int32)"]/*'/>
        public int CompareTo(int intValue)
        {
            return this.CompareTo(EInteger.FromInt32(intValue));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Divide(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger Divide(EInteger bigintDivisor)
        {
            if (bigintDivisor == null)
            {
                throw new ArgumentNullException(nameof(bigintDivisor));
            }
            int words1Size = this.wordCount;
            int words2Size = bigintDivisor.wordCount;
            // ---- Special cases
            if (words2Size == 0)
            {
                // Divisor is 0
                throw new DivideByZeroException();
            }
            if (words1Size < words2Size)
            {
                // Dividend is less than divisor (includes case
                // where dividend is 0)
                return EInteger.Zero;
            }
            if (words1Size <= 2 && words2Size <= 2 && this.CanFitInInt32() &&
                bigintDivisor.CanFitInInt32())
            {
                int valueASmall = this.ToInt32Checked();
                int valueBSmall = bigintDivisor.ToInt32Checked();
                if (valueASmall != Int32.MinValue || valueBSmall != -1)
                {
                    int result = valueASmall / valueBSmall;
                    return EInteger.FromInt32(result);
                }
            }
            if (words1Size <= 4 && words2Size <= 4 && this.CanFitInInt64() &&
                bigintDivisor.CanFitInInt64())
            {
                long valueALong = this.ToInt64Checked();
                long valueBLong = bigintDivisor.ToInt64Checked();
                if (valueALong != Int64.MinValue || valueBLong != -1)
                {
                    long resultLong = valueALong / valueBLong;
                    return EInteger.FromInt64(resultLong);
                }
            }
            short[] quotReg;
            int quotwordCount;
            if (words2Size == 1)
            {
                // divisor is small, use a fast path
                quotReg = new short[this.words.Length];
                quotwordCount = this.wordCount;
                FastDivide(quotReg, this.words, words1Size, bigintDivisor.words[0]);
                while (quotwordCount != 0 && quotReg[quotwordCount - 1] == 0)
                {
                    --quotwordCount;
                }
                return (
                  quotwordCount != 0) ? (
                  new EInteger(
                    quotwordCount,
                    quotReg,
                    this.negative ^ bigintDivisor.negative)) : EInteger.Zero;
            }
            // ---- General case
            quotReg = new short[((int)(words1Size - words2Size + 1))];
            GeneralDivide(
        this.words,
        0,
        this.wordCount,
        bigintDivisor.words,
        0,
        bigintDivisor.wordCount,
        quotReg,
        0,
        null,
        0);
            quotwordCount = CountWords(quotReg);
            quotReg = ShortenArray(quotReg, quotwordCount);
            return (
              quotwordCount != 0) ? (
              new EInteger(
                quotwordCount,
                quotReg,
                this.negative ^ bigintDivisor.negative)) : EInteger.Zero;
        }

        private static short LinearMultiplySubtractMinuend1Bigger(
          short[] resultArr,
          int resultStart,
          short[] minuendArr,
          int minuendArrStart,
          int factor1,
          short[] factor2,
          int factor2Start,
          int factor2Count)
        {
            if (factor2Count <= 0 || (factor1 >> 16) != 0)
            {
                throw new ArgumentException();
            }
            int a = 0;
            int b = 0;
            int cc = 0;
            for (int i = 0; i < factor2Count; ++i)
            {
                a = unchecked((((int)factor2[factor2Start + i]) & 0xffff) * factor1);
                a = unchecked(a + (cc & 0xffff));
                b = ((int)minuendArr[minuendArrStart + i] & 0xffff) - (a & 0xffff);
                resultArr[resultStart + i] = unchecked((short)b);
                cc = ((a >> 16) & 0xffff) + ((b >> 31) & 1);
            }
            a = cc & 0xffff;
            b = ((int)minuendArr[minuendArrStart + factor2Count] & 0xffff) - a;
            resultArr[resultStart + factor2Count] = unchecked((short)b);
            cc = (b >> 31) & 1;
            return unchecked((short)cc);
        }

        private static void DivideThreeBlocksByTwo(
          short[] valueALow,
          int posALow,
          short[] valueAMidHigh,
          int posAMidHigh,
          short[] b,
          int posB,
          int blockCount,
          short[] quot,
          int posQuot,
          short[] rem,
          int posRem,
          short[] tmp)
        {
            // NOTE: size of 'quot' equals 'blockCount' * 2
            // NOTE: size of 'rem' equals 'blockCount' * 2
#if DEBUG
            if (quot != null)
            {
                if (posQuot < 0)
                {
                    throw new ArgumentException("posQuot (" + posQuot +
                      ") is less than 0");
                }
                if (posQuot > quot.Length)
                {
                    throw new ArgumentException("posQuot (" + posQuot +
                      ") is more than " + quot.Length);
                }
                if ((blockCount * 2) < 0)
                {
                    throw new ArgumentException("blockCount*2 (" + (blockCount * 2) +
                      ") is less than 0");
                }
                if ((blockCount * 2) > quot.Length)
                {
                    throw new ArgumentException("blockCount*2 (" + (blockCount * 2) +
                      ") is more than " + quot.Length);
                }
                if (quot.Length - posQuot < blockCount * 2)
                {
                    throw new ArgumentException("quot's length minus " + posQuot + " (" +
                      (quot.Length - posQuot) + ") is less than " + (blockCount * 2));
                }
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is more than " + rem.Length);
                }
                if ((blockCount * 2) < 0)
                {
                    throw new ArgumentException("blockCount*2 (" + (blockCount * 2) +
                      ") is less than 0");
                }
                if ((blockCount * 2) > rem.Length)
                {
                    throw new ArgumentException("blockCount*2 (" + (blockCount * 2) +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < blockCount * 2)
                {
                    throw new ArgumentException("rem's length minus " + posRem + " (" +
                      (rem.Length - posRem) + ") is less than " + (blockCount * 2));
                }
            }
            if (tmp.Length < blockCount * 6)
            {
                throw new ArgumentException("tmp.Length (" + tmp.Length +
                  ") is less than " + (blockCount * 6));
            }
#endif
            // Implements Algorithm 2 of Burnikel & Ziegler 1998
            int c;
            // If AHigh is less than BHigh
            if (
        WordsCompare(
        valueAMidHigh,
        posAMidHigh + blockCount,
        blockCount,
        b,
        posB + blockCount,
        blockCount) < 0)
            {
                // Divide AMidHigh by BHigh
                RecursiveDivideInner(
         valueAMidHigh,
         posAMidHigh,
         b,
         posB + blockCount,
         quot,
         posQuot,
         rem,
         posRem,
         blockCount);
                // Copy remainder to temp at block position 4
                Array.Copy(rem, posRem, tmp, blockCount * 4, blockCount);
                Array.Clear(tmp, blockCount * 5, blockCount);
            }
            else
            {
                // BHigh is less than AHigh
                // set quotient to all ones
                for (int i = 0; i < blockCount; ++i)
                {
                    quot[posQuot + i] = unchecked((short)0xffff);
                }
                Array.Clear(quot, posQuot + blockCount, blockCount);
                // copy AMidHigh to temp
                Array.Copy(
               valueAMidHigh,
               posAMidHigh,
               tmp,
               blockCount * 4,
               blockCount * 2);
                // subtract BHigh from temp's high block
                SubtractInternal(
          tmp,
          blockCount * 5,
          tmp,
          blockCount * 5,
          b,
          posB + blockCount,
          blockCount);
                // add BHigh to temp
                c = AddInternal(
          tmp,
          blockCount * 4,
          tmp,
          blockCount * 4,
          b,
          posB + blockCount,
          blockCount);
                Increment(tmp, blockCount * 5, blockCount, (short)c);
            }
            AsymmetricMultiply(
        tmp,
        0,
        tmp,
        blockCount * 2,
        quot,
        posQuot,
        blockCount,
        b,
        posB,
        blockCount);
            int bc3 = blockCount * 3;
            Array.Copy(valueALow, posALow, tmp, bc3, blockCount);
            Array.Clear(tmp, blockCount * 2, blockCount);
            c = SubtractInternal(tmp, bc3, tmp, bc3, tmp, 0, blockCount * 3);
            if (c != 0)
            {
                while (true)
                {
                    c = AddInternal(tmp, bc3, tmp, bc3, b, posB, blockCount * 2);
                    c = Increment(tmp, blockCount * 5, blockCount, (short)c);
                    Decrement(quot, posQuot, blockCount * 2, (short)1);
                    if (c != 0)
                    {
                        break;
                    }
                }
            }
            Array.Copy(tmp, bc3, rem, posRem, blockCount * 2);
        }

        private static void RecursiveDivideInner(
          short[] a,
          int posA,
          short[] b,
          int posB,
          short[] quot,
          int posQuot,
          short[] rem,
          int posRem,
          int blockSize)
        {
            // NOTE: size of 'a', 'quot', and 'rem' is 'blockSize'*2
            // NOTE: size of 'b' is 'blockSize'
#if DEBUG
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (posA < 0)
            {
                throw new ArgumentException("posA (" + posA +
                  ") is less than 0");
            }
            if (posA > a.Length)
            {
                throw new ArgumentException("posA (" + posA + ") is more than " +
                  a.Length);
            }
            if ((blockSize * 2) < 0)
            {
                throw new ArgumentException("(blockSize*2) (" + (blockSize * 2) +
                  ") is less than 0");
            }
            if ((blockSize * 2) > a.Length)
            {
                throw new ArgumentException("(blockSize*2) (" + (blockSize * 2) +
                  ") is more than " + a.Length);
            }
            if ((a.Length - posA) < (blockSize * 2))
            {
                throw new ArgumentException("a's length minus " + posA + " (" +
                  (a.Length - posA) + ") is less than " + (blockSize * 2));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (posB < 0)
            {
                throw new ArgumentException("posB (" + posB +
                  ") is less than 0");
            }
            if (posB > b.Length)
            {
                throw new ArgumentException("posB (" + posB + ") is more than " +
                  b.Length);
            }
            if (blockSize < 0)
            {
                throw new ArgumentException("blockSize (" + blockSize +
                  ") is less than 0");
            }
            if (blockSize > b.Length)
            {
                throw new ArgumentException("blockSize (" + blockSize +
                  ") is more than " + b.Length);
            }
            if (b.Length - posB < blockSize)
            {
                throw new ArgumentException("b's length minus " + posB + " (" +
                  (b.Length - posB) + ") is less than " + blockSize);
            }
            if (quot != null)
            {
                if (posQuot < 0)
                {
                    throw new ArgumentException("posQuot (" + posQuot +
                      ") is less than 0");
                }
                if (posQuot > quot.Length)
                {
                    throw new ArgumentException("posQuot (" + posQuot +
                      ") is more than " + quot.Length);
                }
                if ((blockSize * 2) < 0)
                {
                    throw new ArgumentException("blockSize*2 (" + (blockSize * 2) +
                      ") is less than 0");
                }
                if ((blockSize * 2) > quot.Length)
                {
                    throw new ArgumentException("blockSize*2 (" + (blockSize * 2) +
                      ") is more than " + quot.Length);
                }
                if (quot.Length - posQuot < blockSize * 2)
                {
                    throw new ArgumentException("quot's length minus " + posQuot + " (" +
                      (quot.Length - posQuot) + ") is less than " + (blockSize * 2));
                }
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is more than " + rem.Length);
                }
                if ((blockSize * 2) < 0)
                {
                    throw new ArgumentException("blockSize*2 (" + (blockSize * 2) +
                      ") is less than 0");
                }
                if ((blockSize * 2) > rem.Length)
                {
                    throw new ArgumentException("blockSize*2 (" + (blockSize * 2) +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < (blockSize * 2))
                {
                    throw new ArgumentException("rem's length minus " + posRem + " (" +
                      (rem.Length - posRem) + ") is less than " + (blockSize * 2));
                }
            }
#endif
            // Implements Algorithm 1 of Burnikel & Ziegler 1998
            if (blockSize < RecursiveDivisionLimit || (blockSize & 1) == 1)
            {
                GeneralDivide(
          a,
          posA,
          blockSize * 2,
          b,
          posB,
          blockSize,
          quot,
          posQuot,
          rem,
          posRem);
            }
            else
            {
                int halfBlock = blockSize >> 1;
                short[] tmp = new short[halfBlock * 10];
                Array.Clear(quot, posQuot, blockSize * 2);
                Array.Clear(rem, posRem, blockSize);
                DivideThreeBlocksByTwo(
          a,
          posA + halfBlock,
          a,
          posA + blockSize,
          b,
          posB,
          halfBlock,
          tmp,
          halfBlock * 6,
          tmp,
          halfBlock * 8,
          tmp);
                DivideThreeBlocksByTwo(
          a,
          posA,
          tmp,
          halfBlock * 8,
          b,
          posB,
          halfBlock,
          quot,
          posQuot,
          rem,
          posRem,
          tmp);
                Array.Copy(tmp, halfBlock * 6, quot, posQuot + halfBlock, halfBlock);
            }
        }

        private static void RecursiveDivide(
         short[] a,
         int posA,
         int countA,
         short[] b,
         int posB,
         int countB,
         short[] quot,
         int posQuot,
         short[] rem,
         int posRem)
        {
#if DEBUG
            if (countB <= RecursiveDivisionLimit)
            {
                throw new ArgumentException("countB (" + countB +
                  ") is not greater than " +
                  RecursiveDivisionLimit);
            }
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (posA < 0)
            {
                throw new ArgumentException("posA (" + posA +
                  ") is less than 0");
            }
            if (posA > a.Length)
            {
                throw new ArgumentException("posA (" + posA + ") is more than " +
                  a.Length);
            }
            if (countA < 0)
            {
                throw new ArgumentException("countA (" + countA +
                  ") is less than 0");
            }
            if (countA > a.Length)
            {
                throw new ArgumentException("countA (" + countA +
                  ") is more than " + a.Length);
            }
            if (a.Length - posA < countA)
            {
                throw new ArgumentException("a's length minus " + posA + " (" +
                  (a.Length - posA) + ") is less than " + countA);
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (posB < 0)
            {
                throw new ArgumentException("posB (" + posB +
                  ") is less than 0");
            }
            if (posB > b.Length)
            {
                throw new ArgumentException("posB (" + posB + ") is more than " +
                  b.Length);
            }
            if (countB < 0)
            {
                throw new ArgumentException("countB (" + countB +
                  ") is less than 0");
            }
            if (countB > b.Length)
            {
                throw new ArgumentException("countB (" + countB +
                  ") is more than " + b.Length);
            }
            if (b.Length - posB < countB)
            {
                throw new ArgumentException("b's length minus " + posB + " (" +
                  (b.Length - posB) + ") is less than " + countB);
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is more than " + rem.Length);
                }
                if (countB < 0)
                {
                    throw new ArgumentException("countB (" + countB +
                      ") is less than 0");
                }
                if (countB > rem.Length)
                {
                    throw new ArgumentException("countB (" + countB +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < countB)
                {
                    throw new ArgumentException("rem's length minus " + posRem + " (" +
                      (rem.Length - posRem) + ") is less than " + countB);
                }
            }
#endif
            int workPosA, workPosB, i;
            short[] workA = a;
            short[] workB = b;
            workPosA = posA;
            workPosB = posB;
            int blocksB = RecursiveDivisionLimit;
            int shiftB = 0;
            int m = 1;
            while (blocksB < countB)
            {
                blocksB <<= 1;
                m <<= 1;
            }
            workB = new short[blocksB];
            workPosB = 0;
            Array.Copy(b, posB, workB, blocksB - countB, countB);
            int shiftA = 0;
            int extraWord = 0;
            int wordsA = countA + (blocksB - countB);
            if ((b[countB - 1] & 0x8000) == 0)
            {
                int x = b[countB - 1];
                while ((x & 0x8000) == 0)
                {
                    ++shiftB;
                    x <<= 1;
                }
                x = a[countA - 1];
                while ((x & 0x8000) == 0)
                {
                    ++shiftA;
                    x <<= 1;
                }
                if (shiftA < shiftB)
                {
                    // Shifting A would require an extra word
                    ++extraWord;
                }
                ShiftWordsLeftByBits(
          workB,
          workPosB + blocksB - countB,
          countB,
          shiftB);
            }
            int blocksA = (wordsA + extraWord + (blocksB - 1)) / blocksB;
            int totalWordsA = blocksA * blocksB;
            workA = new short[totalWordsA];
            workPosA = 0;
            Array.Copy(
        a,
        posA,
        workA,
        workPosA + (blocksB - countB),
        countA);
            ShiftWordsLeftByBits(
        workA,
        workPosA + (blocksB - countB),
        countA + extraWord,
        shiftB);
            // Start division
            // "tmprem" holds temporary space for the following:
            // - blocksB: Remainder
            // - blocksB * 2: Dividend
            // - blocksB * 2: Quotient
            short[] tmprem = new short[blocksB * 5];
            int size = 0;
            for (i = blocksA - 1; i >= 0; --i)
            {
                int workAIndex = workPosA + (i * blocksB);
                // Set the low part of the sub-dividend with the working
                // block of the dividend
                Array.Copy(workA, workAIndex, tmprem, blocksB, blocksB);
                // Clear the quotient
                Array.Clear(tmprem, blocksB * 3, blocksB << 1);
                RecursiveDivideInner(
          tmprem,
          blocksB,
          workB,
          workPosB,
          tmprem,
          blocksB * 3,
          tmprem,
          0,
          blocksB);
                if (quot != null)
                {
                    size = Math.Min(blocksB, quot.Length - (i * blocksB));
                    // DebugUtility.Log("quot len=" + quot.Length + ",bb=" + blocksB +
                    // ",size=" + size + " [" + countA + "," + countB + "]");
                    if (size > 0)
                    {
                        Array.Copy(
                tmprem,
               blocksB * 3,
               quot,
               posQuot + (i * blocksB),
                            size);
                    }
                }
                // Set the high part of the sub-dividend with the remainder
                Array.Copy(tmprem, 0, tmprem, blocksB << 1, blocksB);
            }
            if (rem != null)
            {
                Array.Copy(tmprem, blocksB - countB, rem, posRem, countB);
                ShiftWordsRightByBits(rem, posRem, countB, shiftB);
            }
        }

        private static string WordsToString(short[] a, int pos, int len)
        {
            while (len != 0 && a[pos + len - 1] == 0)
            {
                --len;
            }
            if (len == 0)
            {
                return "\"0\"";
            }
            short[] words = new short[len];
            Array.Copy(a, pos, words, 0, len);
            return "\"" + new EInteger(len, words, false).ToUnoptString() + "\"";
        }

        private static string WordsToStringHex(short[] a, int pos, int len)
        {
            while (len != 0 && a[pos + len - 1] == 0)
            {
                --len;
            }
            if (len == 0)
            {
                return "\"0\"";
            }
            short[] words = new short[len];
            Array.Copy(a, pos, words, 0, len);
            return "\"" + new EInteger(len, words, false).ToRadixString(16) +
                    "\"";
        }

        private static string WordsToString2(
  short[] a,
  int pos,
  int len,
  short[] b,
  int pos2,
  int len2)
        {
            short[] words = new short[len + len2];
            Array.Copy(a, pos, words, 0, len);
            Array.Copy(b, pos2, words, len, len2);
            len += len2;
            while (len != 0 && words[len - 1] == 0)
            {
                --len;
            }
            return (len == 0) ?
        "\"0\"" : ("\"" + new EInteger(
            len,
            words,
            false).ToUnoptString() + "\"");
        }

        private static void GeneralDivide(
         short[] a,
         int posA,
         int countA,
         short[] b,
         int posB,
         int countB,
         short[] quot,
         int posQuot,
         short[] rem,
         int posRem)
        {
#if DEBUG
            if (!(countA > 0 && countB > 0))
            {
                throw new ArgumentException("doesn't satisfy countA>0 && countB>0");
            }
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (posA < 0)
            {
                throw new ArgumentException("posA (" + posA +
                  ") is less than 0");
            }
            if (posA > a.Length)
            {
                throw new ArgumentException("posA (" + posA + ") is more than " +
                  a.Length);
            }
            if (countA < 0)
            {
                throw new ArgumentException("countA (" + countA +
                  ") is less than 0");
            }
            if (countA > a.Length)
            {
                throw new ArgumentException("countA (" + countA +
                  ") is more than " + a.Length);
            }
            if (a.Length - posA < countA)
            {
                throw new ArgumentException("a's length minus " + posA + " (" +
                  (a.Length - posA) + ") is less than " + countA);
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (posB < 0)
            {
                throw new ArgumentException("posB (" + posB +
                  ") is less than 0");
            }
            if (posB > b.Length)
            {
                throw new ArgumentException("posB (" + posB + ") is more than " +
                  b.Length);
            }
            if (countB < 0)
            {
                throw new ArgumentException("countB (" + countB +
                  ") is less than 0");
            }
            if (countB > b.Length)
            {
                throw new ArgumentException("countB (" + countB +
                  ") is more than " + b.Length);
            }
            if (b.Length - posB < countB)
            {
                throw new ArgumentException("b's length minus " + posB + " (" +
                  (b.Length - posB) + ") is less than " + countB);
            }
            if (quot != null)
            {
                if (posQuot < 0)
                {
                    throw new ArgumentException("posQuot (" + posQuot +
                      ") is less than 0");
                }
                if (posQuot > quot.Length)
                {
                    throw new ArgumentException("posQuot (" + posQuot +
                      ") is more than " + quot.Length);
                }
                if (countA - countB + 1 < 0)
                {
                    throw new ArgumentException("(countA-countB+1) (" + (countA - countB + 1) +
                      ") is less than 0");
                }
                if (countA - countB + 1 > quot.Length)
                {
                    throw new ArgumentException("(countA-countB+1) (" + (countA - countB + 1) +
                      ") is more than " + quot.Length);
                }
                if ((quot.Length - posQuot) < (countA - countB + 1))
                {
                    throw new ArgumentException("quot's length minus " + posQuot + " (" +
                      (quot.Length - posQuot) + ") is less than " +
                      (countA - countB + 1));
                }
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem (" + posRem +
                      ") is more than " + rem.Length);
                }
                if (countB < 0)
                {
                    throw new ArgumentException("countB (" + countB +
                      ") is less than 0");
                }
                if (countB > rem.Length)
                {
                    throw new ArgumentException("countB (" + countB +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < countB)
                {
                    throw new ArgumentException("rem's length minus " + posRem + " (" +
                      (rem.Length - posRem) + ") is less than " + countB);
                }
            }
#endif
            int origQuotSize = countA - countB + 1;
            int origCountA = countA;
            int origCountB = countB;
            while (countB > 0 && b[posB + countB - 1] == 0)
            {
                --countB;
            }
            while (countA > 0 && a[posA + countA - 1] == 0)
            {
                --countA;
            }
            int newQuotSize = countA - countB + 1;
            if (quot != null)
            {
                if (newQuotSize < 0 || newQuotSize >= origQuotSize)
                {
                    Array.Clear(quot, posQuot, Math.Max(0, origQuotSize));
                }
                else
                {
                    Array.Clear(
          quot,
          posQuot + newQuotSize,
          Math.Max(0, origQuotSize - newQuotSize));
                }
            }
            if (rem != null)
            {
                Array.Clear(rem, posRem + countB, origCountB - countB);
            }
#if DEBUG
            if (countA != 0 && !(a[posA + countA - 1] != 0))
            {
                throw new ArgumentException();
            }
            if (countB == 0 || !(b[posB + countB - 1] != 0))
            {
                throw new ArgumentException();
            }
#endif
            if (countA < countB)
            {
                // A is less than B, so quotient is 0, remainder is "a"
                if (quot != null)
                {
                    Array.Clear(quot, posQuot, Math.Max(0, origQuotSize));
                }
                if (rem != null)
                {
                    Array.Copy(a, posA, rem, posRem, origCountA);
                }
                return;
            }
            else if (countA == countB)
            {
                int cmp = Compare(a, posA, b, posB, countA);
                if (cmp == 0)
                {
                    // A equals B, so quotient is 1, remainder is 0
                    if (quot != null)
                    {
                        quot[posQuot] = 1;
                        Array.Clear(quot, posQuot + 1, Math.Max(0, origQuotSize - 1));
                    }
                    if (rem != null)
                    {
                        Array.Clear(rem, posRem, countA);
                    }
                    return;
                }
                else if (cmp < 0)
                {
                    // A is less than B, so quotient is 0, remainder is "a"
                    if (quot != null)
                    {
                        Array.Clear(quot, posQuot, Math.Max(0, origQuotSize));
                    }
                    if (rem != null)
                    {
                        Array.Copy(a, posA, rem, posRem, origCountA);
                    }
                    return;
                }
            }
            if (countB == 1)
            {
                // Divisor is a single word
                short shortRemainder = FastDivideAndRemainder(
                      quot,
                      posQuot,
                      a,
                      posA,
                      countA,
                      b[posB]);
                if (rem != null)
                {
                    rem[posRem] = shortRemainder;
                }
                return;
            }
            int workPosA, workPosB;
            short[] workAB = null;
            short[] workA = a;
            short[] workB = b;
            workPosA = posA;
            workPosB = posB;
            if (countB > RecursiveDivisionLimit)
            {
                RecursiveDivide(
          a,
          posA,
          countA,
          b,
          posB,
          countB,
          quot,
          posQuot,
          rem,
          posRem);
                return;
            }
            int sh = 0;
            bool noShift = false;
            if ((b[posB + countB - 1] & 0x8000) == 0)
            {
                // Normalize a and b by shifting both until the high
                // bit of b is the highest bit of the last word
                int x = b[posB + countB - 1];
                if (x == 0)
                {
                    throw new InvalidOperationException();
                }
                while ((x & 0x8000) == 0)
                {
                    ++sh;
                    x <<= 1;
                }
                workAB = new short[countA + 1 + countB];
                workPosA = 0;
                workPosB = countA + 1;
                workA = workAB;
                workB = workAB;
                Array.Copy(a, posA, workA, workPosA, countA);
                Array.Copy(b, posB, workB, workPosB, countB);
                ShiftWordsLeftByBits(workA, workPosA, countA + 1, sh);
                ShiftWordsLeftByBits(workB, workPosB, countB, sh);
            }
            else
            {
                noShift = true;
                workA = new short[countA + 1];
                workPosA = 0;
                Array.Copy(a, posA, workA, workPosA, countA);
            }
            int c = 0;
            short pieceBHigh = workB[workPosB + countB - 1];
            int pieceBHighInt = ((int)pieceBHigh) & 0xffff;
            int endIndex = workPosA + countA;
#if DEBUG
            // Assert that pieceBHighInt is normalized
            if (!((pieceBHighInt & 0x8000) != 0))
            {
                throw new ArgumentException("doesn't satisfy (pieceBHighInt & 0x8000)!=0");
            }
#endif
            short pieceBNextHigh = workB[workPosB + countB - 2];
            int pieceBNextHighInt = ((int)pieceBNextHigh) & 0xffff;
            for (int offset = countA - countB; offset >= 0; --offset)
            {
                int wpoffset = workPosA + offset;
                int wpaNextHigh = ((int)workA[wpoffset + countB - 1]) & 0xffff;
                int wpaHigh = 0;
                if (!noShift || wpoffset + countB < endIndex)
                {
                    wpaHigh = ((int)workA[wpoffset + countB]) & 0xffff;
                }
                int dividend = unchecked(wpaNextHigh + (wpaHigh << 16));
                int divnext = ((int)workA[wpoffset + countB - 2]) & 0xffff;
                int quorem0 = (dividend >> 31) == 0 ? (dividend / pieceBHighInt) :
                 unchecked((int)(((long)dividend & 0xffffffffL) / pieceBHighInt));
                int quorem1 = unchecked(dividend - (quorem0 * pieceBHighInt));
                // DebugUtility.Log("{0:X8}/{1:X4} = {2:X8},{3:X4}",
                // dividend, pieceBHigh, quorem0, quorem1);
                long t = (((long)quorem1) << 16) | (divnext & 0xffffL);
                // NOTE: quorem0 won't be higher than (1<< 16)+1 as long as
                // pieceBHighInt is
                // normalized (see Burnikel & Ziegler 1998). Since the following
                // code block
                // corrects all cases where quorem0 is too high by 2, and all
                // remaining cases
                // will reduce quorem0 by 1 if it's at least (1<< 16), quorem0 will
                // be guaranteed to
                // have a bit length of 16 or less by the end of the code block.
                if ((quorem0 >> 16) != 0 ||
                  (unchecked(quorem0 * pieceBNextHighInt) & 0xffffffffL) > t)
                {
                    quorem1 += pieceBHighInt;
                    --quorem0;
                    if ((quorem1 >> 16) == 0)
                    {
                        t = (((long)quorem1) << 16) | (divnext & 0xffffL);
                        if ((quorem0 >> 16) != 0 ||
                            (unchecked(quorem0 * pieceBNextHighInt) & 0xffffffffL) > t)
                        {
                            --quorem0;
                            if (rem == null && offset == 0)
                            {
                                // We can stop now and break; all cases where quorem0
                                // is 2 too big will have been caught by now
                                if (quot != null)
                                {
                                    quot[posQuot + offset] = unchecked((short)quorem0);
                                }
                                break;
                            }
                        }
                    }
                }
                int q1 = quorem0 & 0xffff;
#if DEBUG
                int q2 = (quorem0 >> 16) & 0xffff;
                if (q2 != 0)
                {
                    // NOTE: The checks above should have ensured that quorem0 can't
                    // be longer than 16 bits.
                    throw new InvalidOperationException();
                }
#endif

                c = LinearMultiplySubtractMinuend1Bigger(
                workA,
                wpoffset,
                workA,
                wpoffset,
                q1,
                workB,
                workPosB,
                countB);
                if (c != 0)
                {
                    // T(workA,workPosA,countA+1,"workA X");
                    c = AddInternal(
            workA,
            wpoffset,
            workA,
            wpoffset,
            workB,
            workPosB,
            countB);
                    c = Increment(workA, wpoffset + countB, 1, (short)c);
                    // T(workA,workPosA,countA+1,"workA "+c);
                    --quorem0;
                }
                if (quot != null)
                {
                    quot[posQuot + offset] = unchecked((short)quorem0);
                }
            }
            if (rem != null)
            {
                if (sh != 0)
                {
                    ShiftWordsRightByBits(workA, workPosA, countB + 1, sh);
                }
                Array.Copy(workA, workPosA, rem, posRem, countB);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger[] DivRem(EInteger divisor)
        {
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            int words1Size = this.wordCount;
            int words2Size = divisor.wordCount;
            if (words2Size == 0)
            {
                // Divisor is 0
                throw new DivideByZeroException();
            }

            if (words1Size < words2Size)
            {
                // Dividend is less than divisor (includes case
                // where dividend is 0)
                return new[] { EInteger.Zero, this };
            }
            if (words2Size == 1)
            {
                // divisor is small, use a fast path
                short[] quotient = new short[this.wordCount];
                int smallRemainder;
                switch (divisor.words[0])
                {
                    case 2:
                        smallRemainder = (int)FastDivideAndRemainderTwo(
                         quotient,
                         0,
                         this.words,
                         0,
                         words1Size);
                        break;
                    case 10:
                        smallRemainder = (int)FastDivideAndRemainderTen(
                         quotient,
                         0,
                         this.words,
                         0,
                         words1Size);
                        break;
                    default:
                        // DebugUtility.Log("smalldiv=" + (divisor.words[0]));
                        smallRemainder = ((int)FastDivideAndRemainder(
                          quotient,
                          0,
                          this.words,
                          0,
                          words1Size,
                          divisor.words[0])) & 0xffff;
                        break;
                }
                int count = this.wordCount;
                while (count != 0 &&
                       quotient[count - 1] == 0)
                {
                    --count;
                }
                if (count == 0)
                {
                    return new[] { EInteger.Zero, this };
                }
                quotient = ShortenArray(quotient, count);
                EInteger bigquo = new EInteger(
                  count,
                  quotient,
                  this.negative ^ divisor.negative);
                if (this.negative)
                {
                    smallRemainder = -smallRemainder;
                }
                return new[] { bigquo, EInteger.FromInt64(smallRemainder) };
            }
            if (this.CanFitInInt32() && divisor.CanFitInInt32())
            {
                long dividendSmall = this.ToInt32Checked();
                long divisorSmall = divisor.ToInt32Checked();
                if (dividendSmall != Int32.MinValue || divisorSmall != -1)
                {
                    long quotientSmall = dividendSmall / divisorSmall;
                    long remainderSmall = dividendSmall - (quotientSmall * divisorSmall);
                    return new[] {
            EInteger.FromInt64(quotientSmall),
            EInteger.FromInt64(remainderSmall) };
                }
            }
            else if (this.CanFitInInt64() && divisor.CanFitInInt64())
            {
                long dividendLong = this.ToInt64Checked();
                long divisorLong = divisor.ToInt64Checked();
                if (dividendLong != Int64.MinValue || divisorLong != -1)
                {
                    long quotientLong = dividendLong / divisorLong;
                    long remainderLong = dividendLong - (quotientLong * divisorLong);
                    return new[] {
            EInteger.FromInt64(quotientLong),
            EInteger.FromInt64(remainderLong) };
                }
                // DebugUtility.Log("int64divrem {0}/{1}"
                // , this.ToInt64Checked(), divisor.ToInt64Checked());
            }
            // --- General case
            short[] bigRemainderreg = new short[((int)words2Size)];
            short[] quotientreg = new short[((int)(words1Size - words2Size + 1))];
            GeneralDivide(
        this.words,
        0,
        this.wordCount,
        divisor.words,
        0,
        divisor.wordCount,
        quotientreg,
        0,
        bigRemainderreg,
        0);
            int remCount = CountWords(bigRemainderreg);
            int quoCount = CountWords(quotientreg);
            bigRemainderreg = ShortenArray(bigRemainderreg, remCount);
            quotientreg = ShortenArray(quotientreg, quoCount);
            EInteger bigrem = (remCount == 0) ? EInteger.Zero : new
              EInteger(remCount, bigRemainderreg, this.negative);
            EInteger bigquo2 = (quoCount == 0) ? EInteger.Zero : new
              EInteger(quoCount, quotientreg, this.negative ^ divisor.negative);
            return new[] { bigquo2, bigrem };
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Equals(System.Object)"]/*'/>
        public override bool Equals(object obj)
        {
            if (!(obj is EInteger other))
            {
                return false;
            }
            if (this.wordCount == other.wordCount)
            {
                if (this.negative != other.negative)
                {
                    return false;
                }
                for (int i = 0; i < this.wordCount; ++i)
                {
                    if (this.words[i] != other.words[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        private static EInteger LeftShiftBigIntVar(EInteger ei, EInteger bigShift)
        {
            if (ei.IsZero)
            {
                return ei;
            }
            while (bigShift.Sign > 0)
            {
                int shift = 1000000;
                if (bigShift.CompareTo((EInteger)1000000) < 0)
                {
                    shift = bigShift.ToInt32Checked();
                }
                ei <<= shift;
                bigShift -= (EInteger)shift;
            }
            return ei;
        }

        private static EInteger GcdLong(long u, long v)
        {
            // Adapted from Christian Stigen Larsen's
            // public domain GCD code
#if DEBUG
            if (!(u >= 0 && v >= 0))
            {
                throw new ArgumentException("doesn't satisfy u>= 0 && v>= 0");
            }
#endif

            int shl = 0;
            while (u != 0 && v != 0 && u != v)
            {
                bool eu = (u & 1L) == 0;
                bool ev = (v & 1L) == 0;
                if (eu && ev)
                {
                    ++shl;
                    u >>= 1;
                    v >>= 1;
                }
                else if (eu && !ev)
                {
                    u >>= 1;
                }
                else if (!eu && ev)
                {
                    v >>= 1;
                }
                else if (u >= v)
                {
                    u = (u - v) >> 1;
                }
                else
                {
                    long tmp = u;
                    u = (v - u) >> 1;
                    v = tmp;
                }
            }
            EInteger eret = (u == 0) ?
              EInteger.FromInt64(v << shl) : EInteger.FromInt64(u << shl);
            return eret;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Gcd(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger Gcd(EInteger bigintSecond)
        {
            if (bigintSecond == null)
            {
                throw new ArgumentNullException(nameof(bigintSecond));
            }
            if (this.IsZero)
            {
                return bigintSecond.Abs();
            }
            EInteger thisValue = this.Abs();
            if (bigintSecond.IsZero)
            {
                return thisValue;
            }
            bigintSecond = bigintSecond.Abs();
            if (bigintSecond.Equals(EInteger.One) ||
                thisValue.Equals(bigintSecond))
            {
                return bigintSecond;
            }
            if (thisValue.Equals(EInteger.One))
            {
                return thisValue;
            }
            if (thisValue.CanFitInInt64() && bigintSecond.CanFitInInt64())
            {
                long u = thisValue.ToInt64Unchecked();
                long v = bigintSecond.ToInt64Unchecked();
                return GcdLong(u, v);
            }
            else
            {
                // Big integer version of code above
                int bshl = 0;
                EInteger ebshl = null;
                short[] bu = thisValue.Copy();
                short[] bv = bigintSecond.Copy();
                int buc = thisValue.wordCount;
                int bvc = bigintSecond.wordCount;
                while (buc != 0 && bvc != 0 && !WordsEqual(bu, buc, bv, bvc))
                {
                    if (buc <= 3 && bvc <= 3)
                    {
                        return GcdLong(
                          WordsToLongUnchecked(bu, buc),
                          WordsToLongUnchecked(bv, bvc));
                    }
                    if ((bu[0] & 0x0f) == 0 && (bv[0] & 0x0f) == 0)
                    {
                        if (bshl < 0)
                        {
                            ebshl += EInteger.FromInt32(4);
                        }
                        else if (bshl == Int32.MaxValue - 3)
                        {
                            ebshl = EInteger.FromInt32(Int32.MaxValue - 3);
                            ebshl += EInteger.FromInt32(4);
                            bshl = -1;
                        }
                        else
                        {
                            bshl += 4;
                        }
                        buc = WordsShiftRightFour(bu, buc);
                        bvc = WordsShiftRightFour(bv, bvc);
                        continue;
                    }
                    bool eu = (bu[0] & 0x01) == 0;
                    bool ev = (bv[0] & 0x01) == 0;
                    if (eu && ev)
                    {
                        if (bshl < 0)
                        {
                            ebshl += EInteger.One;
                        }
                        else if (bshl == Int32.MaxValue)
                        {
                            ebshl = EInteger.FromInt32(Int32.MaxValue);
                            ebshl += EInteger.One;
                            bshl = -1;
                        }
                        else
                        {
                            ++bshl;
                        }
                        buc = WordsShiftRightOne(bu, buc);
                        bvc = WordsShiftRightOne(bv, bvc);
                    }
                    else if (eu && !ev)
                    {
                        buc = (Math.Abs(buc - bvc) > 1 && (bu[0] & 0x0f) == 0) ?
                          WordsShiftRightFour(bu, buc) :
            WordsShiftRightOne(bu, buc);
                    }
                    else if (!eu && ev)
                    {
                        if ((bv[0] & 0xff) == 0 && Math.Abs(buc - bvc) > 1)
                        {
                            // DebugUtility.Log("bv8");
                            bvc = WordsShiftRightEight(bv, bvc);
                        }
                        else
                        {
                            bvc = (
                           (bv[0] & 0x0f) == 0 && Math.Abs(
                           buc - bvc) > 1) ?
                           WordsShiftRightFour(bv, bvc) : WordsShiftRightOne(bv, bvc);
                        }
                    }
                    else if (WordsCompare(bu, buc, bv, bvc) >= 0)
                    {
                        buc = WordsSubtract(bu, buc, bv, bvc);
                        buc = (Math.Abs(buc - bvc) > 1 && (bu[0] & 0x02) == 0) ?
                          WordsShiftRightTwo(bu, buc) : WordsShiftRightOne(bu, buc);
                    }
                    else
                    {
                        short[] butmp = bv;
                        short[] bvtmp = bu;
                        int buctmp = bvc;
                        int bvctmp = buc;
                        buctmp = WordsSubtract(butmp, buctmp, bvtmp, bvctmp);
                        buctmp = WordsShiftRightOne(butmp, buctmp);
                        bu = butmp;
                        bv = bvtmp;
                        buc = buctmp;
                        bvc = bvctmp;
                    }
                }
                EInteger valueBuVar = new EInteger(buc, bu, false);
                EInteger valueBvVar = new EInteger(bvc, bv, false);
                if (bshl >= 0)
                {
                    valueBuVar = valueBuVar.IsZero ? (valueBvVar << bshl) : (valueBuVar <<
                             bshl);
                }
                else
                {
                    valueBuVar = valueBuVar.IsZero ?
            LeftShiftBigIntVar(
           valueBvVar,
           ebshl) : LeftShiftBigIntVar(
           valueBuVar,
           ebshl);
                }
                return valueBuVar;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetDigitCount"]/*'/>
        public int GetDigitCount()
        {
            if (this.IsZero)
            {
                return 1;
            }
            if (this.HasSmallValue())
            {
                long value = this.ToInt64Checked();
                if (value == Int64.MinValue)
                {
                    return 19;
                }
                if (value < 0)
                {
                    value = -value;
                }
                if (value >= 1000000000L)
                {
                    return (value >= 1000000000000000000L) ? 19 : ((value >=
                             100000000000000000L) ? 18 : ((value >= 10000000000000000L) ?
                              17 : ((value >= 1000000000000000L) ? 16 :
                              ((value >= 100000000000000L) ? 15 : ((value
                              >= 10000000000000L) ?
                              14 : ((value >= 1000000000000L) ? 13 : ((value
                              >= 100000000000L) ? 12 : ((value >= 10000000000L) ?
                              11 : ((value >= 1000000000L) ? 10 : 9)))))))));
                }
                else
                {
                    int v2 = (int)value;
                    return (v2 >= 100000000) ? 9 : ((v2 >= 10000000) ? 8 : ((v2 >=
                              1000000) ? 7 : ((v2 >= 100000) ? 6 : ((v2
                              >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ?
                              3 : ((v2 >= 10) ? 2 : 1)))))));
                }
            }
            int bitlen = this.GetUnsignedBitLength();
            if (bitlen <= 2135)
            {
                // (x*631305) >> 21 is an approximation
                // to trunc(x*log10(2)) that is correct up
                // to x = 2135; the multiplication would require
                // up to 31 bits in all cases up to 2135
                // (cases up to 63 are already handled above)
                int minDigits = 1 + (((bitlen - 1) * 631305) >> 21);
                int maxDigits = 1 + ((bitlen * 631305) >> 21);
                if (minDigits == maxDigits)
                {
                    // Number of digits is the same for
                    // all numbers with this bit length
                    return minDigits;
                }
                return this.Abs().CompareTo(NumberUtility.FindPowerOfTen(minDigits)) >=
                      0 ? maxDigits : minDigits;
            }
            else if (bitlen <= 6432162)
            {
                // Much more accurate approximation
                int minDigits = ApproxLogTenOfTwo(bitlen - 1);
                int maxDigits = ApproxLogTenOfTwo(bitlen);
                if (minDigits == maxDigits)
                {
                    // Number of digits is the same for
                    // all numbers with this bit length
                    return 1 + minDigits;
                }
                if (bitlen < 50000)
                {
                    return this.Abs().CompareTo(NumberUtility.FindPowerOfTen(minDigits + 1))
                           >= 0 ? maxDigits + 1 : minDigits + 1;
                }
            }
            short[] tempReg = null;
            int currentCount = this.wordCount;
            int i = 0;
            while (currentCount != 0)
            {
                if (currentCount == 1 || (currentCount == 2 && tempReg[1] == 0))
                {
                    int rest = ((int)tempReg[0]) & 0xffff;
                    if (rest >= 10000)
                    {
                        i += 5;
                    }
                    else if (rest >= 1000)
                    {
                        i += 4;
                    }
                    else if (rest >= 100)
                    {
                        i += 3;
                    }
                    else if (rest >= 10)
                    {
                        i += 2;
                    }
                    else
                    {
                        ++i;
                    }
                    break;
                }
                if (currentCount == 2 && tempReg[1] > 0 && tempReg[1] <= 0x7fff)
                {
                    int rest = ((int)tempReg[0]) & 0xffff;
                    rest |= (((int)tempReg[1]) & 0xffff) << 16;
                    if (rest >= 1000000000)
                    {
                        i += 10;
                    }
                    else if (rest >= 100000000)
                    {
                        i += 9;
                    }
                    else if (rest >= 10000000)
                    {
                        i += 8;
                    }
                    else if (rest >= 1000000)
                    {
                        i += 7;
                    }
                    else if (rest >= 100000)
                    {
                        i += 6;
                    }
                    else if (rest >= 10000)
                    {
                        i += 5;
                    }
                    else if (rest >= 1000)
                    {
                        i += 4;
                    }
                    else if (rest >= 100)
                    {
                        i += 3;
                    }
                    else if (rest >= 10)
                    {
                        i += 2;
                    }
                    else
                    {
                        ++i;
                    }
                    break;
                }
                else
                {
                    int wci = currentCount;
                    short remainderShort = 0;
                    int quo, rem;
                    bool firstdigit = false;
                    short[] dividend = tempReg ?? this.words;
                    // Divide by 10000
                    while ((wci--) > 0)
                    {
                        int curValue = ((int)dividend[wci]) & 0xffff;
                        int currentDividend = unchecked((int)(curValue |
                                ((int)remainderShort << 16)));
                        quo = currentDividend / 10000;
                        if (!firstdigit && quo != 0)
                        {
                            firstdigit = true;
                            // Since we are dividing from left to right, the first
                            // nonzero result is the first part of the
                            // new quotient
                            bitlen = GetUnsignedBitLengthEx(quo, wci + 1);
                            if (bitlen <= 2135)
                            {
                                // (x*631305) >> 21 is an approximation
                                // to trunc(x*log10(2)) that is correct up
                                // to x = 2135; the multiplication would require
                                // up to 31 bits in all cases up to 2135
                                // (cases up to 64 are already handled above)
                                int minDigits = 1 + (((bitlen - 1) * 631305) >> 21);
                                int maxDigits = 1 + ((bitlen * 631305) >> 21);
                                if (minDigits == maxDigits)
                                {
                                    // Number of digits is the same for
                                    // all numbers with this bit length
                                    // NOTE: The 4 is the number of digits just
                                    // taken out of the number, and "i" is the
                                    // number of previously known digits
                                    return i + minDigits + 4;
                                }
                                if (minDigits > 1)
                                {
                                    int maxDigitEstimate = i + maxDigits + 4;
                                    int minDigitEstimate = i + minDigits + 4;
                                    return this.Abs().CompareTo(NumberUtility.FindPowerOfTen(minDigitEstimate))
                                                   >= 0 ? maxDigitEstimate : minDigitEstimate;
                                }
                            }
                            else if (bitlen <= 6432162)
                            {
                                // Much more accurate approximation
                                int minDigits = ApproxLogTenOfTwo(bitlen - 1);
                                int maxDigits = ApproxLogTenOfTwo(bitlen);
                                if (minDigits == maxDigits)
                                {
                                    // Number of digits is the same for
                                    // all numbers with this bit length
                                    return i + 1 + minDigits + 4;
                                }
                            }
                        }
                        if (tempReg == null)
                        {
                            if (quo != 0)
                            {
                                tempReg = new short[this.wordCount];
                                Array.Copy(this.words, tempReg, tempReg.Length);
                                // Use the calculated word count during division;
                                // zeros that may have occurred in division
                                // are not incorporated in the tempReg
                                currentCount = wci + 1;
                                tempReg[wci] = unchecked((short)quo);
                            }
                        }
                        else
                        {
                            tempReg[wci] = unchecked((short)quo);
                        }
                        rem = currentDividend - (10000 * quo);
                        remainderShort = unchecked((short)rem);
                    }
                    // Recalculate word count
                    while (currentCount != 0 && tempReg[currentCount - 1] == 0)
                    {
                        --currentCount;
                    }
                    i += 4;
                }
            }
            return i;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetHashCode"]/*'/>
        public override int GetHashCode()
        {
            int hashCodeValue = 0;
            unchecked
            {
                hashCodeValue += 1000000007 * this.Sign;
                if (this.words != null)
                {
                    for (int i = 0; i < this.wordCount; ++i)
                    {
                        hashCodeValue += 1000000013 * this.words[i];
                    }
                }
            }
            return hashCodeValue;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetLowBit"]/*'/>
        public int GetLowBit()
        {
            int retSetBit = 0;
            for (int i = 0; i < this.wordCount; ++i)
            {
                int c = ((int)this.words[i]) & 0xffff;
                if (c == 0)
                {
                    retSetBit += 16;
                }
                else
                {
                    return (((c << 15) & 0xffff) != 0) ? (retSetBit + 0) : ((((c <<
                              14) & 0xffff) != 0) ? (retSetBit + 1) : ((((c <<
                              13) & 0xffff) != 0) ? (retSetBit + 2) : ((((c <<
                              12) & 0xffff) != 0) ? (retSetBit + 3) : ((((c << 11) &
                              0xffff) != 0) ? (retSetBit +
                              4) : ((((c << 10) & 0xffff) != 0) ? (retSetBit +
                              5) : ((((c << 9) & 0xffff) != 0) ? (retSetBit + 6) :
                              ((((c <<
                          8) & 0xffff) != 0) ? (retSetBit + 7) : ((((c << 7) & 0xffff) !=
                              0) ? (retSetBit + 8) : ((((c << 6) & 0xffff) !=
                              0) ? (retSetBit + 9) : ((((c <<
                              5) & 0xffff) != 0) ? (retSetBit + 10) : ((((c <<
                              4) & 0xffff) != 0) ? (retSetBit + 11) : ((((c << 3) &
                              0xffff) != 0) ? (retSetBit + 12) : ((((c << 2) & 0xffff) !=
                              0) ? (retSetBit + 13) : ((((c << 1) & 0xffff) !=
                              0) ? (retSetBit + 14) : (retSetBit + 15)))))))))))))));
                }
            }
            return -1;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetLowBitAsEInteger"]/*'/>
        public EInteger GetLowBitAsEInteger()
        {
            long retSetBitLong = 0;
            for (int i = 0; i < this.wordCount; ++i)
            {
                int c = ((int)this.words[i]) & 0xffff;
                if (c == 0)
                {
                    retSetBitLong += 16;
                }
                else
                {
                    int rsb = (((c << 15) & 0xffff) != 0) ? 0 : ((((c <<
                              14) & 0xffff) != 0) ? 1 : ((((c <<
                              13) & 0xffff) != 0) ? 2 : ((((c <<
                              12) & 0xffff) != 0) ? 3 : ((((c << 11) &
                              0xffff) != 0) ? 4 : ((((c << 10) & 0xffff) != 0) ? 5 :
                          ((((c << 9) & 0xffff) != 0) ? 6 : ((((c <<
                      8) & 0xffff) != 0) ? 7 : ((((c << 7) & 0xffff) !=
                          0) ? 8 : ((((c << 6) & 0xffff) != 0) ? 9 : ((((c <<
                              5) & 0xffff) != 0) ? 10 : ((((c <<
                              4) & 0xffff) != 0) ? 11 : ((((c << 3) &
                          0xffff) != 0) ? 12 : ((((c << 2) & 0xffff) !=
                          0) ? 13 : ((((c << 1) & 0xffff) != 0) ? 14 : 15))))))))))))));
                    return EInteger.FromInt64(retSetBitLong).Add(
                     EInteger.FromInt32(rsb));
                }
            }
            return EInteger.FromInt32(-1);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetSignedBit(System.Int32)"]/*'/>
        public bool GetSignedBit(int index)
        {
            if (index < 0)
            {
                throw new ArgumentOutOfRangeException("index");
            }
            if (this.wordCount == 0)
            {
                return false;
            }
            if (this.negative)
            {
                int tcindex = 0;
                int wordpos = index / 16;
                if (wordpos >= this.words.Length)
                {
                    return true;
                }
                while (tcindex < wordpos && this.words[tcindex] == 0)
                {
                    ++tcindex;
                }
                short tc;
                unchecked
                {
                    tc = this.words[wordpos];
                    if (tcindex == wordpos)
                    {
                        --tc;
                    }
                    tc = (short)~tc;
                }
                return (bool)(((tc >> (int)(index & 15)) & 1) != 0);
            }
            return this.GetUnsignedBit(index);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetSignedBitLength"]/*'/>
        public int GetSignedBitLength()
        {
            int wc = this.wordCount;
            if (wc != 0)
            {
                if (this.negative)
                {
                    return this.Abs().Subtract(EInteger.One).GetSignedBitLength();
                }
                int numberValue = ((int)this.words[wc - 1]) & 0xffff;
                wc = (wc - 1) << 4;
                if (numberValue == 0)
                {
                    return wc;
                }
                wc += 16;
                unchecked
                {
                    if ((numberValue >> 8) == 0)
                    {
                        numberValue <<= 8;
                        wc -= 8;
                    }
                    if ((numberValue >> 12) == 0)
                    {
                        numberValue <<= 4;
                        wc -= 4;
                    }
                    if ((numberValue >> 14) == 0)
                    {
                        numberValue <<= 2;
                        wc -= 2;
                    }
                    return ((numberValue >> 15) == 0) ? wc - 1 : wc;
                }
            }
            return 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetUnsignedBit(System.Int32)"]/*'/>
        public bool GetUnsignedBit(int index)
        {
            if (index < 0)
            {
                throw new ArgumentException("index (" + index + ") is less than 0");
            }
            return ((index >> 4) < this.words.Length) &&
                ((bool)(((this.words[(index >> 4)] >> (int)(index & 15)) & 1) != 0));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetUnsignedBitLengthAsEInteger"]/*'/>
        public EInteger GetUnsignedBitLengthAsEInteger()
        {
            int wc = this.wordCount;
            if (wc != 0)
            {
                int numberValue = ((int)this.words[wc - 1]) & 0xffff;
                EInteger ebase = EInteger.FromInt32(wc - 1).ShiftLeft(4);
                if (numberValue == 0)
                {
                    return ebase;
                }
                wc = 16;
                unchecked
                {
                    if ((numberValue >> 8) == 0)
                    {
                        numberValue <<= 8;
                        wc -= 8;
                    }
                    if ((numberValue >> 12) == 0)
                    {
                        numberValue <<= 4;
                        wc -= 4;
                    }
                    if ((numberValue >> 14) == 0)
                    {
                        numberValue <<= 2;
                        wc -= 2;
                    }
                    if ((numberValue >> 15) == 0)
                    {
                        --wc;
                    }
                }
                return ebase.Add(EInteger.FromInt32(wc));
            }
            return EInteger.Zero;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetUnsignedBitLength"]/*'/>
        public int GetUnsignedBitLength()
        {
            int wc = this.wordCount;
            if (wc != 0)
            {
                int numberValue = ((int)this.words[wc - 1]) & 0xffff;
                wc = (wc - 1) << 4;
                if (numberValue == 0)
                {
                    return wc;
                }
                wc += 16;
                unchecked
                {
                    if ((numberValue >> 8) == 0)
                    {
                        numberValue <<= 8;
                        wc -= 8;
                    }
                    if ((numberValue >> 12) == 0)
                    {
                        numberValue <<= 4;
                        wc -= 4;
                    }
                    if ((numberValue >> 14) == 0)
                    {
                        numberValue <<= 2;
                        wc -= 2;
                    }
                    if ((numberValue >> 15) == 0)
                    {
                        --wc;
                    }
                }
                return wc;
            }
            return 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Mod(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger Mod(EInteger divisor)
        {
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            if (divisor.Sign < 0)
            {
                throw new ArithmeticException("Divisor is negative");
            }
            EInteger remainderEInt = this.Remainder(divisor);
            if (remainderEInt.Sign < 0)
            {
                remainderEInt = divisor.Add(remainderEInt);
            }
            return remainderEInt;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public EInteger ModPow(EInteger pow, EInteger mod)
        {
            if (pow == null)
            {
                throw new ArgumentNullException(nameof(pow));
            }
            if (mod == null)
            {
                throw new ArgumentNullException(nameof(mod));
            }
            if (pow.Sign < 0)
            {
                throw new ArgumentException("pow (" + pow + ") is less than 0");
            }
            if (mod.Sign <= 0)
            {
                throw new ArgumentException("mod (" + mod + ") is not greater than 0");
            }
            EInteger r = EInteger.One;
            EInteger eiv = this;
            while (!pow.IsZero)
            {
                if (!pow.IsEven)
                {
                    r = (r * (EInteger)eiv).Mod(mod);
                }
                pow >>= 1;
                if (!pow.IsZero)
                {
                    eiv = (eiv * (EInteger)eiv).Mod(mod);
                }
            }
            return r;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Multiply(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger Multiply(EInteger bigintMult)
        {
            if (bigintMult == null)
            {
                throw new ArgumentNullException(nameof(bigintMult));
            }
            if (this.wordCount == 0 || bigintMult.wordCount == 0)
            {
                return EInteger.Zero;
            }
            if (this.wordCount == 1 && this.words[0] == 1)
            {
                return this.negative ? bigintMult.Negate() : bigintMult;
            }
            if (bigintMult.wordCount == 1 && bigintMult.words[0] == 1)
            {
                return bigintMult.negative ? this.Negate() : this;
            }
            short[] productreg;
            int productwordCount;
            bool needShorten = true;
            if (this.wordCount == 1)
            {
                int wc;
                if (bigintMult.wordCount == 1)
                {
                    // NOTE: Result can't be 0 here, since checks
                    // for 0 were already made earlier in this function
                    productreg = new short[2];
                    int ba = ((int)this.words[0]) & 0xffff;
                    int bb = ((int)bigintMult.words[0]) & 0xffff;
                    ba = unchecked(ba * bb);
                    productreg[0] = unchecked((short)(ba & 0xffff));
                    productreg[1] = unchecked((short)((ba >> 16) & 0xffff));
                    short preg = productreg[1];
                    wc = (preg == 0) ? 1 : 2;
                    return new EInteger(
            wc,
            productreg,
            this.negative ^ bigintMult.negative);
                }
                wc = bigintMult.wordCount;
                int regLength = wc + 1;
                productreg = new short[regLength];
                productreg[wc] = LinearMultiply(
                  productreg,
                  0,
                  bigintMult.words,
                  0,
                  this.words[0],
                  wc);
                productwordCount = productreg.Length;
                needShorten = false;
            }
            else if (bigintMult.wordCount == 1)
            {
                int wc = this.wordCount;
                int regLength = wc + 1;
                productreg = new short[regLength];
                productreg[wc] = LinearMultiply(
                  productreg,
                  0,
                  this.words,
                  0,
                  bigintMult.words[0],
                  wc);
                productwordCount = productreg.Length;
                needShorten = false;
            }
            else if (this.Equals(bigintMult))
            {
                int words1Size = this.wordCount;
                productreg = new short[words1Size + words1Size];
                productwordCount = productreg.Length;
                short[] workspace = new short[words1Size + words1Size];
                RecursiveSquare(
                  productreg,
                  0,
                  workspace,
                  0,
                  this.words,
                  0,
                  words1Size);
            }
            else if (this.wordCount <= 10 && bigintMult.wordCount <= 10)
            {
                int wc = this.wordCount + bigintMult.wordCount;
                productreg = new short[wc];
                productwordCount = productreg.Length;
                SchoolbookMultiply(
                  productreg,
                  0,
                  this.words,
                  0,
                  this.wordCount,
                  bigintMult.words,
                  0,
                  bigintMult.wordCount);
                needShorten = false;
            }
            else
            {
                int words1Size = this.wordCount;
                int words2Size = bigintMult.wordCount;
                productreg = new short[(words1Size + words2Size)];
                short[] workspace = new short[words1Size + words2Size];
                productwordCount = productreg.Length;
                AsymmetricMultiply(
                  productreg,
                  0,
                  workspace,
                  0,
                  this.words,
                  0,
                  words1Size,
                  bigintMult.words,
                  0,
                  words2Size);
            }
            // Recalculate word count
            while (productwordCount != 0 && productreg[productwordCount - 1] == 0)
            {
                --productwordCount;
            }
            if (needShorten)
            {
                productreg = ShortenArray(productreg, productwordCount);
            }
            return new EInteger(
              productwordCount,
              productreg,
              this.negative ^ bigintMult.negative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Negate"]/*'/>
        public EInteger Negate()
        {
            return this.wordCount == 0 ? this : new EInteger(
              this.wordCount,
              this.words,
              !this.negative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Pow(System.Int32)"]/*'/>
        public EInteger Pow(int powerSmall)
        {
            if (powerSmall < 0)
            {
                throw new ArgumentException("powerSmall (" + powerSmall +
                            ") is less than 0");
            }
            EInteger thisVar = this;
            if (powerSmall == 0)
            {
                // however 0 to the power of 0 is undefined
                return EInteger.One;
            }
            if (powerSmall == 1)
            {
                return this;
            }
            if (powerSmall == 2)
            {
                return thisVar * (EInteger)thisVar;
            }
            if (powerSmall == 3)
            {
                return (thisVar * (EInteger)thisVar) * (EInteger)thisVar;
            }
            EInteger r = EInteger.One;
            while (powerSmall != 0)
            {
                if ((powerSmall & 1) != 0)
                {
                    r *= (EInteger)thisVar;
                }
                powerSmall >>= 1;
                if (powerSmall != 0)
                {
                    thisVar *= (EInteger)thisVar;
                }
            }
            return r;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.PowBigIntVar(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger PowBigIntVar(EInteger power)
        {
            if (power == null)
            {
                throw new ArgumentNullException(nameof(power));
            }
            int sign = power.Sign;
            if (sign < 0)
            {
                throw new ArgumentException(
                  "sign (" + sign + ") is less than 0");
            }
            EInteger thisVar = this;
            if (sign == 0)
            {
                return EInteger.One;
            }
            if (power.Equals(EInteger.One))
            {
                return this;
            }
            if (power.wordCount == 1 && power.words[0] == 2)
            {
                return thisVar * (EInteger)thisVar;
            }
            if (power.wordCount == 1 && power.words[0] == 3)
            {
                return (thisVar * (EInteger)thisVar) * (EInteger)thisVar;
            }
            EInteger r = EInteger.One;
            while (!power.IsZero)
            {
                if (!power.IsEven)
                {
                    r *= (EInteger)thisVar;
                }
                power >>= 1;
                if (!power.IsZero)
                {
                    thisVar *= (EInteger)thisVar;
                }
            }
            return r;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Remainder(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger Remainder(EInteger divisor)
        {
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            int words1Size = this.wordCount;
            int words2Size = divisor.wordCount;
            if (words2Size == 0)
            {
                throw new DivideByZeroException();
            }
            if (words1Size < words2Size)
            {
                // dividend is less than divisor
                return this;
            }
            if (words2Size == 1)
            {
                short shortRemainder = FastRemainder(
                  this.words,
                  this.wordCount,
                  divisor.words[0]);
                int smallRemainder = ((int)shortRemainder) & 0xffff;
                if (this.negative)
                {
                    smallRemainder = -smallRemainder;
                }
                return EInteger.FromInt64(smallRemainder);
            }
            if (this.PositiveCompare(divisor) < 0)
            {
                return this;
            }
            short[] remainderReg = new short[((int)words2Size)];
            GeneralDivide(
        this.words,
        0,
        this.wordCount,
        divisor.words,
        0,
        divisor.wordCount,
        null,
        0,
        remainderReg,
        0);
            int count = CountWords(remainderReg);
            if (count == 0)
            {
                return EInteger.Zero;
            }
            remainderReg = ShortenArray(remainderReg, count);
            return new EInteger(count, remainderReg, this.negative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ShiftLeft(System.Int32)"]/*'/>
        public EInteger ShiftLeft(int numberBits)
        {
            if (numberBits == 0 || this.wordCount == 0)
            {
                return this;
            }
            if (numberBits < 0)
            {
                return (numberBits == Int32.MinValue) ?
                  this.ShiftRight(1).ShiftRight(Int32.MaxValue) :
                  this.ShiftRight(-numberBits);
            }
            int numWords = (int)this.wordCount;
            int shiftWords = (int)(numberBits >> 4);
            int shiftBits = (int)(numberBits & 15);
            if (!this.negative)
            {
                short[] ret = new short[(numWords + BitsToWords((int)numberBits))];
                Array.Copy(this.words, 0, ret, shiftWords, numWords);
                ShiftWordsLeftByBits(
                  ret,
                  (int)shiftWords,
                  numWords + BitsToWords(shiftBits),
                  shiftBits);
                return new EInteger(CountWords(ret), ret, false);
            }
            else
            {
                short[] ret = new short[(numWords +
                            BitsToWords((int)numberBits))];
                Array.Copy(this.words, ret, numWords);
                TwosComplement(ret, 0, (int)ret.Length);
                ShiftWordsLeftByWords(ret, 0, numWords + shiftWords, shiftWords);
                ShiftWordsLeftByBits(
                  ret,
                  (int)shiftWords,
                  numWords + BitsToWords(shiftBits),
                  shiftBits);
                TwosComplement(ret, 0, (int)ret.Length);
                return new EInteger(CountWords(ret), ret, true);
            }
        }

        private short[] Copy()
        {
            short[] words = new short[this.words.Length];
            Array.Copy(this.words, words, this.wordCount);
            return words;
        }

        private static int WordsCompare(
           short[] words,
           int wordCount,
           short[] words2,
           int wordCount2)
        {
            return WordsCompare(words, 0, wordCount, words2, 0, wordCount2);
        }

        private static int WordsCompare(
           short[] words,
           int pos1,
           int wordCount,
           short[] words2,
           int pos2,
           int wordCount2)
        {
            // NOTE: Assumes the number is nonnegative
            int size = wordCount;
            if (size == 0)
            {
                return (wordCount2 == 0) ? 0 : -1;
            }
            else if (wordCount2 == 0)
            {
                return 1;
            }
            if (size == wordCount2)
            {
                if (size == 1 && words[pos1] == words2[pos2])
                {
                    return 0;
                }
                else
                {
                    int p1 = pos1 + size - 1;
                    int p2 = pos2 + size - 1;
                    while (unchecked(size--) != 0)
                    {
                        int an = ((int)words[p1]) & 0xffff;
                        int bn = ((int)words2[p2]) & 0xffff;
                        if (an > bn)
                        {
                            return 1;
                        }
                        if (an < bn)
                        {
                            return -1;
                        }
                        --p1;
                        --p2;
                    }
                    return 0;
                }
            }
            return (size > wordCount2) ? 1 : -1;
        }

        private static long WordsToLongUnchecked(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            int c = (int)wordCount;
            if (c == 0)
            {
                return (long)0;
            }
            long ivv = 0;
            int intRetValue = ((int)words[0]) & 0xffff;
            if (c > 1)
            {
                intRetValue |= (((int)words[1]) & 0xffff) << 16;
            }
            if (c > 2)
            {
                int intRetValue2 = ((int)words[2]) & 0xffff;
                if (c > 3)
                {
                    intRetValue2 |= (((int)words[3]) & 0xffff) << 16;
                }
                ivv = ((long)intRetValue) & 0xffffffffL;
                ivv |= ((long)intRetValue2) << 32;
                return ivv;
            }
            ivv = ((long)intRetValue) & 0xffffffffL;
            return ivv;
        }

        private static bool WordsEqual(
           short[] words,
           int wordCount,
           short[] words2,
           int wordCount2)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount == wordCount2)
            {
                for (int i = 0; i < wordCount; ++i)
                {
                    if (words[i] != words2[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        private static bool WordsIsEven(short[] words, int wordCount)
        {
            return wordCount == 0 || (words[0] & 0x01) == 0;
        }

        private static int WordsShiftRightTwo(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                int carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xfffc) >> 2) | carry;
                    carry = (w << 14) & 0xc000;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsShiftRightEight(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                int carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xff00) >> 8) | carry;
                    carry = (w << 8) & 0xff00;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsShiftRightFour(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                int carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xfff0) >> 4) | carry;
                    carry = (w << 12) & 0xf000;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsShiftRightOne(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                int carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xfffe) >> 1) | carry;
                    carry = (w << 15) & 0x8000;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsSubtract(
      short[] words,
      int wordCount,
      short[] subtrahendWords,
      int subtrahendCount)
        {
            // NOTE: Assumes this value is at least as high as the subtrahend
            // and both numbers are nonnegative
            short borrow = (short)SubtractInternal(
                 words,
                 0,
                 words,
                 0,
                 subtrahendWords,
                 0,
                 subtrahendCount);
            if (borrow != 0)
            {
                Decrement(
         words,
         subtrahendCount,
         (int)(wordCount - subtrahendCount),
         borrow);
            }
            while (wordCount != 0 && words[wordCount - 1] == 0)
            {
                --wordCount;
            }
            return wordCount;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ShiftRight(System.Int32)"]/*'/>
        public EInteger ShiftRight(int numberBits)
        {
            if (numberBits == 0 || this.wordCount == 0)
            {
                return this;
            }
            if (numberBits < 0)
            {
                return (numberBits == Int32.MinValue) ?
                  this.ShiftLeft(1).ShiftLeft(Int32.MaxValue) :
                  this.ShiftLeft(-numberBits);
            }
            int numWords = (int)this.wordCount;
            int shiftWords = (int)(numberBits >> 4);
            int shiftBits = (int)(numberBits & 15);
            short[] ret;
            int retWordCount;
            if (this.negative)
            {
                ret = new short[this.words.Length];
                Array.Copy(this.words, ret, numWords);
                TwosComplement(ret, 0, (int)ret.Length);
                ShiftWordsRightByWordsSignExtend(ret, 0, numWords, shiftWords);
                if (numWords > shiftWords)
                {
                    ShiftWordsRightByBitsSignExtend(
                      ret,
                      0,
                      numWords - shiftWords,
                      shiftBits);
                }
                TwosComplement(ret, 0, (int)ret.Length);
                retWordCount = ret.Length;
            }
            else
            {
                if (shiftWords >= numWords)
                {
                    return EInteger.Zero;
                }
                ret = new short[this.words.Length];
                Array.Copy(this.words, shiftWords, ret, 0, numWords - shiftWords);
                if (shiftBits != 0)
                {
                    ShiftWordsRightByBits(ret, 0, numWords - shiftWords, shiftBits);
                }
                retWordCount = numWords - shiftWords;
            }
            while (retWordCount != 0 &&
                   ret[retWordCount - 1] == 0)
            {
                --retWordCount;
            }
            if (retWordCount == 0)
            {
                return EInteger.Zero;
            }
            if (shiftWords > 2)
            {
                ret = ShortenArray(ret, retWordCount);
            }
            return new EInteger(retWordCount, ret, this.negative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Sqrt"]/*'/>
        public EInteger Sqrt()
        {
            EInteger[] srrem = this.SqrtRemInternal(false);
            return srrem[0];
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.SqrtRem"]/*'/>
        public EInteger[] SqrtRem()
        {
            return this.SqrtRemInternal(true);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Subtract(PeterO.Numbers.EInteger)"]/*'/>
        public EInteger Subtract(EInteger subtrahend)
        {
            if (subtrahend == null)
            {
                throw new ArgumentNullException(nameof(subtrahend));
            }
            return (this.wordCount == 0) ? subtrahend.Negate() :
              ((subtrahend.wordCount == 0) ? this : this.Add(subtrahend.Negate()));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToBytes(System.Boolean)"]/*'/>
        public byte[] ToBytes(bool littleEndian)
        {
            int sign = this.Sign;
            if (sign == 0)
            {
                return new[] { (byte)0 };
            }
            if (sign > 0)
            {
                int byteCount = this.ByteCount();
                int byteArrayLength = byteCount;
                if (this.GetUnsignedBit((byteCount * 8) - 1))
                {
                    ++byteArrayLength;
                }
                byte[] bytes = new byte[byteArrayLength];
                int j = 0;
                for (int i = 0; i < byteCount; i += 2, j++)
                {
                    int index = littleEndian ? i : bytes.Length - 1 - i;
                    int index2 = littleEndian ? i + 1 : bytes.Length - 2 - i;
                    bytes[index] = (byte)(this.words[j] & 0xff);
                    if (index2 >= 0 && index2 < byteArrayLength)
                    {
                        bytes[index2] = (byte)((this.words[j] >> 8) & 0xff);
                    }
                }
                return bytes;
            }
            else
            {
                short[] regdata = new short[this.words.Length];
                Array.Copy(this.words, regdata, this.words.Length);
                TwosComplement(regdata, 0, (int)regdata.Length);
                int byteCount = regdata.Length * 2;
                for (int i = regdata.Length - 1; i >= 0; --i)
                {
                    if (regdata[i] == unchecked((short)0xffff))
                    {
                        byteCount -= 2;
                    }
                    else if ((regdata[i] & 0xff80) == 0xff80)
                    {
                        // signed first byte, 0xff second
                        --byteCount;
                        break;
                    }
                    else if ((regdata[i] & 0x8000) == 0x8000)
                    {
                        // signed second byte
                        break;
                    }
                    else
                    {
                        // unsigned second byte
                        ++byteCount;
                        break;
                    }
                }
                if (byteCount == 0)
                {
                    byteCount = 1;
                }
                byte[] bytes = new byte[byteCount];
                bytes[littleEndian ? bytes.Length - 1 : 0] = (byte)0xff;
                byteCount = Math.Min(byteCount, regdata.Length * 2);
                int j = 0;
                for (int i = 0; i < byteCount; i += 2, j++)
                {
                    int index = littleEndian ? i : bytes.Length - 1 - i;
                    int index2 = littleEndian ? i + 1 : bytes.Length - 2 - i;
                    bytes[index] = (byte)(regdata[j] & 0xff);
                    if (index2 >= 0 && index2 < byteCount)
                    {
                        bytes[index2] = (byte)((regdata[j] >> 8) & 0xff);
                    }
                }
                return bytes;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToInt32Checked"]/*'/>
        public int ToInt32Checked()
        {
            int count = this.wordCount;
            if (count == 0)
            {
                return 0;
            }
            if (count > 2)
            {
                throw new OverflowException();
            }
            if (count == 2 && (this.words[1] & 0x8000) != 0)
            {
                if (this.negative && this.words[1] == unchecked((short)0x8000) &&
                    this.words[0] == 0)
                {
                    return Int32.MinValue;
                }
                throw new OverflowException();
            }
            return this.ToInt32Unchecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToInt32Unchecked"]/*'/>
        public int ToInt32Unchecked()
        {
            int c = (int)this.wordCount;
            if (c == 0)
            {
                return 0;
            }
            int intRetValue = ((int)this.words[0]) & 0xffff;
            if (c > 1)
            {
                intRetValue |= (((int)this.words[1]) & 0xffff) << 16;
            }
            if (this.negative)
            {
                intRetValue = unchecked(intRetValue - 1);
                intRetValue = unchecked(~intRetValue);
            }
            return intRetValue;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToInt64Checked"]/*'/>
        public long ToInt64Checked()
        {
            int count = this.wordCount;
            if (count == 0)
            {
                return (long)0;
            }
            if (count > 4)
            {
                throw new OverflowException();
            }
            if (count == 4 && (this.words[3] & 0x8000) != 0)
            {
                if (this.negative && this.words[3] == unchecked((short)0x8000) &&
                    this.words[2] == 0 && this.words[1] == 0 &&
                    this.words[0] == 0)
                {
                    return Int64.MinValue;
                }
                throw new OverflowException();
            }
            return this.ToInt64Unchecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToInt64Unchecked"]/*'/>
        public long ToInt64Unchecked()
        {
            int c = (int)this.wordCount;
            if (c == 0)
            {
                return (long)0;
            }
            long ivv = 0;
            int intRetValue = ((int)this.words[0]) & 0xffff;
            if (c > 1)
            {
                intRetValue |= (((int)this.words[1]) & 0xffff) << 16;
            }
            if (c > 2)
            {
                int intRetValue2 = ((int)this.words[2]) & 0xffff;
                if (c > 3)
                {
                    intRetValue2 |= (((int)this.words[3]) & 0xffff) << 16;
                }
                if (this.negative)
                {
                    if (intRetValue == 0)
                    {
                        intRetValue = unchecked(intRetValue - 1);
                        intRetValue2 = unchecked(intRetValue2 - 1);
                    }
                    else
                    {
                        intRetValue = unchecked(intRetValue - 1);
                    }
                    intRetValue = unchecked(~intRetValue);
                    intRetValue2 = unchecked(~intRetValue2);
                }
                ivv = ((long)intRetValue) & 0xffffffffL;
                ivv |= ((long)intRetValue2) << 32;
                return ivv;
            }
            ivv = ((long)intRetValue) & 0xffffffffL;
            if (this.negative)
            {
                ivv = -ivv;
            }
            return ivv;
        }

        private void ToRadixStringDecimal(
      StringBuilder outputSB,
      bool optimize)
        {
#if DEBUG
            if (!(!this.negative))
            {
                throw new ArgumentException("doesn't satisfy !this.negative");
            }
#endif

            int i = 0;
            if (this.wordCount >= 100 && optimize)
            {
                StringBuilder rightBuilder = new StringBuilder();
                int digits = this.wordCount * 3;
                EInteger pow = NumberUtility.FindPowerOfTen(digits);
                // DebugUtility.Log("---divrem " + (this.wordCount));
                EInteger[] divrem = this.DivRem(pow);
                // DebugUtility.Log("" + (divrem[0].GetUnsignedBitLength()) + "," +
                // (// divrem[1].GetUnsignedBitLength()));
                divrem[0].ToRadixStringDecimal(outputSB, optimize);
                divrem[1].ToRadixStringDecimal(rightBuilder, optimize);
                for (i = rightBuilder.Length; i < digits; ++i)
                {
                    outputSB.Append('0');
                }
                outputSB.Append(rightBuilder.ToString());
                return;
            }
            if (this.HasSmallValue())
            {
                outputSB.Append(this.SmallValueToString());
                return;
            }
            short[] tempReg = new short[this.wordCount];
            Array.Copy(this.words, tempReg, tempReg.Length);
            int numWordCount = tempReg.Length;
            while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
            {
                --numWordCount;
            }
            char[] s = new char[(numWordCount << 4) + 1];
            while (numWordCount != 0)
            {
                if (numWordCount == 1 && tempReg[0] > 0 && tempReg[0] <= 0x7fff)
                {
                    int rest = tempReg[0];
                    while (rest != 0)
                    {
                        // accurate approximation to rest/10 up to 43698,
                        // and rest can go up to 32767
                        int newrest = (rest * 26215) >> 18;
                        s[i++] = Digits[rest - (newrest * 10)];
                        rest = newrest;
                    }
                    break;
                }
                if (numWordCount == 2 && tempReg[1] > 0 && tempReg[1] <= 0x7fff)
                {
                    int rest = ((int)tempReg[0]) & 0xffff;
                    rest |= (((int)tempReg[1]) & 0xffff) << 16;
                    while (rest != 0)
                    {
                        int newrest = (rest < 43698) ? ((rest * 26215) >> 18) : (rest /
                            10);
                        s[i++] = Digits[rest - (newrest * 10)];
                        rest = newrest;
                    }
                    break;
                }
                else
                {
                    int wci = numWordCount;
                    short remainderShort = 0;
                    int quo, rem;
                    // Divide by 10000
                    while ((wci--) > 0)
                    {
                        int currentDividend = unchecked((int)((((int)tempReg[wci]) &
                              0xffff) | ((int)remainderShort << 16)));
                        quo = currentDividend / 10000;
                        tempReg[wci] = unchecked((short)quo);
                        rem = currentDividend - (10000 * quo);
                        remainderShort = unchecked((short)rem);
                    }
                    int remainderSmall = remainderShort;
                    // Recalculate word count
                    while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
                    {
                        --numWordCount;
                    }
                    // accurate approximation to rest/10 up to 16388,
                    // and rest can go up to 9999
                    int newrest = (remainderSmall * 3277) >> 15;
                    s[i++] = Digits[(int)(remainderSmall - (newrest * 10))];
                    remainderSmall = newrest;
                    newrest = (remainderSmall * 3277) >> 15;
                    s[i++] = Digits[(int)(remainderSmall - (newrest * 10))];
                    remainderSmall = newrest;
                    newrest = (remainderSmall * 3277) >> 15;
                    s[i++] = Digits[(int)(remainderSmall - (newrest * 10))];
                    remainderSmall = newrest;
                    s[i++] = Digits[remainderSmall];
                }
            }
            ReverseChars(s, 0, i);
            outputSB.Append(s, 0, i);
        }

        private string ToUnoptString()
        {
            if (this.HasSmallValue())
            {
                return this.SmallValueToString();
            }
            StringBuilder sb = new StringBuilder();
            if (this.negative)
            {
                sb.Append('-');
            }
            this.Abs().ToRadixStringDecimal(sb, false);
            return sb.ToString();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToRadixString(System.Int32)"]/*'/>
        public string ToRadixString(int radix)
        {
            if (radix < 2)
            {
                throw new ArgumentException("radix (" + radix +
                            ") is less than 2");
            }
            if (radix > 36)
            {
                throw new ArgumentException("radix (" + radix +
                            ") is more than 36");
            }
            if (this.wordCount == 0)
            {
                return "0";
            }
            if (radix == 10)
            {
                // Decimal
                if (this.HasSmallValue())
                {
                    return this.SmallValueToString();
                }
                StringBuilder sb = new StringBuilder();
                if (this.negative)
                {
                    sb.Append('-');
                }
                this.Abs().ToRadixStringDecimal(sb, true);
                return sb.ToString();
            }
            if (radix == 16)
            {
                // Hex
                StringBuilder sb = new System.Text.StringBuilder();
                if (this.negative)
                {
                    sb.Append('-');
                }
                bool firstBit = true;
                int word = this.words[this.wordCount - 1];
                for (int i = 0; i < 4; ++i)
                {
                    if (!firstBit || (word & 0xf000) != 0)
                    {
                        sb.Append(Digits[(word >> 12) & 0x0f]);
                        firstBit = false;
                    }
                    word <<= 4;
                }
                for (int j = this.wordCount - 2; j >= 0; --j)
                {
                    word = this.words[j];
                    for (int i = 0; i < 4; ++i)
                    {
                        sb.Append(Digits[(word >> 12) & 0x0f]);
                        word <<= 4;
                    }
                }
                return sb.ToString();
            }
            if (radix == 2)
            {
                // Binary
                StringBuilder sb = new System.Text.StringBuilder();
                if (this.negative)
                {
                    sb.Append('-');
                }
                bool firstBit = true;
                int word = this.words[this.wordCount - 1];
                for (int i = 0; i < 16; ++i)
                {
                    if (!firstBit || (word & 0x8000) != 0)
                    {
                        sb.Append((word & 0x8000) == 0 ? '0' : '1');
                        firstBit = false;
                    }
                    word <<= 1;
                }
                for (int j = this.wordCount - 2; j >= 0; --j)
                {
                    word = this.words[j];
                    for (int i = 0; i < 16; ++i)
                    {
                        sb.Append((word & 0x8000) == 0 ? '0' : '1');
                        word <<= 1;
                    }
                }
                return sb.ToString();
            }
            else
            {
                // Other radixes
                short[] tempReg = new short[this.wordCount];
                Array.Copy(this.words, tempReg, tempReg.Length);
                int numWordCount = tempReg.Length;
                while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
                {
                    --numWordCount;
                }
                int i = 0;
                char[] s = new char[(numWordCount << 4) + 1];
                while (numWordCount != 0)
                {
                    if (numWordCount == 1 && tempReg[0] > 0 && tempReg[0] <= 0x7fff)
                    {
                        int rest = tempReg[0];
                        while (rest != 0)
                        {
                            int newrest = rest / radix;
                            s[i++] = Digits[rest - (newrest * radix)];
                            rest = newrest;
                        }
                        break;
                    }
                    if (numWordCount == 2 && tempReg[1] > 0 && tempReg[1] <= 0x7fff)
                    {
                        int rest = ((int)tempReg[0]) & 0xffff;
                        rest |= (((int)tempReg[1]) & 0xffff) << 16;
                        while (rest != 0)
                        {
                            int newrest = rest / radix;
                            s[i++] = Digits[rest - (newrest * radix)];
                            rest = newrest;
                        }
                        break;
                    }
                    else
                    {
                        int wci = numWordCount;
                        short remainderShort = 0;
                        int quo, rem;
                        // Divide by radix
                        while ((wci--) > 0)
                        {
                            int currentDividend = unchecked((int)((((int)tempReg[wci]) &
                                  0xffff) | ((int)remainderShort << 16)));
                            quo = currentDividend / radix;
                            tempReg[wci] = unchecked((short)quo);
                            rem = currentDividend - (radix * quo);
                            remainderShort = unchecked((short)rem);
                        }
                        int remainderSmall = remainderShort;
                        // Recalculate word count
                        while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
                        {
                            --numWordCount;
                        }
                        s[i++] = Digits[remainderSmall];
                    }
                }
                ReverseChars(s, 0, i);
                if (this.negative)
                {
                    StringBuilder sb = new System.Text.StringBuilder(i + 1);
                    sb.Append('-');
                    for (int j = 0; j < i; ++j)
                    {
                        sb.Append(s[j]);
                    }
                    return sb.ToString();
                }
                return new String(s, 0, i);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToString"]/*'/>
        public override string ToString()
        {
            if (this.IsZero)
            {
                return "0";
            }
            return this.HasSmallValue() ? this.SmallValueToString() :
              this.ToRadixString(10);
        }

        private static int AddInternal(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int n)
        {
            unchecked
            {
                int u;
                u = 0;
                bool evn = (n & 1) == 0;
                int valueNEven = evn ? n : n - 1;
                int i = 0;
                while (i < valueNEven)
                {
                    u = (((int)words1[astart + i]) & 0xffff) +
                      (((int)words2[bstart + i]) & 0xffff) + (short)(u >> 16);
                    c[cstart + i] = (short)u;
                    ++i;
                    u = (((int)words1[astart + i]) & 0xffff) +
                      (((int)words2[bstart + i]) & 0xffff) + (short)(u >> 16);
                    c[cstart + i] = (short)u;
                    ++i;
                }
                if (!evn)
                {
                    u = (((int)words1[astart + valueNEven]) & 0xffff) +
                      (((int)words2[bstart + valueNEven]) & 0xffff) + (short)(u >> 16);
                    c[cstart + valueNEven] = (short)u;
                }
                return ((int)u >> 16) & 0xffff;
            }
        }

        private static int AddUnevenSize(
          short[] c,
          int cstart,
          short[] wordsBigger,
          int astart,
          int acount,
          short[] wordsSmaller,
          int bstart,
          int bcount)
        {
#if DEBUG
            if (acount < bcount)
            {
                throw new ArgumentException("acount (" + acount + ") is less than " +
                            bcount);
            }
#endif
            unchecked
            {
                int u;
                u = 0;
                for (int i = 0; i < bcount; i += 1)
                {
                    u = (((int)wordsBigger[astart + i]) & 0xffff) +
                      (((int)wordsSmaller[bstart + i]) & 0xffff) + (short)(u >> 16);
                    c[cstart + i] = (short)u;
                }
                for (int i = bcount; i < acount; i += 1)
                {
                    u = (((int)wordsBigger[astart + i]) & 0xffff) + (short)(u >> 16);
                    c[cstart + i] = (short)u;
                }
                return ((int)u >> 16) & 0xffff;
            }
        }

        private static int ApproxLogTenOfTwo(int bitlen)
        {
            int bitlenLow = bitlen & 0xffff;
            int bitlenHigh = (bitlen >> 16) & 0xffff;
            short resultLow = 0;
            short resultHigh = 0;
            unchecked
            {
                int p; short c; int d;
                p = bitlenLow * 0x84fb; d = ((int)p >> 16) & 0xffff; c = (short)d; d
                  = ((int)d >> 16) & 0xffff;
                p = bitlenLow * 0x209a;
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = bitlenHigh * 0x84fb;
                p += ((int)c) & 0xffff;
                d += ((int)p >> 16) & 0xffff; c = (short)d; d = ((int)d >> 16) & 0xffff;
                p = bitlenLow * 0x9a;
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = bitlenHigh * 0x209a;
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = ((int)c) & 0xffff; c = (short)p; resultLow = c; c = (short)d; d
                  = ((int)d >> 16) & 0xffff;
                p = bitlenHigh * 0x9a;
                p += ((int)c) & 0xffff;
                resultHigh = (short)p;
                int result = ((int)resultLow) & 0xffff;
                result |= (((int)resultHigh) & 0xffff) << 16;
                return (result & 0x7fffffff) >> 9;
            }
        }

        // Multiplies two operands of different sizes
        private static void AsymmetricMultiply(
          short[] resultArr,
          int resultStart,  // uses words1Count + words2Count
          short[] tempArr,
          int tempStart,  // uses words1Count + words2Count
          short[] words1,
          int words1Start,
          int words1Count,
          short[] words2,
          int words2Start,
          int words2Count)
        {
            // DebugUtility.Log("AsymmetricMultiply " + words1Count + " " +
            // words2Count + " [r=" + resultStart + " t=" + tempStart + " a=" +
            // words1Start + " b=" + words2Start + "]");
#if DEBUG
            if (resultArr == null)
            {
                throw new ArgumentNullException(nameof(resultArr));
            }

            if (resultStart < 0)
            {
                throw new ArgumentException("resultStart (" + resultStart +
                            ") is less than 0");
            }

            if (resultStart > resultArr.Length)
            {
                throw new ArgumentException("resultStart (" + resultStart +
                            ") is more than " + resultArr.Length);
            }

            if (words1Count + words2Count < 0)
            {
                throw new ArgumentException("words1Count plus words2Count (" +
                            (words1Count + words2Count) + ") is less than " +
                            "0");
            }

            if (words1Count + words2Count > resultArr.Length)
            {
                throw new ArgumentException("words1Count plus words2Count (" +
                            (words1Count + words2Count) +
                            ") is more than " + resultArr.Length);
            }

            if (resultArr.Length - resultStart < words1Count + words2Count)
            {
                throw new ArgumentException("resultArr.Length minus resultStart (" +
                            (resultArr.Length - resultStart) +
                            ") is less than " + (words1Count +
                            words2Count));
            }

            if (tempArr == null)
            {
                throw new ArgumentNullException(nameof(tempArr));
            }

            if (tempStart < 0)
            {
                throw new ArgumentException("tempStart (" + tempStart +
                            ") is less than 0");
            }

            if (tempStart > tempArr.Length)
            {
                throw new ArgumentException("tempStart (" + tempStart +
                            ") is more than " + tempArr.Length);
            }

            if (words1Count + words2Count < 0)
            {
                throw new ArgumentException("words1Count plus words2Count (" +
                            (words1Count + words2Count) + ") is less than " +
                            "0");
            }

            if (words1Count + words2Count > tempArr.Length)
            {
                throw new ArgumentException("words1Count plus words2Count (" +
                            (words1Count + words2Count) +
                            ") is more than " + tempArr.Length);
            }

            if (tempArr.Length - tempStart < words1Count + words2Count)
            {
                throw new ArgumentException("tempArr.Length minus tempStart (" +
                            (tempArr.Length - tempStart) +
                            ") is less than " + (words1Count +
                            words2Count));
            }

            if (words1 == null)
            {
                throw new ArgumentNullException(nameof(words1));
            }

            if (words1Start < 0)
            {
                throw new ArgumentException("words1Start (" + words1Start +
                            ") is less than 0");
            }

            if (words1Start > words1.Length)
            {
                throw new ArgumentException("words1Start (" + words1Start +
                            ") is more than " + words1.Length);
            }

            if (words1Count < 0)
            {
                throw new ArgumentException("words1Count (" + words1Count +
                            ") is less than 0");
            }

            if (words1Count > words1.Length)
            {
                throw new ArgumentException("words1Count (" + words1Count +
                            ") is more than " + words1.Length);
            }

            if (words1.Length - words1Start < words1Count)
            {
                throw new ArgumentException("words1.Length minus words1Start (" +
                            (words1.Length - words1Start) +
                            ") is less than " + words1Count);
            }

            if (words2 == null)
            {
                throw new ArgumentNullException(nameof(words2));
            }

            if (words2Start < 0)
            {
                throw new ArgumentException("words2Start (" + words2Start +
                            ") is less than 0");
            }

            if (words2Start > words2.Length)
            {
                throw new ArgumentException("words2Start (" + words2Start +
                            ") is more than " + words2.Length);
            }

            if (words2Count < 0)
            {
                throw new ArgumentException("words2Count (" + words2Count +
                            ") is less than 0");
            }

            if (words2Count > words2.Length)
            {
                throw new ArgumentException("words2Count (" + words2Count +
                            ") is more than " + words2.Length);
            }

            if (words2.Length - words2Start < words2Count)
            {
                throw new ArgumentException("words2.Length minus words2Start (" +
                            (words2.Length - words2Start) +
                            ") is less than " + words2Count);
            }
#endif

            if (words1Count == words2Count)
            {
                if (words1Start == words2Start && words1 == words2)
                {
                    // Both operands have the same value and the same word count
                    RecursiveSquare(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words1Count);
                }
                else if (words1Count == 2)
                {
                    // Both operands have a word count of 2
                    BaselineMultiply2(
                      resultArr,
                      resultStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start);
                }
                else
                {
                    // Other cases where both operands have the same word count
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      words1Count);
                }
                return;
            }
            if (words1Count > words2Count)
            {
                // Ensure that words1 is smaller by swapping if necessary
                short[] tmp1 = words1;
                words1 = words2;
                words2 = tmp1;
                int tmp3 = words1Start;
                words1Start = words2Start;
                words2Start = tmp3;
                int tmp2 = words1Count;
                words1Count = words2Count;
                words2Count = tmp2;
            }

            if (words1Count == 1 || (words1Count == 2 && words1[words1Start + 1] ==
                          0))
            {
                switch (words1[words1Start])
                {
                    case 0:
                        // words1 is ValueZero, so result is 0
                        Array.Clear((short[])resultArr, resultStart, words2Count + 2);
                        return;
                    case 1:
                        Array.Copy(
                          words2,
                          words2Start,
                          resultArr,
                          resultStart,
                          (int)words2Count);
                        resultArr[resultStart + words2Count] = (short)0;
                        resultArr[resultStart + words2Count + 1] = (short)0;
                        return;
                    default:
                        resultArr[resultStart + words2Count] = LinearMultiply(
                          resultArr,
                          resultStart,
                          words2,
                          words2Start,
                          words1[words1Start],
                          words2Count);
                        resultArr[resultStart + words2Count + 1] = (short)0;
                        return;
                }
            }
            if (words1Count == 2 && (words2Count & 1) == 0)
            {
                int a0 = ((int)words1[words1Start]) & 0xffff;
                int a1 = ((int)words1[words1Start + 1]) & 0xffff;
                resultArr[resultStart + words2Count] = (short)0;
                resultArr[resultStart + words2Count + 1] = (short)0;
                AtomicMultiplyOpt(
                  resultArr,
                  resultStart,
                  a0,
                  a1,
                  words2,
                  words2Start,
                  0,
                  words2Count);
                AtomicMultiplyAddOpt(
                  resultArr,
                  resultStart,
                  a0,
                  a1,
                  words2,
                  words2Start,
                  2,
                  words2Count);
                return;
            }
            if (words1Count <= 10 && words2Count <= 10)
            {
                SchoolbookMultiply(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  words1Count,
                  words2,
                  words2Start,
                  words2Count);
            }
            else
            {
                int wordsRem = words2Count % words1Count;
                int evenmult = (words2Count / words1Count) & 1;
                int i;
                // DebugUtility.Log("counts=" + words1Count + "," + words2Count +
                // " res=" + (resultStart + words1Count) + " temp=" + (tempStart +
                // (words1Count << 1)) + " rem=" + wordsRem + " evenwc=" + evenmult);
                if (wordsRem == 0)
                {
                    // words2Count is divisible by words1count
                    if (evenmult == 0)
                    {
                        SameSizeMultiply(
                          resultArr,
                          resultStart,
                          tempArr,
                          tempStart,
                          words1,
                          words1Start,
                          words2,
                          words2Start,
                          words1Count);
                        Array.Copy(
                          resultArr,
                          resultStart + words1Count,
                          tempArr,
                          (int)(tempStart + (words1Count << 1)),
                          words1Count);
                        for (i = words1Count << 1; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              tempArr,
                              tempStart + words1Count + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                        for (i = words1Count; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              resultArr,
                              resultStart + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                    }
                    else
                    {
                        for (i = 0; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              resultArr,
                              resultStart + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                        for (i = words1Count; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              tempArr,
                              tempStart + words1Count + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                    }
                    if (
                      AddInternal(
                        resultArr,
                        resultStart + words1Count,
                        resultArr,
                        resultStart + words1Count,
                        tempArr,
                        tempStart + (words1Count << 1),
                        words2Count - words1Count) != 0)
                    {
                        Increment(
                          resultArr,
                          (int)(resultStart + words2Count),
                          words1Count,
                          (short)1);
                    }
                }
                else if ((words1Count + words2Count) >= (words1Count << 2))
                {
                    // DebugUtility.Log("Chunked Linear Multiply long");
                    ChunkedLinearMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words2,
                      words2Start,
                      words2Count,
                      words1,
                      words1Start,
                      words1Count);
                }
                else if (words1Count + 1 == words2Count ||
                         (words1Count + 2 == words2Count && words2[words2Start +
                          words2Count - 1] == 0))
                {
                    Array.Clear(
                      (short[])resultArr,
                      resultStart,
                      words1Count + words2Count);
                    // Multiply the low parts of each operand
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      words1Count);
                    // Multiply the high parts
                    // while adding carry from the high part of the product
                    short carry = LinearMultiplyAdd(
                      resultArr,
                      resultStart + words1Count,
                      words1,
                      words1Start,
                      words2[words2Start + words1Count],
                      words1Count);
                    resultArr[resultStart + words1Count + words1Count] = carry;
                }
                else
                {
                    short[] t2 = new short[words1Count << 2];
                    // DebugUtility.Log("Chunked Linear Multiply Short");
                    ChunkedLinearMultiply(
                      resultArr,
                      resultStart,
                      t2,
                      0,
                      words2,
                      words2Start,
                      words2Count,
                      words1,
                      words1Start,
                      words1Count);
                }
            }
        }

        private static void AtomicMultiplyAddOpt(
          short[] c,
          int valueCstart,
          int valueA0,
          int valueA1,
          short[] words2,
          int words2Start,
          int istart,
          int iend)
        {
            short s;
            int d;
            int first1MinusFirst0 = ((int)valueA1 - valueA0) & 0xffff;
            valueA1 &= 0xffff;
            valueA0 &= 0xffff;
            unchecked
            {
                if (valueA1 >= valueA0)
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int b0 = ((int)words2[words2Start + i]) & 0xffff;
                        int b1 = ((int)words2[words2Start + i + 1]) & 0xffff;
                        int csi = valueCstart + i;
                        if (b0 >= b1)
                        {
                            s = (short)0;
                            d = first1MinusFirst0 * (((int)b0 - b1) & 0xffff);
                        }
                        else
                        {
                            s = (short)first1MinusFirst0;
                            d = (((int)s) & 0xffff) * (((int)b0 - b1) & 0xffff);
                        }
                        int valueA0B0 = valueA0 * b0;
                        int a0b0high = (valueA0B0 >> 16) & 0xffff;
                        int tempInt;
                        tempInt = valueA0B0 + (((int)c[csi]) & 0xffff);
                        c[csi] = (short)(((int)tempInt) & 0xffff);

                        int valueA1B1 = valueA1 * b1;
                        int a1b1low = valueA1B1 & 0xffff;
                        int a1b1high = ((int)(valueA1B1 >> 16)) & 0xffff;
                        tempInt = (((int)(tempInt >> 16)) & 0xffff) + (((int)valueA0B0) &
                                0xffff) + (((int)d) & 0xffff) + a1b1low +
                          (((int)c[csi + 1]) & 0xffff);
                        c[csi + 1] = (short)(((int)tempInt) & 0xffff);

                        tempInt = (((int)(tempInt >> 16)) & 0xffff) + a1b1low + a0b0high +
                          (((int)(d >> 16)) & 0xffff) +
                          a1b1high - (((int)s) & 0xffff) + (((int)c[csi + 2]) & 0xffff);
                        c[csi + 2] = (short)(((int)tempInt) & 0xffff);

                        tempInt = (((int)(tempInt >> 16)) & 0xffff) + a1b1high +
                          (((int)c[csi + 3]) & 0xffff);
                        c[csi + 3] = (short)(((int)tempInt) & 0xffff);
                        if ((tempInt >> 16) != 0)
                        {
                            ++c[csi + 4];
                            c[csi + 5] += (short)((c[csi + 4] == 0) ? 1 : 0);
                        }
                    }
                }
                else
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int valueB0 = ((int)words2[words2Start + i]) & 0xffff;
                        int valueB1 = ((int)words2[words2Start + i + 1]) & 0xffff;
                        int csi = valueCstart + i;
                        if (valueB0 > valueB1)
                        {
                            s = (short)(((int)valueB0 - valueB1) & 0xffff);
                            d = first1MinusFirst0 * (((int)s) & 0xffff);
                        }
                        else
                        {
                            s = (short)0;
                            d = (((int)valueA0 - valueA1) & 0xffff) * (((int)valueB1 -
                                  valueB0) & 0xffff);
                        }
                        int valueA0B0 = valueA0 * valueB0;
                        int a0b0high = (valueA0B0 >> 16) & 0xffff;
                        int tempInt;
                        tempInt = valueA0B0 + (((int)c[csi]) & 0xffff);
                        c[csi] = (short)(((int)tempInt) & 0xffff);

                        int valueA1B1 = valueA1 * valueB1;
                        int a1b1low = valueA1B1 & 0xffff;
                        int a1b1high = (valueA1B1 >> 16) & 0xffff;
                        tempInt = (((int)(tempInt >> 16)) & 0xffff) + (((int)valueA0B0) &
                                0xffff) + (((int)d) & 0xffff) + a1b1low +
                          (((int)c[csi + 1]) & 0xffff);
                        c[csi + 1] = (short)(((int)tempInt) & 0xffff);

                        tempInt = (((int)(tempInt >> 16)) & 0xffff) + a1b1low + a0b0high +
                          (((int)(d >> 16)) & 0xffff) +
                          a1b1high - (((int)s) & 0xffff) + (((int)c[csi + 2]) & 0xffff);
                        c[csi + 2] = (short)(((int)tempInt) & 0xffff);

                        tempInt = (((int)(tempInt >> 16)) & 0xffff) + a1b1high +
                          (((int)c[csi + 3]) & 0xffff);
                        c[csi + 3] = (short)(((int)tempInt) & 0xffff);
                        if ((tempInt >> 16) != 0)
                        {
                            ++c[csi + 4];
                            c[csi + 5] += (short)((c[csi + 4] == 0) ? 1 : 0);
                        }
                    }
                }
            }
        }

        private static void AtomicMultiplyOpt(
          short[] c,
          int valueCstart,
          int valueA0,
          int valueA1,
          short[] words2,
          int words2Start,
          int istart,
          int iend)
        {
            short s;
            int d;
            int first1MinusFirst0 = ((int)valueA1 - valueA0) & 0xffff;
            valueA1 &= 0xffff;
            valueA0 &= 0xffff;
            unchecked
            {
                if (valueA1 >= valueA0)
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int valueB0 = ((int)words2[words2Start + i]) & 0xffff;
                        int valueB1 = ((int)words2[words2Start + i + 1]) & 0xffff;
                        int csi = valueCstart + i;
                        if (valueB0 >= valueB1)
                        {
                            s = (short)0;
                            d = first1MinusFirst0 * (((int)valueB0 - valueB1) & 0xffff);
                        }
                        else
                        {
                            s = (short)first1MinusFirst0;
                            d = (((int)s) & 0xffff) * (((int)valueB0 - valueB1) & 0xffff);
                        }
                        int valueA0B0 = valueA0 * valueB0;
                        c[csi] = (short)(((int)valueA0B0) & 0xffff);
                        int a0b0high = (valueA0B0 >> 16) & 0xffff;
                        int valueA1B1 = valueA1 * valueB1;
                        int tempInt;
                        tempInt = a0b0high + (((int)valueA0B0) & 0xffff) + (((int)d) &
                                0xffff) + (((int)valueA1B1) & 0xffff);
                        c[csi + 1] = (short)tempInt;
                        tempInt = valueA1B1 + (((int)(tempInt >> 16)) & 0xffff) +
                          a0b0high + (((int)(d >> 16)) & 0xffff) + (((int)(valueA1B1 >>
                                16)) & 0xffff) - (((int)s) & 0xffff);
                        c[csi + 2] = (short)tempInt;
                        tempInt >>= 16;
                        c[csi + 3] = (short)tempInt;
                    }
                }
                else
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int valueB0 = ((int)words2[words2Start + i]) & 0xffff;
                        int valueB1 = ((int)words2[words2Start + i + 1]) & 0xffff;
                        int csi = valueCstart + i;
                        if (valueB0 > valueB1)
                        {
                            s = (short)(((int)valueB0 - valueB1) & 0xffff);
                            d = first1MinusFirst0 * (((int)s) & 0xffff);
                        }
                        else
                        {
                            s = (short)0;
                            d = (((int)valueA0 - valueA1) & 0xffff) * (((int)valueB1 -
                                  valueB0) & 0xffff);
                        }
                        int valueA0B0 = valueA0 * valueB0;
                        int a0b0high = (valueA0B0 >> 16) & 0xffff;
                        c[csi] = (short)(((int)valueA0B0) & 0xffff);

                        int valueA1B1 = valueA1 * valueB1;
                        int tempInt;
                        tempInt = a0b0high + (((int)valueA0B0) & 0xffff) + (((int)d) &
                                0xffff) + (((int)valueA1B1) & 0xffff);
                        c[csi + 1] = (short)tempInt;

                        tempInt = valueA1B1 + (((int)(tempInt >> 16)) & 0xffff) +
                          a0b0high + (((int)(d >> 16)) & 0xffff) + (((int)(valueA1B1 >>
                                16)) & 0xffff) - (((int)s) & 0xffff);

                        c[csi + 2] = (short)tempInt;
                        tempInt >>= 16;
                        c[csi + 3] = (short)tempInt;
                    }
                }
            }
        }
        //---------------------
        // Baseline multiply
        //---------------------
        private static void BaselineMultiply2(
          short[] result,
          int rstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart)
        {
            unchecked
            {
                int p; short c; int d;
                int a0 = ((int)words1[astart]) & 0xffff;
                int a1 = ((int)words1[astart + 1]) & 0xffff;
                int b0 = ((int)words2[bstart]) & 0xffff;
                int b1 = ((int)words2[bstart + 1]) & 0xffff;
                p = a0 * b0; c = (short)p; d = ((int)p >> 16) & 0xffff;
                result[rstart] = c; c = (short)d; d = ((int)d >> 16) & 0xffff;
                p = a0 * b1;
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = a1 * b0;
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; result[rstart + 1] = c;
                p = a1 * b1;
                p += d; result[rstart + 2] = (short)p; result[rstart + 3] = (short)(p >>
                            16);
            }
        }

        private static void BaselineMultiply4(
          short[] result,
          int rstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart)
        {
            unchecked
            {
                const int SMask = ShortMask;
                int p; short c; int d;
                int a0 = ((int)words1[astart]) & SMask;
                int b0 = ((int)words2[bstart]) & SMask;
                p = a0 * b0; c = (short)p; d = ((int)p >> 16) & SMask;
                result[rstart] = c; c = (short)d; d = ((int)d >> 16) & SMask;
                p = a0 * (((int)words2[bstart + 1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * b0;
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 1] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = a0 * (((int)words2[bstart + 2]) & SMask);

                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * b0;
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 2] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = a0 * (((int)words2[bstart + 3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;

                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * b0;
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 3] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 4] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 5] = c;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += d; result[rstart + 6] = (short)p; result[rstart + 7] = (short)(p >>
                            16);
            }
        }

        private static void BaselineMultiply8(
          short[] result,
          int rstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart)
        {
            unchecked
            {
                int p; short c; int d;
                const int SMask = ShortMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart]) &
                            SMask); c = (short)p; d = ((int)p >> 16) &
                  SMask;
                result[rstart] = c; c = (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart + 1]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 1] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart + 2]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 2] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart + 3]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 3] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart + 4]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 4] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart + 5]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            4]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 5] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart + 6]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            5]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            4]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 6] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart]) & SMask) * (((int)words2[bstart + 7]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            6]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            5]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            4]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart]) &
                            SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 7] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 1]) & SMask) * (((int)words2[bstart +
                            7]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            6]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            5]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart +
                            4]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart +
                            1]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 8] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 2]) & SMask) * (((int)words2[bstart +
                            7]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            6]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart +
                            5]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart +
                            4]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart +
                            2]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 9] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 3]) & SMask) * (((int)words2[bstart +
                            7]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart +
                            6]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart +
                            5]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart +
                            4]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart +
                            3]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 10] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 4]) & SMask) * (((int)words2[bstart +
                            7]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart +
                            6]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart +
                            5]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart +
                            4]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 11] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 5]) & SMask) * (((int)words2[bstart +
                            7]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart +
                            6]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart +
                            5]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 12] = c; c =
                  (short)d; d = ((int)d >> 16) & SMask;
                p = (((int)words1[astart + 6]) & SMask) * (((int)words2[bstart +
                            7]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart +
                            6]) & SMask);
                p += ((int)c) & SMask; c = (short)p;
                d += ((int)p >> 16) & SMask; result[rstart + 13] = c;
                p = (((int)words1[astart + 7]) & SMask) * (((int)words2[bstart +
                            7]) & SMask);
                p += d; result[rstart + 14] = (short)p; result[rstart + 15] =
                  (short)(p >> 16);
            }
        }
        //-----------------------------
        // Baseline Square
        //-----------------------------
        private static void BaselineSquare2(
          short[] result,
          int rstart,
          short[] words1,
          int astart)
        {
            unchecked
            {
                int p; short c; int d; int e;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart]) &
                            0xffff); result[rstart] = (short)p; e = ((int)p >>
                            16) & 0xffff;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 1]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<=
                  1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 1] = c;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            1]) & 0xffff);
                p += e; result[rstart + 2] = (short)p; result[rstart + 3] = (short)(p >>
                            16);
            }
        }

        private static void BaselineSquare4(
          short[] result,
          int rstart,
          short[] words1,
          int astart)
        {
            unchecked
            {
                int p; short c; int d; int e;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart]) &
                            0xffff); result[rstart] = (short)p; e = ((int)p >>
                            16) & 0xffff;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 1]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<=
                  1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 1] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 2]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<=
                  1;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            1]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 2] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 3]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            2]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 3] = c;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            3]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<= 1;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            2]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 4] = c;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            3]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + (2 * 4) - 3] = c;
                p = (((int)words1[astart + 3]) & 0xffff) * (((int)words1[astart +
                            3]) & 0xffff);
                p += e; result[rstart + 6] = (short)p; result[rstart + 7] = (short)(p >>
                            16);
            }
        }

        private static void BaselineSquare8(
          short[] result,
          int rstart,
          short[] words1,
          int astart)
        {
            unchecked
            {
                int p; short c; int d; int e;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart]) &
                            0xffff); result[rstart] = (short)p; e = ((int)p >>
                            16) & 0xffff;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 1]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<=
                  1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 1] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 2]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<=
                  1;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            1]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 2] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 3]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            2]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 3] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 4]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            3]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            2]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 4] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 5]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            4]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            3]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 5] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 6]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            5]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            4]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                p = (((int)words1[astart + 3]) & 0xffff) * (((int)words1[astart +
                            3]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 6] = c;
                p = (((int)words1[astart]) & 0xffff) * (((int)words1[astart + 7]) &
                            0xffff); c = (short)p; d = ((int)p >> 16) &
                  0xffff;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            6]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            5]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = (((int)words1[astart + 3]) & 0xffff) * (((int)words1[astart +
                            4]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 7] = c;
                p = (((int)words1[astart + 1]) & 0xffff) * (((int)words1[astart +
                            7]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            6]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = (((int)words1[astart + 3]) & 0xffff) * (((int)words1[astart +
                            5]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                p = (((int)words1[astart + 4]) & 0xffff) * (((int)words1[astart +
                            4]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 8] = c;
                p = (((int)words1[astart + 2]) & 0xffff) * (((int)words1[astart +
                            7]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                p = (((int)words1[astart + 3]) & 0xffff) * (((int)words1[astart +
                            6]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                p = (((int)words1[astart + 4]) & 0xffff) * (((int)words1[astart +
                            5]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 9] = c;
                p = (((int)words1[astart + 3]) & 0xffff) * (((int)words1[astart +
                            7]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                p = (((int)words1[astart + 4]) & 0xffff) * (((int)words1[astart +
                            6]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                p = (((int)words1[astart + 5]) & 0xffff) * (((int)words1[astart +
                            5]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 10] = c;
                p = (((int)words1[astart + 4]) & 0xffff) * (((int)words1[astart +
                            7]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                p = (((int)words1[astart + 5]) & 0xffff) * (((int)words1[astart +
                            6]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff; d = (int)((d << 1) + (((int)c >> 15) &
                            1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 11] = c;
                p = (((int)words1[astart + 5]) & 0xffff) * (((int)words1[astart +
                            7]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<= 1;
                p = (((int)words1[astart + 6]) & 0xffff) * (((int)words1[astart +
                            6]) & 0xffff);
                p += ((int)c) & 0xffff; c = (short)p;
                d += ((int)p >> 16) & 0xffff;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 12] = c;
                p = (((int)words1[astart + 6]) & 0xffff) * (((int)words1[astart +
                            7]) & 0xffff); c = (short)p; d = ((int)p >>
                            16) & 0xffff;
                d = (int)((d << 1) + (((int)c >> 15) & 1)); c <<= 1;
                e += ((int)c) & 0xffff; c = (short)e; e = d + (((int)e >> 16) &
                            0xffff); result[rstart + 13] = c;
                p = (((int)words1[astart + 7]) & 0xffff) * (((int)words1[astart +
                            7]) & 0xffff);
                p += e; result[rstart + 14] = (short)p; result[rstart + 15] =
                  (short)(p >> 16);
            }
        }

        private static int BitPrecision(short numberValue)
        {
            if (numberValue == 0)
            {
                return 0;
            }
            int i = 16;
            unchecked
            {
                if ((numberValue >> 8) == 0)
                {
                    numberValue <<= 8;
                    i -= 8;
                }

                if ((numberValue >> 12) == 0)
                {
                    numberValue <<= 4;
                    i -= 4;
                }

                if ((numberValue >> 14) == 0)
                {
                    numberValue <<= 2;
                    i -= 2;
                }

                if ((numberValue >> 15) == 0)
                {
                    --i;
                }
            }
            return i;
        }

        private static int BitsToWords(int bitCount)
        {
            return (bitCount + 15) >> 4;
        }

        private static void ChunkedLinearMultiply(
          short[] productArr,
          int cstart,
          short[] tempArr,
          int tempStart,  // uses bcount*4 space
          short[] words1,
          int astart,
          int acount,  // Equal size or longer
          short[] words2,
          int bstart,
          int bcount)
        {
#if DEBUG
            if (acount < bcount)
            {
                throw new ArgumentException("acount (" + acount + ") is less than " +
                            bcount);
            }

            if (productArr == null)
            {
                throw new ArgumentNullException(nameof(productArr));
            }

            if (cstart < 0)
            {
                throw new ArgumentException("cstart (" + cstart + ") is less than " +
                            "0");
            }

            if (cstart > productArr.Length)
            {
                throw new ArgumentException("cstart (" + cstart + ") is more than " +
                            productArr.Length);
            }

            if (acount + bcount < 0)
            {
                throw new ArgumentException("acount plus bcount (" + (acount + bcount) +
                            ") is less than 0");
            }

            if (acount + bcount > productArr.Length)
            {
                throw new ArgumentException("acount plus bcount (" + (acount + bcount) +
                            ") is more than " + productArr.Length);
            }

            if (productArr.Length - cstart < acount + bcount)
            {
                throw new ArgumentException("productArr.Length minus cstart (" +
                            (productArr.Length - cstart) +
                            ") is less than " + (acount + bcount));
            }

            if (tempArr == null)
            {
                throw new ArgumentNullException(nameof(tempArr));
            }

            if (tempStart < 0)
            {
                throw new ArgumentException("tempStart (" + tempStart +
                            ") is less than 0");
            }

            if (tempStart > tempArr.Length)
            {
                throw new ArgumentException("tempStart (" + tempStart +
                            ") is more than " + tempArr.Length);
            }

            if ((bcount * 4) < 0)
            {
                throw new ArgumentException("bcount * 4 less than 0 (" + (bcount * 4) +
                            ")");
            }

            if ((bcount * 4) > tempArr.Length)
            {
                throw new ArgumentException("bcount * 4 more than " + tempArr.Length +
                            " (" + (bcount * 4) + ")");
            }

            if (tempArr.Length - tempStart < bcount * 4)
            {
                throw new ArgumentException("tempArr.Length minus tempStart (" +
                            (tempArr.Length - tempStart) +
                            ") is less than " + (bcount * 4));
            }

            if (words1 == null)
            {
                throw new ArgumentNullException(nameof(words1));
            }

            if (astart < 0)
            {
                throw new ArgumentException("astart (" + astart + ") is less than " +
                            "0");
            }

            if (astart > words1.Length)
            {
                throw new ArgumentException("astart (" + astart + ") is more than " +
                            words1.Length);
            }

            if (acount < 0)
            {
                throw new ArgumentException("acount (" + acount + ") is less than " +
                            "0");
            }

            if (acount > words1.Length)
            {
                throw new ArgumentException("acount (" + acount + ") is more than " +
                            words1.Length);
            }

            if (words1.Length - astart < acount)
            {
                throw new ArgumentException("words1.Length minus astart (" +
                            (words1.Length - astart) + ") is less than " +
                            acount);
            }

            if (words2 == null)
            {
                throw new ArgumentNullException(nameof(words2));
            }

            if (bstart < 0)
            {
                throw new ArgumentException("bstart (" + bstart + ") is less than " +
                            "0");
            }

            if (bstart > words2.Length)
            {
                throw new ArgumentException("bstart (" + bstart + ") is more than " +
                            words2.Length);
            }

            if (bcount < 0)
            {
                throw new ArgumentException("bcount (" + bcount + ") is less than " +
                            "0");
            }

            if (bcount > words2.Length)
            {
                throw new ArgumentException("bcount (" + bcount + ") is more than " +
                            words2.Length);
            }

            if (words2.Length - bstart < bcount)
            {
                throw new ArgumentException("words2.Length minus bstart (" +
                            (words2.Length - bstart) + ") is less than " +
                            bcount);
            }
#endif

            unchecked
            {
                int carryPos = 0;
                // Set carry to ValueZero
                Array.Clear((short[])productArr, cstart, bcount);
                for (int i = 0; i < acount; i += bcount)
                {
                    int diff = acount - i;
                    if (diff > bcount)
                    {
                        SameSizeMultiply(
                          tempArr,
                          tempStart,
                          tempArr,
                          tempStart + bcount + bcount,
                          words1,
                          astart + i,
                          words2,
                          bstart,
                          bcount);
                        // Add carry
                        AddUnevenSize(
                          tempArr,
                          tempStart,
                          tempArr,
                          tempStart,
                          bcount + bcount,
                          productArr,
                          cstart + carryPos,
                          bcount);
                        // Copy product and carry
                        Array.Copy(
                          tempArr,
                          tempStart,
                          productArr,
                          cstart + i,
                          bcount + bcount);
                        carryPos += bcount;
                    }
                    else
                    {
                        AsymmetricMultiply(
                          tempArr,
                          tempStart,  // uses diff + bcount space
                          tempArr,
                          tempStart + diff + bcount,  // uses diff + bcount
                          words1,
                          astart + i,
                          diff,
                          words2,
                          bstart,
                          bcount);
                        // Add carry
                        AddUnevenSize(
                          tempArr,
                          tempStart,
                          tempArr,
                          tempStart,
                          diff + bcount,
                          productArr,
                          cstart + carryPos,
                          bcount);
                        // Copy product without carry
                        Array.Copy(
                          tempArr,
                          tempStart,
                          productArr,
                          cstart + i,
                          diff + bcount);
                    }
                }
            }
        }

        private static short[] CleanGrow(short[] a, int size)
        {
            if (size > a.Length)
            {
                short[] newa = new short[size];
                Array.Copy(a, newa, a.Length);
                return newa;
            }
            return a;
        }

        private static int Compare(
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int n)
        {
            while (unchecked(n--) != 0)
            {
                int an = ((int)words1[astart + n]) & 0xffff;
                int bn = ((int)words2[bstart + n]) & 0xffff;
                if (an > bn)
                {
                    return 1;
                }
                if (an < bn)
                {
                    return -1;
                }
            }
            return 0;
        }

        private static int CompareWithWords1IsOneBigger(
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int words1Count)
        {
            // NOTE: Assumes that words2's count is 1 less
            if (words1[astart + words1Count - 1] != 0)
            {
                return 1;
            }
            int w1c = words1Count;
            --w1c;
            while (unchecked(w1c--) != 0)
            {
                int an = ((int)words1[astart + w1c]) & 0xffff;
                int bn = ((int)words2[bstart + w1c]) & 0xffff;
                if (an > bn)
                {
                    return 1;
                }
                if (an < bn)
                {
                    return -1;
                }
            }
            return 0;
        }

        private static int CountWords(short[] array)
        {
            int n = array.Length;
            while (n != 0 && array[n - 1] == 0)
            {
                --n;
            }
            return (int)n;
        }

        private static int CountWords(short[] array, int pos, int len)
        {
            int n = len;
            while (n != 0 && array[pos + n - 1] == 0)
            {
                --n;
            }
            return (int)n;
        }

        private static int Decrement(
          short[] words1,
          int words1Start,
          int n,
          short words2)
        {
            unchecked
            {
                short tmp = words1[words1Start];
                words1[words1Start] = (short)(tmp - words2);
                if ((((int)words1[words1Start]) & 0xffff) <= (((int)tmp) & 0xffff))
                {
                    return 0;
                }
                for (int i = 1; i < n; ++i)
                {
                    tmp = words1[words1Start + i];
                    --words1[words1Start + i];
                    if (tmp != 0)
                    {
                        return 0;
                    }
                }
                return 1;
            }
        }

        private static short Divide32By16(
           int dividendLow,
           short divisorShort,
           bool returnRemainder)
        {
            int tmpInt;
            int dividendHigh = 0;
            int intDivisor = ((int)divisorShort) & 0xffff;
            for (int i = 0; i < 32; ++i)
            {
                tmpInt = dividendHigh >> 31;
                dividendHigh <<= 1;
                dividendHigh = unchecked((int)(dividendHigh | ((int)((dividendLow >>
                            31) & 1))));
                dividendLow <<= 1;
                tmpInt |= dividendHigh;
                // unsigned greater-than-or-equal check
                if (((tmpInt >> 31) != 0) || (tmpInt >= intDivisor))
                {
                    unchecked
                    {
                        dividendHigh -= intDivisor;
                        ++dividendLow;
                    }
                }
            }
            return returnRemainder ? unchecked((short)(((int)dividendHigh) &
                          0xffff)) : unchecked((short)(((int)dividendLow) &
                          0xffff));
        }

        private static short DivideUnsigned(int x, short y)
        {
            if ((x >> 31) == 0)
            {
                // x is already nonnegative
                int iy = ((int)y) & 0xffff;
                return unchecked((short)((int)x / iy));
            }
            else
            {
                long longX = ((long)x) & 0xffffffffL;
                int iy = ((int)y) & 0xffff;
                return unchecked((short)(longX / iy));
            }
        }

        private static void FastDivide(
          short[] quotientReg,
          short[] dividendReg,
          int count,
          short divisorSmall)
        {
            switch (divisorSmall)
            {
                case 2:
                    FastDivideAndRemainderTwo(quotientReg, 0, dividendReg, 0, count);
                    break;
                case 10:
                    FastDivideAndRemainderTen(quotientReg, 0, dividendReg, 0, count);
                    break;
                default:
                    FastDivideAndRemainder(
                 quotientReg,
                 0,
                 dividendReg,
                 0,
                 count,
                 divisorSmall);
                    break;
            }
        }

        private static short FastDivideAndRemainderTwo(
          short[] quotientReg,
          int quotientStart,
          short[] dividendReg,
          int dividendStart,
          int count)
        {
            int quo;
            int rem = 0;
            int currentDividend;
            int ds = dividendStart + count - 1;
            int qs = quotientStart + count - 1;
            for (int i = 0; i < count; ++i)
            {
                currentDividend = ((int)dividendReg[ds]) & 0xffff;
                currentDividend |= rem << 16;
                quo = currentDividend >> 1;
                quotientReg[qs] = unchecked((short)quo);
                rem = currentDividend & 1;
                --ds;
                --qs;
            }
            return unchecked((short)rem);
        }

        private static short FastDivideAndRemainderTen(
          short[] quotientReg,
          int quotientStart,
          short[] dividendReg,
          int dividendStart,
          int count)
        {
            int quo;
            int rem = 0;
            int currentDividend;
            int ds = dividendStart + count - 1;
            int qs = quotientStart + count - 1;
            for (int i = 0; i < count; ++i)
            {
                currentDividend = ((int)dividendReg[ds]) & 0xffff;
                currentDividend |= rem << 16;
                quo = (currentDividend < 43698) ? ((currentDividend * 26215) >> 18) :
                    (currentDividend / 10);
                quotientReg[qs] = unchecked((short)quo);
                rem = currentDividend - (10 * quo);
                --ds;
                --qs;
            }
            return unchecked((short)rem);
        }

        private static short FastDivideAndRemainder(
          short[] quotientReg,
          int quotientStart,
          short[] dividendReg,
          int dividendStart,
          int count,
          short divisorSmall)
        {
            int idivisor = ((int)divisorSmall) & 0xffff;
            int quo;
            int rem = 0;
            int ds = dividendStart + count - 1;
            int qs = quotientStart + count - 1;
            int currentDividend;
            if (idivisor >= 0x8000)
            {
                for (int i = 0; i < count; ++i)
                {
                    currentDividend = ((int)dividendReg[ds]) & 0xffff;
                    currentDividend |= rem << 16;
                    if ((currentDividend >> 31) == 0)
                    {
                        quo = currentDividend / idivisor;
                        quotientReg[qs] = unchecked((short)quo);
                        rem = currentDividend - (idivisor * quo);
                    }
                    else
                    {
                        quo = ((int)DivideUnsigned(
                         currentDividend,
                         divisorSmall)) & 0xffff;
                        quotientReg[qs] = unchecked((short)quo);
                        rem = unchecked(currentDividend - (idivisor * quo));
                    }
                    --ds;
                    --qs;
                }
            }
            else
            {
                for (int i = 0; i < count; ++i)
                {
                    currentDividend = ((int)dividendReg[ds]) & 0xffff;
                    currentDividend |= rem << 16;
                    quo = currentDividend / idivisor;
                    quotientReg[qs] = unchecked((short)quo);
                    rem = currentDividend - (idivisor * quo);
                    --ds;
                    --qs;
                }
            }
            return unchecked((short)rem);
        }

        private static short FastRemainder(
          short[] dividendReg,
          int count,
          short divisorSmall)
        {
            int i = count;
            short remainder = 0;
            while ((i--) > 0)
            {
                remainder = RemainderUnsigned(
                  MakeUint(dividendReg[i], remainder),
                  divisorSmall);
            }
            return remainder;
        }

        private static short GetHighHalfAsBorrow(int val)
        {
            return unchecked((short)(0 - ((val >> 16) & 0xffff)));
        }

        private static int GetLowHalf(int val)
        {
            return val & 0xffff;
        }

        private static int GetUnsignedBitLengthEx(int numberValue, int wordCount)
        {
            int wc = wordCount;
            if (wc != 0)
            {
                wc = (wc - 1) << 4;
                if (numberValue == 0)
                {
                    return wc;
                }
                wc += 16;
                unchecked
                {
                    if ((numberValue >> 8) == 0)
                    {
                        numberValue <<= 8;
                        wc -= 8;
                    }
                    if ((numberValue >> 12) == 0)
                    {
                        numberValue <<= 4;
                        wc -= 4;
                    }
                    if ((numberValue >> 14) == 0)
                    {
                        numberValue <<= 2;
                        wc -= 2;
                    }
                    if ((numberValue >> 15) == 0)
                    {
                        --wc;
                    }
                }
                return wc;
            }
            return 0;
        }

        private static short[] GrowForCarry(short[] a, short carry)
        {
            int oldLength = a.Length;
            short[] ret = CleanGrow(a, oldLength + 1);
            ret[oldLength] = carry;
            return ret;
        }

        private static int Increment(
          short[] words1,
          int words1Start,
          int n,
          short words2)
        {
            unchecked
            {
                short tmp = words1[words1Start];
                words1[words1Start] = (short)(tmp + words2);
                if ((((int)words1[words1Start]) & 0xffff) >= (((int)tmp) & 0xffff))
                {
                    return 0;
                }
                for (int i = 1; i < n; ++i)
                {
                    ++words1[words1Start + i];
                    if (words1[words1Start + i] != 0)
                    {
                        return 0;
                    }
                }
                return 1;
            }
        }

        private static short LinearMultiply(
          short[] productArr,
          int cstart,
          short[] words1,
          int astart,
          short words2,
          int n)
        {
            unchecked
            {
                short carry = 0;
                int bint = ((int)words2) & 0xffff;
                for (int i = 0; i < n; ++i)
                {
                    int p;
                    p = (((int)words1[astart + i]) & 0xffff) * bint;
                    p += ((int)carry) & 0xffff;
                    productArr[cstart + i] = (short)p;
                    carry = (short)(p >> 16);
                }
                return carry;
            }
        }

        private static short LinearMultiplyAdd(
          short[] productArr,
          int cstart,
          short[] words1,
          int astart,
          short words2,
          int n)
        {
            short carry = 0;
            int bint = ((int)words2) & 0xffff;
            for (int i = 0; i < n; ++i)
            {
                int p;
                p = unchecked((((int)words1[astart + i]) & 0xffff) * bint);
                p = unchecked(p + (((int)carry) & 0xffff));
                p = unchecked(p + (((int)productArr[cstart + i]) & 0xffff));
                productArr[cstart + i] = unchecked((short)p);
                carry = (short)(p >> 16);
            }
            return carry;
        }

        private static int MakeUint(short first, short second)
        {
            return unchecked((int)((((int)first) & 0xffff) | ((int)second << 16)));
        }

        private static void RecursiveSquare(
          short[] resultArr,
          int resultStart,
          short[] tempArr,
          int tempStart,
          short[] words1,
          int words1Start,
          int count)
        {
            if (count <= RecursionLimit)
            {
                switch (count)
                {
                    case 2:
                        BaselineSquare2(resultArr, resultStart, words1, words1Start);
                        break;
                    case 4:
                        BaselineSquare4(resultArr, resultStart, words1, words1Start);
                        break;
                    case 8:
                        BaselineSquare8(resultArr, resultStart, words1, words1Start);
                        break;
                    default:
                        SchoolbookSquare(
              resultArr,
              resultStart,
              words1,
              words1Start,
              count);
                        break;
                }
            }
            else if ((count & 1) == 0)
            {
                int count2 = count >> 1;
                RecursiveSquare(
                  resultArr,
                  resultStart,
                  tempArr,
                  tempStart + count,
                  words1,
                  words1Start,
                  count2);
                RecursiveSquare(
                  resultArr,
                  resultStart + count,
                  tempArr,
                  tempStart + count,
                  words1,
                  words1Start + count2,
                  count2);
                SameSizeMultiply(
                  tempArr,
                  tempStart,
                  tempArr,
                  tempStart + count,
                  words1,
                  words1Start,
                  words1,
                  words1Start + count2,
                  count2);
                int carry = AddInternal(
                  resultArr,
                  resultStart + count2,
                  resultArr,
                  resultStart + count2,
                  tempArr,
                  tempStart,
                  count);
                carry += AddInternal(
                  resultArr,
                  resultStart + count2,
                  resultArr,
                  resultStart + count2,
                  tempArr,
                  tempStart,
                  count);
                Increment(
                  resultArr,
                  (int)(resultStart + count + count2),
                  count2,
                  (short)carry);
            }
            else
            {
                SameSizeMultiply(
                  resultArr,
                  resultStart,
                  tempArr,
                  tempStart,
                  words1,
                  words1Start,
                  words1,
                  words1Start,
                  count);
            }
        }

        private static short RemainderUnsigned(int x, short y)
        {
            unchecked
            {
                int iy = ((int)y) & 0xffff;
                return ((x >> 31) == 0) ? ((short)(((int)x % iy) & 0xffff)) :
                  Divide32By16(x, y, true);
            }
        }

        private static void ReverseChars(char[] chars, int offset, int length)
        {
            int half = length >> 1;
            int right = offset + length - 1;
            for (int i = 0; i < half; i++, right--)
            {
                char value = chars[offset + i];
                chars[offset + i] = chars[right];
                chars[right] = value;
            }
        }

        // NOTE: Renamed from RecursiveMultiply to better show that
        // this function only takes operands of the same size, as opposed
        // to AsymmetricMultiply.
        private static void SameSizeMultiply(
          short[] resultArr,  // size 2*count
          int resultStart,
          short[] tempArr,  // size 2*count
          int tempStart,
          short[] words1,
          int words1Start,  // size count
          short[] words2,
          int words2Start,  // size count
          int count)
        {
            // DebugUtility.Log("RecursiveMultiply " + count + " " + count +
            // " [r=" + resultStart + " t=" + tempStart + " a=" + words1Start +
            // " b=" + words2Start + "]");
#if DEBUG
            if (resultArr == null)
            {
                throw new ArgumentNullException(nameof(resultArr));
            }

            if (resultStart < 0)
            {
                throw new ArgumentException("resultStart (" + resultStart +
                            ") is less than 0");
            }

            if (resultStart > resultArr.Length)
            {
                throw new ArgumentException("resultStart (" + resultStart +
                            ") is more than " + resultArr.Length);
            }

            if (count + count < 0)
            {
                throw new ArgumentException("count plus count (" + (count + count) +
                            ") is less than 0");
            }
            if (count + count > resultArr.Length)
            {
                throw new ArgumentException("count plus count (" + (count + count) +
                            ") is more than " + resultArr.Length);
            }

            if (resultArr.Length - resultStart < count + count)
            {
                throw new ArgumentException("resultArr.Length minus resultStart (" +
                            (resultArr.Length - resultStart) +
                            ") is less than " + (count + count));
            }

            if (tempArr == null)
            {
                throw new ArgumentNullException(nameof(tempArr));
            }

            if (tempStart < 0)
            {
                throw new ArgumentException("tempStart (" + tempStart +
                            ") is less than 0");
            }

            if (tempStart > tempArr.Length)
            {
                throw new ArgumentException("tempStart (" + tempStart +
                            ") is more than " + tempArr.Length);
            }

            if (count + count < 0)
            {
                throw new ArgumentException("count plus count (" + (count + count) +
                            ") is less than 0");
            }

            if (count + count > tempArr.Length)
            {
                throw new ArgumentException("count plus count (" + (count + count) +
                            ") is more than " + tempArr.Length);
            }

            if (tempArr.Length - tempStart < count + count)
            {
                throw new ArgumentException("tempArr.Length minus tempStart (" +
                            (tempArr.Length - tempStart) +
                            ") is less than " + (count + count));
            }

            if (words1 == null)
            {
                throw new ArgumentNullException(nameof(words1));
            }

            if (words1Start < 0)
            {
                throw new ArgumentException("words1Start (" + words1Start +
                            ") is less than 0");
            }

            if (words1Start > words1.Length)
            {
                throw new ArgumentException("words1Start (" + words1Start +
                            ") is more than " + words1.Length);
            }

            if (count < 0)
            {
                throw new ArgumentException("count (" + count + ") is less than " +
                            "0");
            }

            if (count > words1.Length)
            {
                throw new ArgumentException("count (" + count + ") is more than " +
                            words1.Length);
            }

            if (words1.Length - words1Start < count)
            {
                throw new ArgumentException("words1.Length minus words1Start (" +
                            (words1.Length - words1Start) + ") is less than " +
                            count);
            }

            if (words2 == null)
            {
                throw new ArgumentNullException(nameof(words2));
            }

            if (words2Start < 0)
            {
                throw new ArgumentException("words2Start (" + words2Start +
                            ") is less than 0");
            }

            if (words2Start > words2.Length)
            {
                throw new ArgumentException("words2Start (" + words2Start +
                            ") is more than " + words2.Length);
            }

            if (count < 0)
            {
                throw new ArgumentException("count (" + count + ") is less than " +
                            "0");
            }

            if (count > words2.Length)
            {
                throw new ArgumentException("count (" + count + ") is more than " +
                            words2.Length);
            }

            if (words2.Length - words2Start < count)
            {
                throw new ArgumentException("words2.Length minus words2Start (" +
                            (words2.Length - words2Start) + ") is less than " +
                            count);
            }
#endif

            if (count <= RecursionLimit)
            {
                switch (count)
                {
                    case 2:
                        BaselineMultiply2(
              resultArr,
              resultStart,
              words1,
              words1Start,
              words2,
              words2Start);
                        break;
                    case 4:
                        BaselineMultiply4(
              resultArr,
              resultStart,
              words1,
              words1Start,
              words2,
              words2Start);
                        break;
                    case 8:
                        BaselineMultiply8(
              resultArr,
              resultStart,
              words1,
              words1Start,
              words2,
              words2Start);
                        break;
                    default:
                        SchoolbookMultiply(
       resultArr,
       resultStart,
       words1,
       words1Start,
       count,
       words2,
       words2Start,
       count);
                        break;
                }
            }
            else
            {
                int countA = count;
                while (countA != 0 && words1[words1Start + countA - 1] == 0)
                {
                    --countA;
                }
                int countB = count;
                while (countB != 0 && words2[words2Start + countB - 1] == 0)
                {
                    --countB;
                }
                int offset2For1 = 0;
                int offset2For2 = 0;
                if (countA == 0 || countB == 0)
                {
                    // words1 or words2 is empty, so result is 0
                    Array.Clear((short[])resultArr, resultStart, count << 1);
                    return;
                }
                // Split words1 and words2 in two parts each
                // Words1 is split into HighA and LowA
                // Words2 is split into HighB and LowB
                if ((count & 1) == 0)
                {
                    // Count is even, so each part will be equal size
                    int count2 = count >> 1;
                    if (countA <= count2 && countB <= count2)
                    {
                        // Both words1 and words2 are smaller than half the
                        // count (their high parts are 0)
                        // DebugUtility.Log("Can be smaller: " + AN + "," + BN + "," +
                        // (count2));
                        Array.Clear((short[])resultArr, resultStart + count, count);
                        if (count2 == 8)
                        {
                            BaselineMultiply8(
                              resultArr,
                              resultStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start);
                        }
                        else
                        {
                            SameSizeMultiply(
                              resultArr,
                              resultStart,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start,
                              count2);
                        }
                        return;
                    }
                    int resultMediumHigh = resultStart + count;
                    int resultHigh = resultMediumHigh + count2;
                    int resultMediumLow = resultStart + count2;
                    int tsn = tempStart + count;
                    // Find the part of words1 with the higher value
                    // so we can compute the absolute value
                    offset2For1 = Compare(
                      words1,
                      words1Start,
                      words1,
                      words1Start + count2,
                      count2) > 0 ? 0 : count2;
                    int tmpvar = (int)(words1Start + (count2 ^
                              offset2For1));
                    // Abs(LowA - HighA)
                    SubtractInternal(
                      resultArr,
                      resultStart,
                      words1,
                      words1Start + offset2For1,
                      words1,
                      tmpvar,
                      count2);
                    // Find the part of words2 with the higher value
                    // so we can compute the absolute value
                    offset2For2 = Compare(
                      words2,
                      words2Start,
                      words2,
                      words2Start + count2,
                      count2) > 0 ? 0 : count2;
                    // Abs(LowB - HighB)
                    int tmp = words2Start + (count2 ^ offset2For2);
                    SubtractInternal(
                      resultArr,
                      resultMediumLow,
                      words2,
                      words2Start + offset2For2,
                      words2,
                      tmp,
                      count2);
                    // Medium-high/high result = HighA * HighB
                    SameSizeMultiply(
                      resultArr,
                      resultMediumHigh,
                      tempArr,
                      tsn,
                      words1,
                      words1Start + count2,
                      words2,
                      words2Start + count2,
                      count2);
                    // Temp = Abs(LowA-HighA) * Abs(LowB-HighB)
                    SameSizeMultiply(
                      tempArr,
                      tempStart,
                      tempArr,
                      tsn,
                      resultArr,
                      resultStart,
                      resultArr,
                      resultMediumLow,
                      count2);
                    // Low/Medium-low result = LowA * LowB
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tsn,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      count2);
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB)
                    int c2 = AddInternal(
                      resultArr,
                      resultMediumHigh,
                      resultArr,
                      resultMediumHigh,
                      resultArr,
                      resultMediumLow,
                      count2);
                    int c3 = c2;
                    // Medium low result = Low(HighA * HighB) + High(LowA * LowB) +
                    // Low(LowA * LowB)
                    c2 += AddInternal(
                      resultArr,
                      resultMediumLow,
                      resultArr,
                      resultMediumHigh,
                      resultArr,
                      resultStart,
                      count2);
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB) +
                    // High(HighA * HighB)
                    c3 += AddInternal(
                      resultArr,
                      resultMediumHigh,
                      resultArr,
                      resultMediumHigh,
                      resultArr,
                      resultHigh,
                      count2);
                    if (offset2For1 == offset2For2)
                    {
                        // If high parts of both words were greater
                        // than their low parts
                        // or if low parts of both words were greater
                        // than their high parts
                        // Medium low/Medium high result = Medium low/Medium high result
                        // - Low(Temp)
                        c3 -= SubtractInternal(
                          resultArr,
                          resultMediumLow,
                          resultArr,
                          resultMediumLow,
                          tempArr,
                          tempStart,
                          count);
                    }
                    else
                    {
                        // Medium low/Medium high result = Medium low/Medium high result
                        // + Low(Temp)
                        c3 += AddInternal(
                          resultArr,
                          resultMediumLow,
                          resultArr,
                          resultMediumLow,
                          tempArr,
                          tempStart,
                          count);
                    }
                    // Add carry
                    c3 += Increment(resultArr, resultMediumHigh, count2, (short)c2);
                    if (c3 != 0)
                    {
                        Increment(resultArr, resultHigh, count2, (short)c3);
                    }
                }
                else
                {
                    // Count is odd, high part will be 1 shorter
                    int countHigh = count >> 1;  // Shorter part
                    int countLow = count - countHigh;  // Longer part
                    offset2For1 = CompareWithWords1IsOneBigger(
                      words1,
                      words1Start,
                      words1,
                      words1Start + countLow,
                      countLow) > 0 ? 0 : countLow;
                    // Abs(LowA - HighA)
                    if (offset2For1 == 0)
                    {
                        SubtractWords1IsOneBigger(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start,
                          words1,
                          words1Start + countLow,
                          countLow);
                    }
                    else
                    {
                        SubtractWords2IsOneBigger(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start + countLow,
                          words1,
                          words1Start,
                          countLow);
                    }
                    offset2For2 = CompareWithWords1IsOneBigger(
                      words2,
                      words2Start,
                      words2,
                      words2Start + countLow,
                      countLow) > 0 ? 0 : countLow;
                    // Abs(LowB, HighB)
                    if (offset2For2 == 0)
                    {
                        SubtractWords1IsOneBigger(
                          tempArr,
                          tempStart,
                          words2,
                          words2Start,
                          words2,
                          words2Start + countLow,
                          countLow);
                    }
                    else
                    {
                        SubtractWords2IsOneBigger(
                          tempArr,
                          tempStart,
                          words2,
                          words2Start + countLow,
                          words2,
                          words2Start,
                          countLow);
                    }
                    // Temp = Abs(LowA-HighA) * Abs(LowB-HighB)
                    int shorterOffset = countHigh << 1;
                    int longerOffset = countLow << 1;
                    SameSizeMultiply(
                      tempArr,
                      tempStart + shorterOffset,
                      resultArr,
                      resultStart + shorterOffset,
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      countLow);
                    // Save part of temp since temp will overlap in part
                    // in the Low/Medium low result multiply
                    short resultTmp0 = tempArr[tempStart + shorterOffset];
                    short resultTmp1 = tempArr[tempStart + shorterOffset + 1];
                    // Medium high/high result = HighA * HighB
                    SameSizeMultiply(
                      resultArr,
                      resultStart + longerOffset,
                      resultArr,
                      resultStart,
                      words1,
                      words1Start + countLow,
                      words2,
                      words2Start + countLow,
                      countHigh);
                    // Low/Medium low result = LowA * LowB
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      countLow);
                    // Restore part of temp
                    tempArr[tempStart + shorterOffset] = resultTmp0;
                    tempArr[tempStart + shorterOffset + 1] = resultTmp1;
                    int countMiddle = countLow << 1;
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB)
                    int c2 = AddInternal(
                      resultArr,
                      resultStart + countMiddle,
                      resultArr,
                      resultStart + countMiddle,
                      resultArr,
                      resultStart + countLow,
                      countLow);
                    int c3 = c2;
                    // Medium low result = Low(HighA * HighB) + High(LowA * LowB) +
                    // Low(LowA * LowB)
                    c2 += AddInternal(
                      resultArr,
                      resultStart + countLow,
                      resultArr,
                      resultStart + countMiddle,
                      resultArr,
                      resultStart,
                      countLow);
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB) +
                    // High(HighA * HighB)
                    c3 += AddUnevenSize(
                      resultArr,
                      resultStart + countMiddle,
                      resultArr,
                      resultStart + countMiddle,
                      countLow,
                      resultArr,
                      resultStart + countMiddle + countLow,
                      countLow - 2);
                    if (offset2For1 == offset2For2)
                    {
                        // If high parts of both words were greater
                        // than their low parts
                        // or if low parts of both words were greater
                        // than their high parts
                        // Medium low/Medium high result = Medium low/Medium high result
                        // - Low(Temp)
                        c3 -= SubtractInternal(
                          resultArr,
                          resultStart + countLow,
                          resultArr,
                          resultStart + countLow,
                          tempArr,
                          tempStart + shorterOffset,
                          countLow << 1);
                    }
                    else
                    {
                        // Medium low/Medium high result = Medium low/Medium high result
                        // + Low(Temp)
                        c3 += AddInternal(
                          resultArr,
                          resultStart + countLow,
                          resultArr,
                          resultStart + countLow,
                          tempArr,
                          tempStart + shorterOffset,
                          countLow << 1);
                    }
                    // Add carry
                    c3 += Increment(
                      resultArr,
                      resultStart + countMiddle,
                      countLow,
                      (short)c2);
                    if (c3 != 0)
                    {
                        Increment(
                          resultArr,
                          resultStart + countMiddle + countLow,
                          countLow - 2,
                          (short)c3);
                    }
                }
            }
        }

        private static void SchoolbookMultiply(
          short[] resultArr,
          int resultStart,
          short[] words1,
          int words1Start,
          int words1Count,
          short[] words2,
          int words2Start,
          int words2Count)
        {
#if DEBUG
            // Avoid overlaps
            if (resultArr == words1)
            {
                int m1 = Math.Max(resultStart, words1Start);
                int m2 = Math.Min(
          resultStart + words1Count + words2Count,
          words1Start + words1Count);
                if (m1 < m2)
                {
                    throw new ArgumentException();
                }
            }
            if (resultArr == words2)
            {
                int m1 = Math.Max(resultStart, words2Start);
                int m2 = Math.Min(
          resultStart + words1Count + words2Count,
          words2Start + words2Count);
                if (m1 < m2)
                {
                    throw new ArgumentException();
                }
            }
            if (words1Count <= 0)
            {
                throw new ArgumentException("words1Count (" + words1Count +
                  ") is not greater than 0");
            }
            if (words2Count <= 0)
            {
                throw new ArgumentException("words2Count (" + words2Count +
                  ") is not greater than 0");
            }
#endif

            int cstart, carry, valueBint;
            if (words1Count < words2Count)
            {
                // words1 is shorter than words2, so put words2 on top
                carry = 0;
                valueBint = ((int)words1[words1Start]) & 0xffff;
                for (int j = 0; j < words2Count; ++j)
                {
                    int p;
                    p = unchecked((((int)words2[words2Start + j]) & 0xffff) *
                          valueBint);
                    p = unchecked(p + (((int)carry) & 0xffff));
                    resultArr[resultStart + j] = unchecked((short)p);
                    carry = (p >> 16) & 0xffff;
                }
                resultArr[resultStart + words2Count] = unchecked((short)carry);
                for (int i = 1; i < words1Count; ++i)
                {
                    cstart = resultStart + i;
                    carry = 0;
                    valueBint = ((int)words1[words1Start + i]) & 0xffff;
                    for (int j = 0; j < words2Count; ++j)
                    {
                        int p;
                        p = unchecked((((int)words2[words2Start + j]) & 0xffff) *
                              valueBint);
                        p = unchecked(p + (((int)carry) & 0xffff));
                        p = unchecked(p + (((int)resultArr[cstart + j]) & 0xffff));
                        resultArr[cstart + j] = unchecked((short)p);
                        carry = (p >> 16) & 0xffff;
                    }
                    resultArr[cstart + words2Count] = unchecked((short)carry);
                }
            }
            else
            {
                // words2 is shorter or the same length as words1
                carry = 0;
                valueBint = ((int)words2[words2Start]) & 0xffff;
                for (int j = 0; j < words1Count; ++j)
                {
                    int p;
                    p = unchecked((((int)words1[words1Start + j]) & 0xffff) *
                          valueBint);
                    p = unchecked(p + (((int)carry) & 0xffff));
                    resultArr[resultStart + j] = unchecked((short)p);
                    carry = (p >> 16) & 0xffff;
                }
                resultArr[resultStart + words1Count] = unchecked((short)carry);
                for (int i = 1; i < words2Count; ++i)
                {
                    cstart = resultStart + i;
                    carry = 0;
                    valueBint = ((int)words2[words2Start + i]) & 0xffff;
                    for (int j = 0; j < words1Count; ++j)
                    {
                        int p;
                        p = unchecked((((int)words1[words1Start + j]) & 0xffff) *
                              valueBint);
                        p = unchecked(p + (((int)carry) & 0xffff));
                        p = unchecked(p + (((int)resultArr[cstart + j]) & 0xffff));
                        resultArr[cstart + j] = unchecked((short)p);
                        carry = (p >> 16) & 0xffff;
                    }
                    resultArr[cstart + words1Count] = unchecked((short)carry);
                }
            }
        }

        private static void SchoolbookSquare(
          short[] resultArr,
          int resultStart,
          short[] words1,
          int words1Start,
          int words1Count)
        {
            // Method assumes that resultArr was already zeroed,
            // if resultArr is the same as words1
            int cstart;
            for (int i = 0; i < words1Count; ++i)
            {
                cstart = resultStart + i;
                unchecked
                {
                    short carry = 0;
                    int valueBint = ((int)words1[words1Start + i]) & 0xffff;
                    for (int j = 0; j < words1Count; ++j)
                    {
                        int p;
                        p = (((int)words1[words1Start + j]) & 0xffff) * valueBint;
                        p += ((int)carry) & 0xffff;
                        if (i != 0)
                        {
                            p += ((int)resultArr[cstart + j]) & 0xffff;
                        }
                        resultArr[cstart + j] = (short)p;
                        carry = (short)(p >> 16);
                    }
                    resultArr[cstart + words1Count] = carry;
                }
            }
        }

        private static short ShiftWordsLeftByBits(
          short[] r,
          int rstart,
          int n,
          int shiftBits)
        {
#if DEBUG
            if (shiftBits >= 16)
            {
                throw new ArgumentException("doesn't satisfy shiftBits<16");
            }
#endif
            int u;
            int carry = 0;
            if (shiftBits != 0)
            {
                int sb16 = 16 - shiftBits;
                int rs = rstart;
                for (int i = 0; i < n; ++i, ++rs)
                {
                    u = r[rs];
                    r[rs] = unchecked((short)((u << shiftBits) | carry));
                    carry = (u & 0xffff) >> sb16;
                }
            }
            return unchecked((short)carry);
        }

        private static void ShiftWordsLeftByWords(
          short[] r,
          int rstart,
          int n,
          int shiftWords)
        {
            shiftWords = Math.Min(shiftWords, n);
            if (shiftWords != 0)
            {
                for (int i = n - 1; i >= shiftWords; --i)
                {
                    r[rstart + i] = r[rstart + i - shiftWords];
                }
                Array.Clear((short[])r, rstart, shiftWords);
            }
        }

        private static short ShiftWordsRightByBits(
          short[] r,
          int rstart,
          int n,
          int shiftBits)
        {
            short u, carry = 0;
            unchecked
            {
                if (shiftBits != 0)
                {
                    for (int i = n; i > 0; --i)
                    {
                        u = r[rstart + i - 1];
                        r[rstart + i - 1] = (short)((((((int)u) & 0xffff) >>
                                (int)shiftBits) & 0xffff) | (((int)carry) &
                                0xffff));
                        carry = (short)((((int)u) & 0xffff) << (int)(16 - shiftBits));
                    }
                }
                return carry;
            }
        }

        private static short ShiftWordsRightByBitsSignExtend(
          short[] r,
          int rstart,
          int n,
          int shiftBits)
        {
            unchecked
            {
                short u, carry = (short)((int)0xffff << (int)(16 - shiftBits));
                if (shiftBits != 0)
                {
                    for (int i = n; i > 0; --i)
                    {
                        u = r[rstart + i - 1];
                        r[rstart + i - 1] = (short)(((((int)u) & 0xffff) >>
                                (int)shiftBits) | (((int)carry) & 0xffff));
                        carry = (short)((((int)u) & 0xffff) << (int)(16 - shiftBits));
                    }
                }
                return carry;
            }
        }

        private static void ShiftWordsRightByWordsSignExtend(
          short[] r,
          int rstart,
          int n,
          int shiftWords)
        {
            shiftWords = Math.Min(shiftWords, n);
            if (shiftWords != 0)
            {
                for (int i = 0; i + shiftWords < n; ++i)
                {
                    r[rstart + i] = r[rstart + i + shiftWords];
                }
                rstart += n - shiftWords;
                // Sign extend
                for (int i = 0; i < shiftWords; ++i)
                {
                    r[rstart + i] = unchecked((short)0xffff);
                }
            }
        }

        private static short[] ShortenArray(short[] reg, int wordCount)
        {
            if (reg.Length > 32)
            {
                int newLength = wordCount;
                if (newLength < reg.Length && (reg.Length - newLength) >= 16)
                {
                    // Reallocate the array if the desired length
                    // is much smaller than the current length
                    short[] newreg = new short[newLength];
                    Array.Copy(reg, newreg, Math.Min(newLength, reg.Length));
                    reg = newreg;
                }
            }
            return reg;
        }

        private static int SubtractWords1IsOneBigger(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int words1Count)
        {
            // Assumes that words2's count is 1 less
            unchecked
            {
                int u;
                u = 0;
                int cm1 = words1Count - 1;
                for (int i = 0; i < cm1; i += 1)
                {
                    u = (((int)words1[astart]) & 0xffff) - (((int)words2[bstart]) &
                              0xffff) - (int)((u >> 31) & 1);
                    c[cstart++] = (short)u;
                    ++astart;
                    ++bstart;
                }
                u = (((int)words1[astart]) & 0xffff) - (int)((u >> 31) & 1);
                c[cstart++] = (short)u;
                return (int)((u >> 31) & 1);
            }
        }

        private static int SubtractWords2IsOneBigger(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int words2Count)
        {
            // Assumes that words1's count is 1 less
            int u;
            u = 0;
            int cm1 = words2Count - 1;
            for (int i = 0; i < cm1; i += 1)
            {
                u = unchecked((((int)words1[astart]) & 0xffff) -
                      (((int)words2[bstart]) & 0xffff) - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                ++astart;
                ++bstart;
            }
            u = 0 - unchecked((((int)words2[bstart]) & 0xffff) - (int)((u >> 31) &
                  1));
            c[cstart++] = unchecked((short)u);
            return (int)((u >> 31) & 1);
        }

        private static int SubtractInternal(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int n)
        {
            int u = 0;
            bool odd = (n & 1) != 0;
            if (odd)
            {
                --n;
            }
            int mask = 0xffff;
            for (int i = 0; i < n; i += 2)
            {
                int wb0 = words2[bstart] & mask;
                int wb1 = words2[bstart + 1] & mask;
                int wa0 = words1[astart] & mask;
                int wa1 = words1[astart + 1] & mask;
                u = unchecked(wa0 - wb0 - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                u = unchecked(wa1 - wb1 - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                astart += 2;
                bstart += 2;
            }
            if (odd)
            {
                u = unchecked((((int)words1[astart]) & mask) -
                      (((int)words2[bstart]) & mask) - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                ++astart;
                ++bstart;
            }
            return (int)((u >> 31) & 1);
        }

        private static void TwosComplement(short[] words1, int words1Start, int n)
        {
            Decrement(words1, words1Start, n, (short)1);
            for (int i = 0; i < n; ++i)
            {
                words1[words1Start + i] = unchecked((short)(~words1[words1Start + i]));
            }
        }

        private int ByteCount()
        {
            int wc = this.wordCount;
            if (wc == 0)
            {
                return 0;
            }
            short s = this.words[wc - 1];
            wc = (wc - 1) << 1;
            return (s == 0) ? wc : (((s >> 8) == 0) ? wc + 1 : wc + 2);
        }

        private bool HasSmallValue()
        {
            int c = (int)this.wordCount;
            if (c > 4)
            {
                return false;
            }
            if (c == 4 && (this.words[3] & 0x8000) != 0)
            {
                return this.negative && this.words[3] == unchecked((short)0x8000) &&
                  this.words[2] == 0 && this.words[1] == 0 &&
                  this.words[0] == 0;
            }
            return true;
        }

        private int PositiveCompare(EInteger t)
        {
            int size = this.wordCount, tempSize = t.wordCount;
            return (
              size == tempSize) ? Compare(
              this.words,
              0,
              t.words,
              0,
              (int)size) : (size > tempSize ? 1 : -1);
        }

        private string SmallValueToString()
        {
            long value = this.ToInt64Unchecked();
            if (value == Int64.MinValue)
            {
                return "-9223372036854775808";
            }
            if (value == (long)Int32.MinValue)
            {
                return "-2147483648";
            }
            bool neg = value < 0;
            int count = 0;
            char[] chars;
            int intvalue = unchecked((int)value);
            if ((long)intvalue == value)
            {
                chars = new char[12];
                count = 11;
                if (neg)
                {
                    intvalue = -intvalue;
                }
                while (intvalue > 43698)
                {
                    int intdivvalue = intvalue / 10;
                    char digit = Digits[(int)(intvalue - (intdivvalue * 10))];
                    chars[count--] = digit;
                    intvalue = intdivvalue;
                }
                while (intvalue > 9)
                {
                    int intdivvalue = (intvalue * 26215) >> 18;
                    char digit = Digits[(int)(intvalue - (intdivvalue * 10))];
                    chars[count--] = digit;
                    intvalue = intdivvalue;
                }
                if (intvalue != 0)
                {
                    chars[count--] = Digits[intvalue];
                }
                if (neg)
                {
                    chars[count] = '-';
                }
                else
                {
                    ++count;
                }
                return new String(chars, count, 12 - count);
            }
            else
            {
                chars = new char[24];
                count = 23;
                if (neg)
                {
                    value = -value;
                }
                while (value > 9)
                {
                    long divvalue = value / 10;
                    char digit = Digits[(int)(value - (divvalue * 10))];
                    chars[count--] = digit;
                    value = divvalue;
                }
                if (value != 0)
                {
                    chars[count--] = Digits[(int)value];
                }
                if (neg)
                {
                    chars[count] = '-';
                }
                else
                {
                    ++count;
                }
                return new String(chars, count, 24 - count);
            }
        }

        private EInteger[] SqrtRemInternal(bool useRem)
        {
            if (this.Sign <= 0)
            {
                return new[] { EInteger.Zero, EInteger.Zero };
            }
            if (this.Equals(EInteger.One))
            {
                return new[] { EInteger.One, EInteger.Zero };
            }
            EInteger bigintX;
            EInteger bigintY;
            EInteger thisValue = this;
            int powerBits = (thisValue.GetUnsignedBitLength() + 1) / 2;
            if (thisValue.CanFitInInt32())
            {
                int smallValue = thisValue.ToInt32Checked();
                // No need to check for ValueZero; already done above
                int smallintX = 0;
                int smallintY = 1 << powerBits;
                do
                {
                    smallintX = smallintY;
                    smallintY = smallValue / smallintX;
                    smallintY += smallintX;
                    smallintY >>= 1;
                } while (smallintY < smallintX);
                if (!useRem)
                {
                    return new[] { (EInteger)smallintX, null };
                }
                smallintY = smallintX * smallintX;
                smallintY = smallValue - smallintY;
                return new[] {
          (EInteger)smallintX, (EInteger)smallintY };
            }
            if (this.wordCount >= 4)
            {
                int wordsPerPart = (this.wordCount + 3) >> 2;
                int bitsPerPart = wordsPerPart * 16;
                int totalBits = bitsPerPart * 4;
                int bitLength = this.GetUnsignedBitLength();
                bool bitLengthEven = (bitLength & 1) == 0;
                bigintX = this;
                int shift = 0;
                if (bitLength < totalBits - 1)
                {
                    int targetLength = bitLengthEven ? totalBits : (totalBits - 1);
                    shift = targetLength - bitLength;
                    bigintX = bigintX.ShiftLeft(shift);
                }
                // DebugUtility.Log("this=" + (this.ToRadixString(16)));
                // DebugUtility.Log("bigx=" + (bigintX.ToRadixString(16)));
                short[] ww = bigintX.words;
                short[] w1 = new short[wordsPerPart];
                short[] w2 = new short[wordsPerPart];
                short[] w3 = new short[wordsPerPart * 2];
                Array.Copy(ww, 0, w1, 0, wordsPerPart);
                Array.Copy(ww, wordsPerPart, w2, 0, wordsPerPart);
                Array.Copy(ww, wordsPerPart * 2, w3, 0, wordsPerPart * 2);
#if DEBUG
                if (!((ww[(wordsPerPart * 4) - 1] & 0xc000) != 0))
                {
                    throw new
                      ArgumentException("doesn't satisfy (ww[wordsPerPart*4-1]&0xC000)!=0");
                }
#endif

                EInteger e1 = new EInteger(CountWords(w1), w1, false);
                EInteger e2 = new EInteger(CountWords(w2), w2, false);
                EInteger e3 = new EInteger(CountWords(w3), w3, false);
                EInteger[] srem = e3.SqrtRemInternal(true);
                // DebugUtility.Log("sqrt0({0})[depth={3}] = {1},{2}"
                // , e3, srem[0], srem[1], 0);
                // DebugUtility.Log("sqrt1({0})[depth={3}] = {1},{2}"
                // , e3, srem2[0], srem2[1], 0);
                // if (!srem[0].Equals(srem2[0]) || !srem[1].Equals(srem2[1])) {
                // throw new InvalidOperationException(this.ToString());
                // }
                EInteger[] qrem = srem[1].ShiftLeft(bitsPerPart).Add(e2).DivRem(
                   srem[0].ShiftLeft(1));
                EInteger sqroot = srem[0].ShiftLeft(bitsPerPart).Add(qrem[0]);
                EInteger sqrem = qrem[1].ShiftLeft(bitsPerPart).Add(e1).Subtract(
                   qrem[0].Multiply(qrem[0]));
                // DebugUtility.Log("sqrem=" + sqrem + ",sqroot=" + sqroot);
                if (sqrem.Sign < 0)
                {
                    if (useRem)
                    {
                        sqrem = sqrem.Add(sqroot.ShiftLeft(1)).Subtract(EInteger.One);
                    }
                    sqroot = sqroot.Subtract(EInteger.One);
#if DEBUG
                    if (!(sqroot.Sign >= 0))
                    {
                        throw new ArgumentException("doesn't satisfy sqroot.Sign>= 0");
                    }
#endif
                }
                /*

          DebugUtility.Log("sqrt({0}) = {1},{2},\n---shift={3},words={4},wpp={5},bxwords={6}",

          this, sqroot, sqrem, shift, this.wordCount, wordsPerPart,
           bigintX.wordCount);
                if (useRem) {
                 DebugUtility.Log("srshHalf=" + (sqrem.ShiftRight(shift>>1)));
                 DebugUtility.Log("srshFull=" + (sqrem.ShiftRight(shift)));
                }
                */
                EInteger[] retarr = new EInteger[2];
                retarr[0] = sqroot.ShiftRight(shift >> 1);
                if (useRem)
                {
                    if (shift == 0)
                    {
                        retarr[1] = sqrem;
                    }
                    else
                    {
                        retarr[1] = this.Subtract(retarr[0].Multiply(retarr[0]));
                    }
                }
                return retarr;
            }
            bigintX = EInteger.Zero;
            bigintY = EInteger.One << powerBits;
            do
            {
                bigintX = bigintY;
                // DebugUtility.Log("" + thisValue + " " + bigintX);
                bigintY = thisValue / (EInteger)bigintX;
                bigintY += bigintX;
                bigintY >>= 1;
            } while (bigintY != null && bigintY.CompareTo(bigintX) < 0);
            if (!useRem)
            {
                return new[] { bigintX, null };
            }
            bigintY = bigintX * (EInteger)bigintX;
            bigintY = thisValue - (EInteger)bigintY;
            return new[] {
        bigintX, bigintY };
        }
        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToByteChecked"]/*'/>
        public byte ToByteChecked()
        {
            int val = this.ToInt32Checked();
            if (val < 0 || val > 255)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((byte)(val & 0xff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToByteUnchecked"]/*'/>
        public byte ToByteUnchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((byte)(val & 0xff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromByte(System.Byte)"]/*'/>
        public static EInteger FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToInt16Checked"]/*'/>
        public short ToInt16Checked()
        {
            int val = this.ToInt32Checked();
            if (val < -32768 || val > 32767)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((short)(val & 0xffff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToInt16Unchecked"]/*'/>
        public short ToInt16Unchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((short)(val & 0xffff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromInt16(System.Int16)"]/*'/>
        public static EInteger FromInt16(short inputInt16)
        {
            int val = (int)inputInt16;
            return FromInt32(val);
        }

        // End integer conversions
    }

    public sealed partial class EInteger
    {
        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromUInt64(System.UInt64)"]/*'/>
        
        public static EInteger FromUInt64(ulong ulongValue)
        {
            if (ulongValue <= Int64.MaxValue)
            {
                return FromInt64((long)ulongValue);
            }
            else
            {
                ulongValue &= (1UL << 63) - 1;
                return EInteger.One.ShiftLeft(63).Add(FromInt64((long)ulongValue));
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Addition(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator +(EInteger bthis, EInteger augend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(augend);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Subtraction(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator -(
         EInteger bthis,
         EInteger subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Multiply(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator *(
          EInteger operand1,
          EInteger operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Division(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator /(
         EInteger dividend,
         EInteger divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Modulus(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator %(
         EInteger dividend,
         EInteger divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_LeftShift(PeterO.Numbers.EInteger,System.Int32)"]/*'/>
        public static EInteger operator <<(EInteger bthis, int bitCount)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.ShiftLeft(bitCount);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger ModPow(
      EInteger bigintValue,
      EInteger pow,
      EInteger mod)
        {
            if (bigintValue == null)
            {
                throw new ArgumentNullException(nameof(bigintValue));
            }
            return bigintValue.ModPow(pow, mod);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_RightShift(PeterO.Numbers.EInteger,System.Int32)"]/*'/>
        public static EInteger operator >>(EInteger bthis, int smallValue)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.ShiftRight(smallValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_UnaryNegation(PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator -(EInteger bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToUInt64Checked"]/*'/>
        
        public ulong ToUInt64Checked()
        {
            if (this.negative || this.wordCount > 4)
            {
                throw new OverflowException("This object's value is out of range");
            }
            long ret = this.ToInt64Unchecked();
            if (this.GetSignedBit(63))
            {
                ret |= 1L << 63;
            }
            return unchecked((ulong)ret);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToUInt64Unchecked"]/*'/>
        
        public ulong ToUInt64Unchecked()
        {
            long ret = this.ToInt64Unchecked();
            if (this.GetSignedBit(63))
            {
                ret |= 1L << 63;
            }
            return unchecked((ulong)ret);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_LessThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static bool operator <(EInteger thisValue, EInteger otherValue)
        {
            return (thisValue == null) ? (otherValue != null) :
              (thisValue.CompareTo(otherValue) < 0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_LessThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static bool operator <=(
        EInteger thisValue,
        EInteger otherValue)
        {
            return (thisValue == null) || (thisValue.CompareTo(otherValue) <= 0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_GreaterThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static bool operator >(EInteger thisValue, EInteger otherValue)
        {
            return (thisValue != null) && (thisValue.CompareTo(otherValue) > 0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_GreaterThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static bool operator >=(
        EInteger thisValue,
        EInteger otherValue)
        {
            return (thisValue == null) ? (otherValue == null) :
              (thisValue.CompareTo(otherValue) >= 0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_OnesComplement(PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator ~(
        EInteger thisValue)
        {
            return Not(thisValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_BitwiseAnd(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator &(
        EInteger thisValue,
        EInteger otherValue)
        {
            return And(thisValue, otherValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_BitwiseOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator |(
        EInteger thisValue,
        EInteger otherValue)
        {
            return Or(thisValue, otherValue);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_ExclusiveOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger operator ^(
        EInteger a,
        EInteger b)
        {
            return Xor(a, b);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.GetBits(System.Int32,System.Int32)"]/*'/>
        public long GetBits(int index, int numberBits)
        {
            if (numberBits < 0 || numberBits > 64)
            {
                throw new ArgumentOutOfRangeException("numberBits");
            }
            long v = 0;
            for (int j = 0; j < numberBits; ++j)
            {
                v |= (long)(this.GetSignedBit((int)(index + j)) ? 1 : 0) << j;
            }
            return v;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger@)"]/*'/>
        [Obsolete("Use the DivRem instance method instead.")]
        public static EInteger DivRem(
      EInteger dividend,
      EInteger divisor,
      out EInteger remainder)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            EInteger[] result = dividend.DivRem(divisor);
            remainder = result[1];
            return result[0];
        }

        private static void OrWords(short[] r, short[] a, short[] b, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(a[i] | b[i]));
            }
        }

        private static void XorWords(short[] r, short[] a, short[] b, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(a[i] ^ b[i]));
            }
        }

        private static void NotWords(short[] r, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(~r[i]));
            }
        }

        private static void AndWords(short[] r, short[] a, short[] b, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(a[i] & b[i]));
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Equals(PeterO.Numbers.EInteger)"]/*'/>
        public bool Equals(EInteger other)
        {
            return (other != null) && (this.CompareTo(other) == 0);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Not(PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger Not(EInteger valueA)
        {
            if (valueA == null)
            {
                throw new ArgumentNullException(nameof(valueA));
            }
            if (valueA.wordCount == 0)
            {
                return EInteger.FromInt32(-1);
            }
            bool valueXaNegative = false; int valueXaWordCount = 0;
            short[] valueXaReg = new short[valueA.wordCount];
            Array.Copy(valueA.words, valueXaReg, valueXaReg.Length);
            valueXaWordCount = valueA.wordCount;
            if (valueA.negative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            NotWords(valueXaReg, (int)valueXaReg.Length);
            if (valueA.negative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            valueXaNegative = !valueA.negative;
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : (new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.And(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger And(EInteger a, EInteger b)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (b.IsZero || a.IsZero)
            {
                return Zero;
            }
            bool valueXaNegative = false; int valueXaWordCount = 0;
            short[] valueXaReg = new short[a.wordCount];
            Array.Copy(a.words, valueXaReg, valueXaReg.Length);
            bool valueXbNegative = false;
            short[] valueXbReg = new short[b.wordCount];
            Array.Copy(b.words, valueXbReg, valueXbReg.Length);
            valueXaNegative = a.negative;
            valueXaWordCount = a.wordCount;
            valueXbNegative = b.negative;
            valueXaReg = CleanGrow(
        valueXaReg,
        Math.Max(valueXaReg.Length, valueXbReg.Length));
            valueXbReg = CleanGrow(
        valueXbReg,
        Math.Max(valueXaReg.Length, valueXbReg.Length));
            if (valueXaNegative)
            {
                {
                    TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
                }
            }
            if (valueXbNegative)
            {
                {
                    TwosComplement(valueXbReg, 0, (int)valueXbReg.Length);
                }
            }
            valueXaNegative &= valueXbNegative;
            AndWords(valueXaReg, valueXaReg, valueXbReg, (int)valueXaReg.Length);
            if (valueXaNegative)
            {
                {
                    TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
                }
            }
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : (new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Or(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger Or(EInteger first, EInteger second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            if (first.wordCount == 0)
            {
                return second;
            }
            if (second.wordCount == 0)
            {
                return first;
            }
            bool valueXaNegative = false; int valueXaWordCount = 0;
            short[] valueXaReg = new short[first.wordCount];
            Array.Copy(first.words, valueXaReg, valueXaReg.Length);
            bool valueXbNegative = false;
            short[] valueXbReg = new short[second.wordCount];
            Array.Copy(second.words, valueXbReg, valueXbReg.Length);
            valueXaNegative = first.negative;
            valueXaWordCount = first.wordCount;
            valueXbNegative = second.negative;
            valueXaReg = CleanGrow(
        valueXaReg,
        Math.Max(valueXaReg.Length, valueXbReg.Length));
            valueXbReg = CleanGrow(
        valueXbReg,
        Math.Max(valueXaReg.Length, valueXbReg.Length));
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            if (valueXbNegative)
            {
                TwosComplement(valueXbReg, 0, (int)valueXbReg.Length);
            }
            valueXaNegative |= valueXbNegative;
            OrWords(valueXaReg, valueXaReg, valueXbReg, (int)valueXaReg.Length);
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : (new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.Xor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static EInteger Xor(EInteger a, EInteger b)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (a == b)
            {
                return EInteger.Zero;
            }
            if (a.wordCount == 0)
            {
                return b;
            }
            if (b.wordCount == 0)
            {
                return a;
            }
            bool valueXaNegative = false; int valueXaWordCount = 0;
            short[] valueXaReg = new short[a.wordCount];
            Array.Copy(a.words, valueXaReg, valueXaReg.Length);
            bool valueXbNegative = false;
            short[] valueXbReg = new short[b.wordCount];
            Array.Copy(b.words, valueXbReg, valueXbReg.Length);
            valueXaNegative = a.negative;
            valueXaWordCount = a.wordCount;
            valueXbNegative = b.negative;
            valueXaReg = CleanGrow(
        valueXaReg,
        Math.Max(valueXaReg.Length, valueXbReg.Length));
            valueXbReg = CleanGrow(
        valueXbReg,
        Math.Max(valueXaReg.Length, valueXbReg.Length));
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            if (valueXbNegative)
            {
                TwosComplement(valueXbReg, 0, (int)valueXbReg.Length);
            }
            valueXaNegative ^= valueXbNegative;
            XorWords(valueXaReg, valueXaReg, valueXbReg, (int)valueXaReg.Length);
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : (new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative));
        }
        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Byte"]/*'/>
        public static explicit operator byte(EInteger input)
        {
            return input.ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.Byte)~PeterO.Numbers.EInteger"]/*'/>
        public static implicit operator EInteger(byte inputByte)
        {
            return EInteger.FromByte(inputByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToSByteChecked"]/*'/>
        
        public sbyte ToSByteChecked()
        {
            int val = this.ToInt32Checked();
            if (val < -128 || val > 127)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((sbyte)(val & 0xff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToSByteUnchecked"]/*'/>
        
        public sbyte ToSByteUnchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((sbyte)(val & 0xff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromSByte(System.SByte)"]/*'/>
        
        public static EInteger FromSByte(sbyte inputSByte)
        {
            int val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.SByte"]/*'/>
        
        public static explicit operator sbyte(EInteger input)
        {
            return input.ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.SByte)~PeterO.Numbers.EInteger"]/*'/>
        
        public static implicit operator EInteger(sbyte inputSByte)
        {
            return EInteger.FromSByte(inputSByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int16"]/*'/>
        public static explicit operator short(EInteger input)
        {
            return input.ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int16)~PeterO.Numbers.EInteger"]/*'/>
        public static implicit operator EInteger(short inputInt16)
        {
            return EInteger.FromInt16(inputInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToUInt16Checked"]/*'/>
        
        public ushort ToUInt16Checked()
        {
            int val = this.ToInt32Checked();
            if (val < 0 || val > 65535)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((ushort)(val & 0xffff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToUInt16Unchecked"]/*'/>
        
        public ushort ToUInt16Unchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((ushort)(val & 0xffff));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromUInt16(System.UInt16)"]/*'/>
        public static EInteger FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt16"]/*'/>
        
        public static explicit operator ushort(EInteger input)
        {
            return input.ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt16)~PeterO.Numbers.EInteger"]/*'/>
        
        public static implicit operator EInteger(ushort inputUInt16)
        {
            return EInteger.FromUInt16(inputUInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int32"]/*'/>
        public static explicit operator int(EInteger input)
        {
            return input.ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int32)~PeterO.Numbers.EInteger"]/*'/>
        public static implicit operator EInteger(int inputInt32)
        {
            return EInteger.FromInt32(inputInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToUInt32Checked"]/*'/>
        public uint ToUInt32Checked()
        {
            long val = this.ToInt64Checked();
            if (val < 0 || val > 4294967295L)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((uint)(val & 0xffffffffL));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.ToUInt32Unchecked"]/*'/>
        public uint ToUInt32Unchecked()
        {
            long val = this.ToInt64Unchecked();
            return unchecked((uint)(val & 0xffffffffL));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.FromUInt32(System.UInt32)"]/*'/>
        public static EInteger FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt32"]/*'/>
        
        public static explicit operator uint(EInteger input)
        {
            return input.ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt32)~PeterO.Numbers.EInteger"]/*'/>
        
        public static implicit operator EInteger(uint inputUInt32)
        {
            return EInteger.FromUInt32(inputUInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int64"]/*'/>
        public static explicit operator long(EInteger input)
        {
            return input.ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int64)~PeterO.Numbers.EInteger"]/*'/>
        public static implicit operator EInteger(long inputInt64)
        {
            return EInteger.FromInt64(inputInt64);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt64"]/*'/>
        
        public static explicit operator ulong(EInteger input)
        {
            return input.ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt64)~PeterO.Numbers.EInteger"]/*'/>
        
        public static implicit operator EInteger(ulong inputUInt64)
        {
            return EInteger.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.ERational"]/*'/>
    public sealed partial class ERational : IComparable<ERational>,
      IEquatable<ERational>
    {
        private const int MaxSafeInt = 214748363;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.NaN"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational NaN = CreateWithFlags(
      EInteger.Zero,
      EInteger.One,
      BigNumberFlags.FlagQuietNaN);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.NegativeInfinity"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational NegativeInfinity =
          CreateWithFlags(
      EInteger.Zero,
      EInteger.One,
      BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.NegativeZero"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational NegativeZero =
          FromEInteger(EInteger.Zero).ChangeSign(false);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.One"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational One = FromEInteger(EInteger.One);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.PositiveInfinity"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational PositiveInfinity =
          CreateWithFlags(
      EInteger.Zero,
      EInteger.One,
      BigNumberFlags.FlagInfinity);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.SignalingNaN"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational SignalingNaN =
          CreateWithFlags(
      EInteger.Zero,
      EInteger.One,
      BigNumberFlags.FlagSignalingNaN);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.Ten"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational Ten = FromEInteger((EInteger)10);

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERational.Zero"]/*'/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Security",
          "CA2104",
          Justification = "ERational is immutable")]
        public static readonly ERational Zero = FromEInteger(EInteger.Zero);

        private EInteger denominator;

        private int flags;
        private EInteger unsignedNumerator;

        private ERational()
        {
        }

        private void Initialize(EInteger numerator, EInteger denominator)
        {
            if (numerator == null)
            {
                throw new ArgumentNullException(nameof(numerator));
            }
            if (denominator == null)
            {
                throw new ArgumentNullException(nameof(denominator));
            }
            if (denominator.IsZero)
            {
                throw new ArgumentException("denominator is zero");
            }
            bool numNegative = numerator.Sign < 0;
            bool denNegative = denominator.Sign < 0;
            this.flags = (numNegative != denNegative) ?
                    BigNumberFlags.FlagNegative : 0;
            if (numNegative)
            {
                numerator = -numerator;
            }
            if (denNegative)
            {
                denominator = -denominator;
            }
#if DEBUG
            if (denominator.IsZero)
            {
                throw new ArgumentException("doesn't satisfy !denominator.IsZero");
            }
#endif
            this.unsignedNumerator = numerator;
            this.denominator = denominator;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.#ctor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        [Obsolete("Use the ERational.Create method instead. This constructor will be private or unavailable in version 1.0.")]
        public ERational(EInteger numerator, EInteger denominator)
        {
            this.Initialize(numerator, denominator);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ERational.Denominator"]/*'/>
        public EInteger Denominator
        {
            get
            {
                return this.denominator;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ERational.IsFinite"]/*'/>
        public bool IsFinite
        {
            get
            {
                return !this.IsNaN() && !this.IsInfinity();
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ERational.IsNegative"]/*'/>
        public bool IsNegative
        {
            get
            {
                return (this.flags & BigNumberFlags.FlagNegative) != 0;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ERational.IsZero"]/*'/>
        public bool IsZero
        {
            get
            {
                return ((this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNaN)) == 0) && this.unsignedNumerator.IsZero;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ERational.Numerator"]/*'/>
        public EInteger Numerator
        {
            get
            {
                return this.IsNegative ? (-(EInteger)this.unsignedNumerator) :
                  this.unsignedNumerator;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ERational.Sign"]/*'/>
        public int Sign
        {
            get
            {
                return ((this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNaN)) != 0) ? (this.IsNegative ? -1 : 1) :
                  (this.unsignedNumerator.IsZero ? 0 : (this.IsNegative ? -1 : 1));
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ERational.UnsignedNumerator"]/*'/>
        public EInteger UnsignedNumerator
        {
            get
            {
                return this.unsignedNumerator;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Create(System.Int32,System.Int32)"]/*'/>
        public static ERational Create(
      int numeratorSmall,
      int denominatorSmall)
        {
            return Create((EInteger)numeratorSmall, (EInteger)denominatorSmall);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"]/*'/>
        public static ERational Create(
      EInteger numerator,
      EInteger denominator)
        {
            ERational er = new ERational();
            er.Initialize(numerator, denominator);
            return er;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger)"]/*'/>
        public static ERational CreateNaN(EInteger diag)
        {
            return CreateNaN(diag, false, false);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean)"]/*'/>
        public static ERational CreateNaN(
      EInteger diag,
      bool signaling,
      bool negative)
        {
            if (diag == null)
            {
                throw new ArgumentNullException(nameof(diag));
            }
            if (diag.Sign < 0)
            {
                throw new
          ArgumentException("Diagnostic information must be 0 or greater, was: " +
                  diag);
            }
            if (diag.IsZero && !negative)
            {
                return signaling ? SignalingNaN : NaN;
            }
            int flags = 0;
            if (negative)
            {
                flags |= BigNumberFlags.FlagNegative;
            }
            flags |= signaling ? BigNumberFlags.FlagSignalingNaN :
              BigNumberFlags.FlagQuietNaN;
            ERational er = ERational.Create(diag, EInteger.One);
            er.flags = flags;
            return er;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromDouble(System.Double)"]/*'/>
        public static ERational FromDouble(double flt)
        {
            return FromEFloat(EFloat.FromDouble(flt));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromExtendedDecimal(PeterO.Numbers.EDecimal)"]/*'/>
        [Obsolete("Renamed to FromEDecimal.")]
        public static ERational FromExtendedDecimal(EDecimal ef)
        {
            return FromEDecimal(ef);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromExtendedFloat(PeterO.Numbers.EFloat)"]/*'/>
        [Obsolete("Renamed to FromEFloat.")]
        public static ERational FromExtendedFloat(EFloat ef)
        {
            return FromEFloat(ef);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromEDecimal(PeterO.Numbers.EDecimal)"]/*'/>
        public static ERational FromEDecimal(EDecimal ef)
        {
            if (ef == null)
            {
                throw new ArgumentNullException(nameof(ef));
            }
            if (!ef.IsFinite)
            {
                ERational er = ERational.Create(ef.Mantissa, EInteger.One);
                int flags = 0;
                if (ef.IsNegative)
                {
                    flags |= BigNumberFlags.FlagNegative;
                }
                if (ef.IsInfinity())
                {
                    flags |= BigNumberFlags.FlagInfinity;
                }
                if (ef.IsSignalingNaN())
                {
                    flags |= BigNumberFlags.FlagSignalingNaN;
                }
                if (ef.IsQuietNaN())
                {
                    flags |= BigNumberFlags.FlagQuietNaN;
                }
                er.flags = flags;
                return er;
            }
            EInteger num = ef.Mantissa;
            EInteger exp = ef.Exponent;
            if (exp.IsZero)
            {
                return FromEInteger(num);
            }
            bool neg = num.Sign < 0;
            num = num.Abs();
            EInteger den = EInteger.One;
            if (exp.Sign < 0)
            {
                exp = -(EInteger)exp;
                den = NumberUtility.FindPowerOfTenFromBig(exp);
            }
            else
            {
                EInteger powerOfTen = NumberUtility.FindPowerOfTenFromBig(exp);
                num *= (EInteger)powerOfTen;
            }
            if (neg)
            {
                num = -(EInteger)num;
            }
            return ERational.Create(num, den);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromEFloat(PeterO.Numbers.EFloat)"]/*'/>
        public static ERational FromEFloat(EFloat ef)
        {
            if (ef == null)
            {
                throw new ArgumentNullException(nameof(ef));
            }
            if (!ef.IsFinite)
            {
                ERational er = ERational.Create(ef.Mantissa, EInteger.One);
                int flags = 0;
                if (ef.IsNegative)
                {
                    flags |= BigNumberFlags.FlagNegative;
                }
                if (ef.IsInfinity())
                {
                    flags |= BigNumberFlags.FlagInfinity;
                }
                if (ef.IsSignalingNaN())
                {
                    flags |= BigNumberFlags.FlagSignalingNaN;
                }
                if (ef.IsQuietNaN())
                {
                    flags |= BigNumberFlags.FlagQuietNaN;
                }
                er.flags = flags;
                return er;
            }
            EInteger num = ef.Mantissa;
            EInteger exp = ef.Exponent;
            if (exp.IsZero)
            {
                return FromEInteger(num);
            }
            bool neg = num.Sign < 0;
            num = num.Abs();
            EInteger den = EInteger.One;
            if (exp.Sign < 0)
            {
                exp = -(EInteger)exp;
                den = NumberUtility.ShiftLeft(den, exp);
            }
            else
            {
                num = NumberUtility.ShiftLeft(num, exp);
            }
            if (neg)
            {
                num = -(EInteger)num;
            }
            return ERational.Create(num, den);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromEInteger(PeterO.Numbers.EInteger)"]/*'/>
        public static ERational FromEInteger(EInteger bigint)
        {
            return ERational.Create(bigint, EInteger.One);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromSingle(System.Single)"]/*'/>
        public static ERational FromSingle(float flt)
        {
            return FromEFloat(EFloat.FromSingle(flt));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromString(System.String)"]/*'/>
        public static ERational FromString(string str)
        {
            return FromString(str, 0, str == null ? 0 : str.Length);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromString(System.String,System.Int32,System.Int32)"]/*'/>
        public static ERational FromString(
          string str,
          int offset,
          int length)
        {
            int tmpoffset = offset;
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset (" + tmpoffset + ") is less than " +
                            "0");
            }
            if (tmpoffset > str.Length)
            {
                throw new FormatException("offset (" + tmpoffset + ") is more than " +
                            str.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length (" + length + ") is less than " +
                            "0");
            }
            if (length > str.Length)
            {
                throw new FormatException("length (" + length + ") is more than " +
                            str.Length);
            }
            if (str.Length - tmpoffset < length)
            {
                throw new FormatException("str's length minus " + tmpoffset + " (" +
                            (str.Length - tmpoffset) + ") is less than " + length);
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            bool negative = false;
            int endStr = tmpoffset + length;
            if (str[0] == '+' || str[0] == '-')
            {
                negative = str[0] == '-';
                ++tmpoffset;
            }
            int numerInt = 0;
            FastInteger numer = null;
            int numerBuffer = 0;
            int numerBufferMult = 1;
            int denomBuffer = 0;
            int denomBufferMult = 1;
            bool haveDigits = false;
            bool haveDenominator = false;
            int ndenomInt = 0;
            FastInteger ndenom = null;
            int i = tmpoffset;
            if (i + 8 == endStr)
            {
                if ((str[i] == 'I' || str[i] == 'i') &&
                    (str[i + 1] == 'N' || str[i + 1] == 'n') &&
                    (str[i + 2] == 'F' || str[i + 2] == 'f') &&
                    (str[i + 3] == 'I' || str[i + 3] == 'i') && (str[i + 4] == 'N' ||
                            str[i + 4] == 'n') && (str[i + 5] ==
                            'I' || str[i + 5] == 'i') &&
                    (str[i + 6] == 'T' || str[i + 6] == 't') && (str[i + 7] == 'Y' ||
                            str[i + 7] == 'y'))
                {
                    return negative ? NegativeInfinity : PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((str[i] == 'I' || str[i] == 'i') &&
                    (str[i + 1] == 'N' || str[i + 1] == 'n') && (str[i + 2] == 'F' ||
                            str[i + 2] == 'f'))
                {
                    return negative ? NegativeInfinity : PositiveInfinity;
                }
            }
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((str[i] == 'N' || str[i] == 'n') && (str[i + 1] == 'A' || str[i +
                        1] == 'a') && (str[i + 2] == 'N' || str[i + 2] == 'n'))
                {
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? NaN : NaN.Negate();
                    }
                    i += 3;
                    for (; i < endStr; ++i)
                    {
                        if (str[i] >= '0' && str[i] <= '9')
                        {
                            int thisdigit = (int)(str[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (numerInt > MaxSafeInt)
                            {
                                if (numer == null)
                                {
                                    numer = new FastInteger(numerInt);
                                    numerBuffer = thisdigit;
                                    numerBufferMult = 10;
                                }
                                else
                                {
                                    if (numerBufferMult >= 1000000000)
                                    {
                                        numer.Multiply(numerBufferMult).AddInt(numerBuffer);
                                        numerBuffer = thisdigit;
                                        numerBufferMult = 10;
                                    }
                                    else
                                    {
                                        numerBufferMult *= 10;
                                        numerBuffer = (numerBuffer << 3) + (numerBuffer << 1);
                                        numerBuffer += thisdigit;
                                    }
                                }
                            }
                            else
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (numer != null && (numerBufferMult != 1 || numerBuffer != 0))
                    {
                        numer.Multiply(numerBufferMult).AddInt(numerBuffer);
                    }
                    EInteger bignumer = (numer == null) ? ((EInteger)numerInt) :
                      numer.AsEInteger();
                    return CreateNaN(bignumer, false, negative);
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((str[i] == 'S' || str[i] == 's') && (str[i + 1] == 'N' || str[i +
                            1] == 'n') && (str[i + 2] == 'A' || str[i + 2] == 'a') &&
                        (str[i + 3] == 'N' || str[i + 3] == 'n'))
                {
                    if (i + 4 == endStr)
                    {
                        return (!negative) ? SignalingNaN : SignalingNaN.Negate();
                    }
                    i += 4;
                    for (; i < endStr; ++i)
                    {
                        if (str[i] >= '0' && str[i] <= '9')
                        {
                            int thisdigit = (int)(str[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (numerInt > MaxSafeInt)
                            {
                                if (numer == null)
                                {
                                    numer = new FastInteger(numerInt);
                                    numerBuffer = thisdigit;
                                    numerBufferMult = 10;
                                }
                                else
                                {
                                    if (numerBufferMult >= 1000000000)
                                    {
                                        numer.Multiply(numerBufferMult).AddInt(numerBuffer);
                                        numerBuffer = thisdigit;
                                        numerBufferMult = 10;
                                    }
                                    else
                                    {
                                        numerBufferMult *= 10;
                                        numerBuffer = (numerBuffer << 3) + (numerBuffer << 1);
                                        numerBuffer += thisdigit;
                                    }
                                }
                            }
                            else
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (numer != null && (numerBufferMult != 1 || numerBuffer != 0))
                    {
                        numer.Multiply(numerBufferMult).AddInt(numerBuffer);
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    EInteger bignumer = (numer == null) ? ((EInteger)numerInt) :
                      numer.AsEInteger();
                    return CreateWithFlags(
                      bignumer,
                      EInteger.One,
                      flags3);
                }
            }
            // Ordinary number
            for (; i < endStr; ++i)
            {
                if (str[i] >= '0' && str[i] <= '9')
                {
                    int thisdigit = (int)(str[i] - '0');
                    if (numerInt > MaxSafeInt)
                    {
                        if (numer == null)
                        {
                            numer = new FastInteger(numerInt);
                            numerBuffer = thisdigit;
                            numerBufferMult = 10;
                        }
                        else
                        {
                            if (numerBufferMult >= 1000000000)
                            {
                                numer.Multiply(numerBufferMult).AddInt(numerBuffer);
                                numerBuffer = thisdigit;
                                numerBufferMult = 10;
                            }
                            else
                            {
                                // multiply numerBufferMult and numerBuffer each by 10
                                numerBufferMult = (numerBufferMult << 3) + (numerBufferMult <<
                                     1);
                                numerBuffer = (numerBuffer << 3) + (numerBuffer << 1);
                                numerBuffer += thisdigit;
                            }
                        }
                    }
                    else
                    {
                        numerInt *= 10;
                        numerInt += thisdigit;
                    }
                    haveDigits = true;
                }
                else if (str[i] == '/')
                {
                    haveDenominator = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (numer != null && (numerBufferMult != 1 || numerBuffer != 0))
            {
                numer.Multiply(numerBufferMult).AddInt(numerBuffer);
            }
            if (haveDenominator)
            {
                FastInteger denom = null;
                int denomInt = 0;
                tmpoffset = 1;
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                for (; i < endStr; ++i)
                {
                    if (str[i] >= '0' && str[i] <= '9')
                    {
                        haveDigits = true;
                        int thisdigit = (int)(str[i] - '0');
                        if (denomInt > MaxSafeInt)
                        {
                            if (denom == null)
                            {
                                denom = new FastInteger(denomInt);
                                denomBuffer = thisdigit;
                                denomBufferMult = 10;
                            }
                            else
                            {
                                if (denomBufferMult >= 1000000000)
                                {
                                    denom.Multiply(denomBufferMult).AddInt(denomBuffer);
                                    denomBuffer = thisdigit;
                                    denomBufferMult = 10;
                                }
                                else
                                {
                                    // multiply denomBufferMult and denomBuffer each by 10
                                    denomBufferMult = (denomBufferMult << 3) + (denomBufferMult <<
                                           1);
                                    denomBuffer = (denomBuffer << 3) + (denomBuffer << 1);
                                    denomBuffer += thisdigit;
                                }
                            }
                        }
                        else
                        {
                            denomInt *= 10;
                            denomInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                if (denom != null && (denomBufferMult != 1 || denomBuffer != 0))
                {
                    denom.Multiply(denomBufferMult).AddInt(denomBuffer);
                }
                if (denom == null)
                {
                    ndenomInt = denomInt;
                }
                else
                {
                    ndenom = denom;
                }
            }
            else
            {
                ndenomInt = 1;
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (ndenom == null ? (ndenomInt == 0) : ndenom.IsValueZero)
            {
                throw new FormatException();
            }
            ERational erat = Create(
              numer == null ? (EInteger)numerInt : numer.AsEInteger(),
              ndenom == null ? (EInteger)ndenomInt : ndenom.AsEInteger());
            return negative ? erat.Negate() : erat;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CompareToTotalMagnitude(PeterO.Numbers.ERational)"]/*'/>
        public int CompareToTotalMagnitude(ERational other)
        {
            if (other == null)
            {
                return -1;
            }
            int valueIThis = 0;
            int valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return 1;
            }
            else if (valueIThis < valueIOther)
            {
                return -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedNumerator.CompareTo(
                 other.unsignedNumerator);
                return cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.Abs().CompareTo(other.Abs());
                if (cmp == 0)
                {
                    cmp = this.denominator.CompareTo(
                     other.denominator);
                    return cmp;
                }
                return cmp;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CompareToTotal(PeterO.Numbers.ERational)"]/*'/>
        public int CompareToTotal(ERational other)
        {
            if (other == null)
            {
                return -1;
            }
            bool neg1 = this.IsNegative;
            bool neg2 = other.IsNegative;
            if (neg1 != neg2)
            {
                return neg1 ? -1 : 1;
            }
            int valueIThis = 0;
            int valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return neg1 ? -1 : 1;
            }
            else if (valueIThis < valueIOther)
            {
                return neg1 ? 1 : -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedNumerator.CompareTo(
                 other.unsignedNumerator);
                return neg1 ? -cmp : cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.CompareTo(other);
                if (cmp == 0)
                {
                    cmp = this.denominator.CompareTo(
                     other.denominator);
                    return neg1 ? -cmp : cmp;
                }
                return cmp;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Abs"]/*'/>
        public ERational Abs()
        {
            if (this.IsNegative)
            {
                ERational er = ERational.Create(
             this.unsignedNumerator,
             this.denominator);
                er.flags = this.flags & ~BigNumberFlags.FlagNegative;
                return er;
            }
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Add(PeterO.Numbers.ERational)"]/*'/>
        public ERational Add(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.unsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
              otherValue.unsignedNumerator,
              false,
              otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            if (this.IsInfinity())
            {
                return otherValue.IsInfinity() ? ((this.IsNegative ==
                  otherValue.IsNegative) ? this : NaN) : this;
            }
            if (otherValue.IsInfinity())
            {
                return otherValue;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            EInteger bd = this.Denominator * (EInteger)otherValue.Denominator;
            ad += (EInteger)bc;
            return ERational.Create(ad, bd);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CompareTo(PeterO.Numbers.ERational)"]/*'/>
        public int CompareTo(ERational other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this == other)
            {
                return 0;
            }
            if (this.IsNaN())
            {
                return other.IsNaN() ? 0 : 1;
            }
            if (other.IsNaN())
            {
                return -1;
            }
            int signA = this.Sign;
            int signB = other.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (this.IsInfinity())
            {
                if (other.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return this.IsNegative ? -1 : 1;
            }
            if (other.IsInfinity())
            {
                return other.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!this.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy this.IsFinite");
            }
            if (!other.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy other.IsFinite");
            }
#endif

            int dencmp = this.denominator.CompareTo(other.denominator);
            // At this point, the signs are equal so we can compare
            // their absolute values instead
            int numcmp = this.unsignedNumerator.CompareTo(other.unsignedNumerator);
            if (signA < 0)
            {
                numcmp = -numcmp;
            }
            if (numcmp == 0)
            {
                // Special case: numerators are equal, so the
                // number with the lower denominator is greater
                return signA < 0 ? dencmp : -dencmp;
            }
            if (dencmp == 0)
            {
                // denominators are equal
                return numcmp;
            }
            EInteger ad = this.Numerator * (EInteger)other.Denominator;
            EInteger bc = this.Denominator * (EInteger)other.Numerator;
            return ad.CompareTo(bc);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CompareToBinary(PeterO.Numbers.EFloat)"]/*'/>
        public int CompareToBinary(EFloat other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsNaN())
            {
                return other.IsNaN() ? 0 : 1;
            }
            int signA = this.Sign;
            int signB = other.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (this.IsInfinity())
            {
                if (other.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return this.IsNegative ? -1 : 1;
            }
            if (other.IsInfinity())
            {
                return other.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!this.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy this.IsFinite");
            }
            if (!other.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy other.IsFinite");
            }
#endif
            EInteger bigExponent = other.Exponent;
            if (bigExponent.IsZero)
            {
                // Special case: other has exponent 0
                EInteger otherMant = other.Mantissa;
                EInteger bcx = this.Denominator * (EInteger)otherMant;
                return this.Numerator.CompareTo(bcx);
            }
            if (bigExponent.Abs().CompareTo((EInteger)1000) > 0)
            {
                // Other has a high absolute value of exponent, so try different
                // approaches to
                // comparison
                EInteger thisRem;
                EInteger thisInt;
                {
                    EInteger[] divrem = this.UnsignedNumerator.DivRem(this.Denominator);
                    thisInt = divrem[0];
                    thisRem = divrem[1];
                }
                EFloat otherAbs = other.Abs();
                EFloat thisIntDec = EFloat.FromEInteger(thisInt);
                if (thisRem.IsZero)
                {
                    // This object's value is an integer
                    // Console.WriteLine("Shortcircuit IV");
                    int ret = thisIntDec.CompareTo(otherAbs);
                    return this.IsNegative ? -ret : ret;
                }
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit I");
                    return this.IsNegative ? -1 : 1;
                }
                // Round up
                thisInt = thisInt.Add(EInteger.One);
                thisIntDec = EFloat.FromEInteger(thisInt);
                if (thisIntDec.CompareTo(otherAbs) < 0)
                {
                    // Absolute value rounded up is less than other's unrounded
                    // absolute value
                    // Console.WriteLine("Shortcircuit II");
                    return this.IsNegative ? 1 : -1;
                }
                thisIntDec = EFloat.FromEInteger(this.UnsignedNumerator).Divide(
                    EFloat.FromEInteger(this.Denominator),
                    EContext.ForPrecisionAndRounding(256, ERounding.Down));
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit III");
                    return this.IsNegative ? -1 : 1;
                }
                if (other.Exponent.Sign > 0)
                {
                    // NOTE: if unsigned numerator is 0, bitLength will return
                    // 0 instead of 1, but the possibility of 0 was already excluded
                    int digitCount = this.UnsignedNumerator.GetSignedBitLength();
                    --digitCount;
                    EInteger bigDigitCount = (EInteger)digitCount;
                    if (bigDigitCount.CompareTo(other.Exponent) < 0)
                    {
                        // Numerator's digit count minus 1 is less than the other' s
                        // exponent,
                        // and other's exponent is positive, so this value's absolute
                        // value is less
                        return this.IsNegative ? 1 : -1;
                    }
                }
            }
            // Convert to rational number and use usual rational number
            // comparison
            // Console.WriteLine("no shortcircuit");
            // Console.WriteLine(this);
            // Console.WriteLine(other);
            ERational otherRational = ERational.FromEFloat(other);
            EInteger ad = this.Numerator * (EInteger)otherRational.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherRational.Numerator;
            return ad.CompareTo(bc);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CompareToDecimal(PeterO.Numbers.EDecimal)"]/*'/>
        public int CompareToDecimal(EDecimal other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsNaN())
            {
                return other.IsNaN() ? 0 : 1;
            }
            int signA = this.Sign;
            int signB = other.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (this.IsInfinity())
            {
                if (other.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return this.IsNegative ? -1 : 1;
            }
            if (other.IsInfinity())
            {
                return other.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!this.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy this.IsFinite");
            }
            if (!other.IsFinite)
            {
                throw new ArgumentException("doesn't satisfy other.IsFinite");
            }
#endif

            if (other.Exponent.IsZero)
            {
                // Special case: other has exponent 0
                EInteger otherMant = other.Mantissa;
                EInteger bcx = this.Denominator * (EInteger)otherMant;
                return this.Numerator.CompareTo(bcx);
            }
            if (other.Exponent.Abs().CompareTo((EInteger)50) > 0)
            {
                // Other has a high absolute value of exponent, so try different
                // approaches to
                // comparison
                EInteger thisRem;
                EInteger thisInt;
                {
                    EInteger[] divrem = this.UnsignedNumerator.DivRem(this.Denominator);
                    thisInt = divrem[0];
                    thisRem = divrem[1];
                }
                EDecimal otherAbs = other.Abs();
                EDecimal thisIntDec = EDecimal.FromEInteger(thisInt);
                if (thisRem.IsZero)
                {
                    // This object's value is an integer
                    // Console.WriteLine("Shortcircuit IV");
                    int ret = thisIntDec.CompareTo(otherAbs);
                    return this.IsNegative ? -ret : ret;
                }
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit I");
                    return this.IsNegative ? -1 : 1;
                }
                // Round up
                thisInt = thisInt.Add(EInteger.One);
                thisIntDec = EDecimal.FromEInteger(thisInt);
                if (thisIntDec.CompareTo(otherAbs) < 0)
                {
                    // Absolute value rounded up is less than other's unrounded
                    // absolute value
                    // Console.WriteLine("Shortcircuit II");
                    return this.IsNegative ? 1 : -1;
                }
                // Conservative approximation of this rational number's absolute value,
                // as a decimal number. The true value will be greater or equal.
                thisIntDec = EDecimal.FromEInteger(this.UnsignedNumerator).Divide(
                      EDecimal.FromEInteger(this.Denominator),
                      EContext.ForPrecisionAndRounding(20, ERounding.Down));
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit III");
                    return this.IsNegative ? -1 : 1;
                }
                // Console.WriteLine("---" + this + " " + other);
                if (other.Exponent.Sign > 0)
                {
                    int digitCount = this.UnsignedNumerator.GetDigitCount();
                    --digitCount;
                    EInteger bigDigitCount = (EInteger)digitCount;
                    if (bigDigitCount.CompareTo(other.Exponent) < 0)
                    {
                        // Numerator's digit count minus 1 is less than the other' s
                        // exponent,
                        // and other's exponent is positive, so this value's absolute
                        // value is less
                        return this.IsNegative ? 1 : -1;
                    }
                }
            }
            // Convert to rational number and use usual rational number
            // comparison
            // Console.WriteLine("no shortcircuit");
            // Console.WriteLine(this);
            // Console.WriteLine(other);
            ERational otherRational = ERational.FromEDecimal(other);
            EInteger ad = this.Numerator * (EInteger)otherRational.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherRational.Numerator;
            return ad.CompareTo(bc);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.CopySign(PeterO.Numbers.ERational)"]/*'/>
        public ERational CopySign(ERational other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (this.IsNegative)
            {
                return other.IsNegative ? this : this.Negate();
            }
            else
            {
                return other.IsNegative ? this.Negate() : this;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Divide(PeterO.Numbers.ERational)"]/*'/>
        public ERational Divide(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.unsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
              otherValue.unsignedNumerator,
              false,
              otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            bool resultNeg = this.IsNegative ^ otherValue.IsNegative;
            if (this.IsInfinity())
            {
                return otherValue.IsInfinity() ? NaN : (resultNeg ? NegativeInfinity :
                  PositiveInfinity);
            }
            if (otherValue.IsInfinity())
            {
                return resultNeg ? NegativeZero : Zero;
            }
            if (otherValue.IsZero)
            {
                return this.IsZero ? NaN : (resultNeg ? NegativeInfinity :
                        PositiveInfinity);
            }
            if (this.IsZero)
            {
                return resultNeg ? NegativeZero : Zero;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            return ERational.Create(ad, bc).ChangeSign(resultNeg);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Equals(System.Object)"]/*'/>
        public override bool Equals(object obj)
        {
            return (
obj is ERational other) && (
        Object.Equals(
        this.unsignedNumerator,
        other.unsignedNumerator) && Object.Equals(
        this.denominator,
        other.denominator) && this.flags == other.flags);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Equals(PeterO.Numbers.ERational)"]/*'/>
        public bool Equals(ERational other)
        {
            return this.Equals((object)other);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.GetHashCode"]/*'/>
        public override int GetHashCode()
        {
            int hashCode = 1857066527;
            unchecked
            {
                if (this.unsignedNumerator != null)
                {
                    hashCode += 1857066539 * this.unsignedNumerator.GetHashCode();
                }
                if (this.denominator != null)
                {
                    hashCode += 1857066551 * this.denominator.GetHashCode();
                }
                hashCode += 1857066623 * this.flags;
            }
            return hashCode;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.IsInfinity"]/*'/>
        public bool IsInfinity()
        {
            return (this.flags & BigNumberFlags.FlagInfinity) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.IsNaN"]/*'/>
        public bool IsNaN()
        {
            return (this.flags & BigNumberFlags.FlagNaN) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.IsNegativeInfinity"]/*'/>
        public bool IsNegativeInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
              BigNumberFlags.FlagNegative)) ==
              (BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.IsPositiveInfinity"]/*'/>
        public bool IsPositiveInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
              BigNumberFlags.FlagNegative)) == BigNumberFlags.FlagInfinity;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.IsQuietNaN"]/*'/>
        public bool IsQuietNaN()
        {
            return (this.flags & BigNumberFlags.FlagQuietNaN) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.IsSignalingNaN"]/*'/>
        public bool IsSignalingNaN()
        {
            return (this.flags & BigNumberFlags.FlagSignalingNaN) != 0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Multiply(PeterO.Numbers.ERational)"]/*'/>
        public ERational Multiply(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.unsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
              otherValue.unsignedNumerator,
              false,
              otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            bool resultNeg = this.IsNegative ^ otherValue.IsNegative;
            if (this.IsInfinity())
            {
                return otherValue.IsZero ? NaN : (resultNeg ? NegativeInfinity :
                  PositiveInfinity);
            }
            if (otherValue.IsInfinity())
            {
                return this.IsZero ? NaN : (resultNeg ? NegativeInfinity :
                        PositiveInfinity);
            }
            EInteger ac = this.Numerator * (EInteger)otherValue.Numerator;
            EInteger bd = this.Denominator * (EInteger)otherValue.Denominator;
            return ac.IsZero ? (resultNeg ? NegativeZero : Zero) :
                     ERational.Create(ac, bd).ChangeSign(resultNeg);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Negate"]/*'/>
        public ERational Negate()
        {
            ERational er = ERational.Create(this.unsignedNumerator, this.denominator);
            er.flags = this.flags ^ BigNumberFlags.FlagNegative;
            return er;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Remainder(PeterO.Numbers.ERational)"]/*'/>
        public ERational Remainder(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.unsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
              otherValue.unsignedNumerator,
              false,
              otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            bool resultNeg = this.IsNegative ^ otherValue.IsNegative;
            if (this.IsInfinity())
            {
                return NaN;
            }
            if (otherValue.IsInfinity())
            {
                return this;
            }
            if (otherValue.IsZero)
            {
                return NaN;
            }
            if (this.IsZero)
            {
                return this;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            EInteger quo = ad / (EInteger)bc;  // Find the integer quotient
            EInteger tnum = quo * (EInteger)otherValue.Numerator;
            EInteger tden = otherValue.Denominator;
            EInteger thisDen = this.Denominator;
            ad = this.Numerator * (EInteger)tden;
            bc = thisDen * (EInteger)tnum;
            tden *= (EInteger)thisDen;
            ad -= (EInteger)bc;
            return ERational.Create(ad, tden).ChangeSign(resultNeg);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.Subtract(PeterO.Numbers.ERational)"]/*'/>
        public ERational Subtract(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.unsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
              otherValue.unsignedNumerator,
              false,
              otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            if (this.IsInfinity())
            {
                if (otherValue.IsInfinity())
                {
                    return (this.IsNegative != otherValue.IsNegative) ?
                      (this.IsNegative ? PositiveInfinity : NegativeInfinity) : NaN;
                }
                return this.IsNegative ? PositiveInfinity : NegativeInfinity;
            }
            if (otherValue.IsInfinity())
            {
                return otherValue.IsNegative ? PositiveInfinity : NegativeInfinity;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            EInteger bd = this.Denominator * (EInteger)otherValue.Denominator;
            ad -= (EInteger)bc;
            return ERational.Create(ad, bd);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToDouble"]/*'/>
        public double ToDouble()
        {
            if (!this.IsFinite)
            {
                return this.ToEFloat(EContext.Binary64).ToDouble();
            }
            if (this.IsNegative && this.IsZero)
            {
                return EFloat.NegativeZero.ToDouble();
            }
            return EFloat.FromEInteger(this.Numerator)
              .Divide(EFloat.FromEInteger(this.denominator), EContext.Binary64)
              .ToDouble();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEInteger"]/*'/>
        public EInteger ToEInteger()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.Numerator / (EInteger)this.denominator;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEIntegerExact"]/*'/>
        [Obsolete("Renamed to ToEIntegerIfExact.")]
        public EInteger ToEIntegerExact()
        {
            return this.ToEIntegerIfExact();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEIntegerIfExact"]/*'/>
        public EInteger ToEIntegerIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            EInteger rem;
            EInteger quo;
            {
                EInteger[] divrem = this.Numerator.DivRem(this.denominator);
                quo = divrem[0];
                rem = divrem[1];
            }
            if (!rem.IsZero)
            {
                throw new ArithmeticException("Value is not an integral value");
            }
            return quo;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEDecimal"]/*'/>
        public EDecimal ToEDecimal()
        {
            return this.ToEDecimal(null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEDecimal(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal ToEDecimal(EContext ctx)
        {
            if (this.IsNaN())
            {
                return EDecimal.CreateNaN(
          this.unsignedNumerator,
          this.IsSignalingNaN(),
          this.IsNegative,
          ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EDecimal.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EDecimal.NegativeInfinity.RoundToPrecision(ctx);
            }
            EDecimal ef = (this.IsNegative && this.IsZero) ?
       EDecimal.NegativeZero : EDecimal.FromEInteger(this.Numerator);
            return ef.Divide(EDecimal.FromEInteger(this.Denominator), ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEDecimalExactIfPossible(PeterO.Numbers.EContext)"]/*'/>
        public EDecimal ToEDecimalExactIfPossible(EContext
              ctx)
        {
            if (ctx == null)
            {
                return this.ToEDecimal(null);
            }
            if (this.IsNaN())
            {
                return EDecimal.CreateNaN(
          this.unsignedNumerator,
          this.IsSignalingNaN(),
          this.IsNegative,
          ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EDecimal.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EDecimal.NegativeInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegative && this.IsZero)
            {
                return EDecimal.NegativeZero;
            }
            EDecimal valueEdNum = (this.IsNegative && this.IsZero) ?
       EDecimal.NegativeZero : EDecimal.FromEInteger(this.Numerator);
            EDecimal valueEdDen = EDecimal.FromEInteger(this.Denominator);
            EDecimal ed = valueEdNum.Divide(valueEdDen, null);
            if (ed.IsNaN())
            {
                // Result would be inexact, try again using the precision context
                ed = valueEdNum.Divide(valueEdDen, ctx);
            }
            return ed;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToExtendedDecimal"]/*'/>
        [Obsolete("Renamed to ToEDecimal.")]
        public EDecimal ToExtendedDecimal()
        {
            return this.ToEDecimal();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToExtendedDecimal(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to ToEDecimal.")]
        public EDecimal ToExtendedDecimal(EContext ctx)
        {
            return this.ToEDecimal(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to ToEDecimalExactIfPossible.")]
        public EDecimal ToExtendedDecimalExactIfPossible(EContext ctx)
        {
            return this.ToEDecimalExactIfPossible(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEFloat"]/*'/>
        public EFloat ToEFloat()
        {
            return this.ToEFloat(null);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEFloat(PeterO.Numbers.EContext)"]/*'/>
        public EFloat ToEFloat(EContext ctx)
        {
            if (this.IsNaN())
            {
                return EFloat.CreateNaN(
          this.unsignedNumerator,
          this.IsSignalingNaN(),
          this.IsNegative,
          ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EFloat.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EFloat.NegativeInfinity.RoundToPrecision(ctx);
            }
            EFloat ef = (this.IsNegative && this.IsZero) ?
           EFloat.NegativeZero : EFloat.FromEInteger(this.Numerator);
            return ef.Divide(EFloat.FromEInteger(this.Denominator), ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToEFloatExactIfPossible(PeterO.Numbers.EContext)"]/*'/>
        public EFloat ToEFloatExactIfPossible(EContext ctx)
        {
            if (ctx == null)
            {
                return this.ToEFloat(null);
            }
            if (this.IsNaN())
            {
                return EFloat.CreateNaN(
          this.unsignedNumerator,
          this.IsSignalingNaN(),
          this.IsNegative,
          ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EFloat.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EFloat.NegativeInfinity.RoundToPrecision(ctx);
            }
            if (this.IsZero)
            {
                return this.IsNegative ? EFloat.NegativeZero :
                    EFloat.Zero;
            }
            EFloat valueEdNum = (this.IsNegative && this.IsZero) ?
           EFloat.NegativeZero : EFloat.FromEInteger(this.Numerator);
            EFloat valueEdDen = EFloat.FromEInteger(this.Denominator);
            EFloat ed = valueEdNum.Divide(valueEdDen, null);
            if (ed.IsNaN())
            {
                // Result would be inexact, try again using the precision context
                ed = valueEdNum.Divide(valueEdDen, ctx);
            }
            return ed;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToExtendedFloat"]/*'/>
        [Obsolete("Renamed to ToEFloat.")]
        public EFloat ToExtendedFloat()
        {
            return this.ToEFloat();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToExtendedFloat(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to ToEFloat.")]
        public EFloat ToExtendedFloat(EContext ctx)
        {
            return this.ToEFloat(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)"]/*'/>
        [Obsolete("Renamed to ToEFloatExactIfPossible.")]
        public EFloat ToExtendedFloatExactIfPossible(EContext ctx)
        {
            return this.ToEFloatExactIfPossible(ctx);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToSingle"]/*'/>
        public float ToSingle()
        {
            return
        this.ToEFloat(EContext.Binary32.WithRounding(ERounding.Odd))
              .ToSingle();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToString"]/*'/>
        public override string ToString()
        {
            if (!this.IsFinite)
            {
                if (this.IsSignalingNaN())
                {
                    if (this.unsignedNumerator.IsZero)
                    {
                        return this.IsNegative ? "-sNaN" : "sNaN";
                    }
                    return this.IsNegative ? "-sNaN" + this.unsignedNumerator :
                        "sNaN" + this.unsignedNumerator;
                }
                if (this.IsQuietNaN())
                {
                    if (this.unsignedNumerator.IsZero)
                    {
                        return this.IsNegative ? "-NaN" : "NaN";
                    }
                    return this.IsNegative ? "-NaN" + this.unsignedNumerator :
                        "NaN" + this.unsignedNumerator;
                }
                if (this.IsInfinity())
                {
                    return this.IsNegative ? "-Infinity" : "Infinity";
                }
            }
            return (this.Numerator.IsZero && this.IsNegative) ? ("-0/" +
              this.Denominator) : (this.Numerator + "/" + this.Denominator);
        }

        private static ERational CreateWithFlags(
      EInteger numerator,
      EInteger denominator,
      int flags)
        {
            ERational er = ERational.Create(numerator, denominator);
            er.flags = flags;
            return er;
        }

        private ERational ChangeSign(bool negative)
        {
            if (negative)
            {
                this.flags |= BigNumberFlags.FlagNegative;
            }
            else
            {
                this.flags &= ~BigNumberFlags.FlagNegative;
            }
            return this;
        }

        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToByteChecked"]/*'/>
        public byte ToByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((byte)0) : this.ToEInteger().ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToByteUnchecked"]/*'/>
        public byte ToByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToByteUnchecked() : (byte)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToByteIfExact"]/*'/>
        public byte ToByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((byte)0) : this.ToEIntegerIfExact().ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromByte(System.Byte)"]/*'/>
        public static ERational FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt16Checked"]/*'/>
        public short ToInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((short)0) : this.ToEInteger().ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt16Unchecked"]/*'/>
        public short ToInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt16Unchecked() : (short)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt16IfExact"]/*'/>
        public short ToInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((short)0) :
              this.ToEIntegerIfExact().ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromInt16(System.Int16)"]/*'/>
        public static ERational FromInt16(short inputInt16)
        {
            int val = (int)inputInt16;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt32Checked"]/*'/>
        public int ToInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((int)0) : this.ToEInteger().ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt32Unchecked"]/*'/>
        public int ToInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt32Unchecked() : (int)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt32IfExact"]/*'/>
        public int ToInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((int)0) : this.ToEIntegerIfExact().ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromInt32(System.Int32)"]/*'/>
        public static ERational FromInt32(int inputInt32)
        {
            return FromEInteger(EInteger.FromInt32(inputInt32));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt64Checked"]/*'/>
        public long ToInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((long)0) : this.ToEInteger().ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt64Unchecked"]/*'/>
        public long ToInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt64Unchecked() : (long)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToInt64IfExact"]/*'/>
        public long ToInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((long)0) : this.ToEIntegerIfExact().ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromInt64(System.Int64)"]/*'/>
        public static ERational FromInt64(long inputInt64)
        {
            return FromEInteger(EInteger.FromInt64(inputInt64));
        }

        // End integer conversions
    }
    public sealed partial class ERational
    {
        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(EInteger eint)
        {
            return FromEInteger(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(EDecimal eint)
        {
            return FromEDecimal(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EFloat)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(EFloat eint)
        {
            return FromEFloat(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromDecimal(System.Decimal)"]/*'/>
        public static ERational FromDecimal(decimal eint)
        {
            return FromEDecimal(EDecimal.FromDecimal(eint));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.Decimal)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(decimal eint)
        {
            return FromDecimal(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.Single)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(float eint)
        {
            return ERational.FromSingle(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.Double)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(double eint)
        {
            return ERational.FromDouble(eint);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Addition(PeterO.Numbers.ERational,PeterO.Numbers.ERational)"]/*'/>
        public static ERational operator +(ERational bthis, ERational augend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(augend);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Subtraction(PeterO.Numbers.ERational,PeterO.Numbers.ERational)"]/*'/>
        public static ERational operator -(
       ERational bthis,
       ERational subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Multiply(PeterO.Numbers.ERational,PeterO.Numbers.ERational)"]/*'/>
        public static ERational operator *(
        ERational operand1,
        ERational operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Division(PeterO.Numbers.ERational,PeterO.Numbers.ERational)"]/*'/>
        public static ERational operator /(
       ERational dividend,
       ERational divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Modulus(PeterO.Numbers.ERational,PeterO.Numbers.ERational)"]/*'/>
        public static ERational operator %(
       ERational dividend,
       ERational divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_UnaryNegation(PeterO.Numbers.ERational)"]/*'/>
        public static ERational operator -(ERational bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToDecimal"]/*'/>
        public decimal ToDecimal()
        {
            ERational extendedNumber = this;
            if (extendedNumber.IsInfinity() || extendedNumber.IsNaN())
            {
                throw new OverflowException("This object's value is out of range");
            }
            try
            {
                EDecimal newDecimal = EDecimal.FromEInteger(extendedNumber.Numerator)
                  .Divide(
          EDecimal.FromEInteger(extendedNumber.Denominator),
          EContext.CliDecimal.WithTraps(EContext.FlagOverflow));
                return (decimal)newDecimal;
            }
            catch (ETrapException ex)
            {
                throw new OverflowException("This object's value is out of range", ex);
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Decimal"]/*'/>
        public static explicit operator decimal(
          ERational extendedNumber)
        {
            return extendedNumber.ToDecimal();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~PeterO.Numbers.EInteger"]/*'/>
        public static explicit operator EInteger(ERational bigValue)
        {
            return bigValue.ToEInteger();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Double"]/*'/>
        public static explicit operator double(ERational bigValue)
        {
            return bigValue.ToDouble();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Single"]/*'/>
        public static explicit operator float(ERational bigValue)
        {
            return bigValue.ToSingle();
        }

        // Begin integer conversions

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Byte"]/*'/>
        public static explicit operator byte(ERational input)
        {
            return input.ToByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.Byte)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(byte inputByte)
        {
            return ERational.FromByte(inputByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToSByteChecked"]/*'/>
        
        public sbyte ToSByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) : this.ToEInteger().ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToSByteUnchecked"]/*'/>
        
        public sbyte ToSByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToSByteUnchecked() : (sbyte)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToSByteIfExact"]/*'/>
        
        public sbyte ToSByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) :
              this.ToEIntegerIfExact().ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromSByte(System.SByte)"]/*'/>
        
        public static ERational FromSByte(sbyte inputSByte)
        {
            int val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.SByte"]/*'/>
        
        public static explicit operator sbyte(ERational input)
        {
            return input.ToSByteChecked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.SByte)~PeterO.Numbers.ERational"]/*'/>
        
        public static implicit operator ERational(sbyte inputSByte)
        {
            return ERational.FromSByte(inputSByte);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int16"]/*'/>
        public static explicit operator short(ERational input)
        {
            return input.ToInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.Int16)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(short inputInt16)
        {
            return ERational.FromInt16(inputInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt16Checked"]/*'/>
        
        public ushort ToUInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ushort)0) : this.ToEInteger().ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt16Unchecked"]/*'/>
        
        public ushort ToUInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt16Unchecked() : (ushort)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt16IfExact"]/*'/>
        
        public ushort ToUInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ushort)0) :
              this.ToEIntegerIfExact().ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromUInt16(System.UInt16)"]/*'/>
        
        public static ERational FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt16"]/*'/>
        
        public static explicit operator ushort(ERational input)
        {
            return input.ToUInt16Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt16)~PeterO.Numbers.ERational"]/*'/>
        
        public static implicit operator ERational(ushort inputUInt16)
        {
            return ERational.FromUInt16(inputUInt16);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int32"]/*'/>
        public static explicit operator int(ERational input)
        {
            return input.ToInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.Int32)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(int inputInt32)
        {
            return ERational.FromInt32(inputInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt32Checked"]/*'/>
        
        public uint ToUInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((uint)0) : this.ToEInteger().ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt32Unchecked"]/*'/>
        
        public uint ToUInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt32Unchecked() : (uint)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt32IfExact"]/*'/>
        
        public uint ToUInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((uint)0) :
              this.ToEIntegerIfExact().ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromUInt32(System.UInt32)"]/*'/>
        
        public static ERational FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt32"]/*'/>
        
        public static explicit operator uint(ERational input)
        {
            return input.ToUInt32Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt32)~PeterO.Numbers.ERational"]/*'/>
        
        public static implicit operator ERational(uint inputUInt32)
        {
            return ERational.FromUInt32(inputUInt32);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int64"]/*'/>
        public static explicit operator long(ERational input)
        {
            return input.ToInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.Int64)~PeterO.Numbers.ERational"]/*'/>
        public static implicit operator ERational(long inputInt64)
        {
            return ERational.FromInt64(inputInt64);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt64Checked"]/*'/>
        
        public ulong ToUInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ulong)0) : this.ToEInteger().ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt64Unchecked"]/*'/>
        
        public ulong ToUInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt64Unchecked() : (ulong)0;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.ToUInt64IfExact"]/*'/>
        
        public ulong ToUInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ulong)0) :
              this.ToEIntegerIfExact().ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.FromUInt64(System.UInt64)"]/*'/>
        
        public static ERational FromUInt64(ulong inputUInt64)
        {
            return FromEInteger(EInteger.FromUInt64(inputUInt64));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt64"]/*'/>
        
        public static explicit operator ulong(ERational input)
        {
            return input.ToUInt64Checked();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt64)~PeterO.Numbers.ERational"]/*'/>
        
        public static implicit operator ERational(ulong inputUInt64)
        {
            return ERational.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.ERounding"]/*'/>
    public enum ERounding
    {
        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.None"]/*'/>
        None,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.Up"]/*'/>
        Up,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.Down"]/*'/>
        Down,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.HalfUp"]/*'/>
        HalfUp,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.HalfDown"]/*'/>
        HalfDown,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.HalfEven"]/*'/>
        HalfEven,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.Ceiling"]/*'/>
        Ceiling,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.Floor"]/*'/>
        Floor,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.Odd"]/*'/>
        Odd,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.ZeroFiveUp"]/*'/>
        ZeroFiveUp,

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="F:PeterO.Numbers.ERounding.OddOrZeroFiveUp"]/*'/>
        OddOrZeroFiveUp
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.ETrapException"]/*'/>
    public sealed class ETrapException : ArithmeticException
    {
        private readonly Object result;
        private readonly EContext ctx;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ETrapException.Context"]/*'/>
        public EContext Context
        {
            get
            {
                return this.ctx;
            }
        }

        private readonly int error;

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ETrapException.Result"]/*'/>
        public Object Result
        {
            get
            {
                return this.result;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.ETrapException.Error"]/*'/>
        public int Error
        {
            get
            {
                return this.error;
            }
        }

        private static string FlagToMessage(int flag)
        {
            return (flag == EContext.FlagClamped) ? "Clamped" : ((flag ==
              EContext.FlagDivideByZero) ? "DivideByZero" : ((flag ==
              EContext.FlagInexact) ? "Inexact" : ((flag ==
              EContext.FlagInvalid) ? "Invalid" : ((flag ==
              EContext.FlagOverflow) ? "Overflow" : ((flag ==
              EContext.FlagRounded) ? "Rounded" : ((flag ==
              EContext.FlagSubnormal) ? "Subnormal" : ((flag ==
              EContext.FlagUnderflow) ? "Underflow" : "Trap")))))));
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.ETrapException.#ctor(System.Int32,PeterO.Numbers.EContext,System.Object)"]/*'/>
        public ETrapException(int flag, EContext ctx, Object result) :
          base(FlagToMessage(flag))
        {
            this.error = flag;
            this.ctx = ctx?.Copy();
            this.result = result;
        }
    }

    internal class ExtendedOrSimpleRadixMath<T> : IRadixMath<T>
    {
        private readonly RadixMath<T> ext;
        private readonly SimpleRadixMath<T> simp;

        public ExtendedOrSimpleRadixMath(IRadixMathHelper<T> helper)
        {
            this.ext = new RadixMath<T>(helper);
            this.simp = new SimpleRadixMath<T>(this.ext);
        }

        public IRadixMathHelper<T> GetHelper()
        {
            // Both RadixMath implementations return the
            // same helper, so use the ext implementation
            return this.ext.GetHelper();
        }

        public T DivideToIntegerNaturalScale(
      T thisValue,
      T divisor,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.DivideToIntegerNaturalScale(thisValue, divisor, ctx) :
              this.simp.DivideToIntegerNaturalScale(thisValue, divisor, ctx);
        }

        public T DivideToIntegerZeroScale(
      T thisValue,
      T divisor,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.DivideToIntegerZeroScale(thisValue, divisor, ctx) :
              this.simp.DivideToIntegerZeroScale(thisValue, divisor, ctx);
        }

        public T Abs(T value, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Abs(value, ctx) :
              this.simp.Abs(value, ctx);
        }

        public T Negate(T value, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Negate(value, ctx) :
              this.simp.Negate(value, ctx);
        }

        public T Remainder(
      T thisValue,
      T divisor,
      EContext ctx,
      bool roundAfterDivide)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.Remainder(thisValue, divisor, ctx, roundAfterDivide) :
              this.simp.Remainder(thisValue, divisor, ctx, roundAfterDivide);
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.RemainderNear(thisValue, divisor, ctx) :
              this.simp.RemainderNear(thisValue, divisor, ctx);
        }

        public T Pi(EContext ctx)
        {
            return (!ctx.IsSimplified) ? this.ext.Pi(ctx) : this.simp.Pi(ctx);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.Power(
        thisValue,
        pow,
        ctx) : this.simp.Power(thisValue, pow, ctx);
        }

        public T Log10(T thisValue, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.Log10(
        thisValue,
        ctx) : this.simp.Log10(thisValue, ctx);
        }

        public T Ln(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Ln(thisValue, ctx) :
              this.simp.Ln(thisValue, ctx);
        }

        public T Exp(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Exp(thisValue, ctx) :
              this.simp.Exp(thisValue, ctx);
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
          this.ext.SquareRoot(
        thisValue,
        ctx) : this.simp.SquareRoot(
        thisValue,
        ctx);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.NextMinus(thisValue, ctx) : this.simp.NextMinus(thisValue, ctx);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.NextToward(thisValue, otherValue, ctx) :
              this.simp.NextToward(thisValue, otherValue, ctx);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.NextPlus(thisValue, ctx) : this.simp.NextPlus(thisValue, ctx);
        }

        public T DivideToExponent(
      T thisValue,
      T divisor,
      EInteger desiredExponent,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.DivideToExponent(thisValue, divisor, desiredExponent, ctx) :
              this.simp.DivideToExponent(thisValue, divisor, desiredExponent, ctx);
        }

        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.Divide(
        thisValue,
        divisor,
        ctx) : this.simp.Divide(thisValue, divisor, ctx);
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.MinMagnitude(
        a,
        b,
        ctx) : this.simp.MinMagnitude(a, b, ctx);
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.MaxMagnitude(
        a,
        b,
        ctx) : this.simp.MaxMagnitude(a, b, ctx);
        }

        public T Max(T a, T b, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Max(a, b, ctx) :
            this.simp.Max(a, b, ctx);
        }

        public T Min(T a, T b, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Min(a, b, ctx) :
            this.simp.Min(a, b, ctx);
        }

        public T Multiply(T thisValue, T other, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.Multiply(thisValue, other, ctx) :
              this.simp.Multiply(thisValue, other, ctx);
        }

        public T MultiplyAndAdd(
      T thisValue,
      T multiplicand,
      T augend,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.MultiplyAndAdd(thisValue, multiplicand, augend, ctx) :
              this.simp.MultiplyAndAdd(thisValue, multiplicand, augend, ctx);
        }

        public T Plus(T thisValue, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.Plus(
        thisValue,
        ctx) : this.simp.Plus(thisValue, ctx);
        }

        public T RoundToPrecision(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.RoundToPrecision(thisValue, ctx) :
              this.simp.RoundToPrecision(thisValue, ctx);
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.RoundAfterConversion(thisValue, ctx) :
              this.simp.RoundAfterConversion(thisValue, ctx);
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.Quantize(thisValue, otherValue, ctx) :
              this.simp.Quantize(thisValue, otherValue, ctx);
        }

        public T RoundToExponentExact(
      T thisValue,
      EInteger expOther,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.RoundToExponentExact(thisValue, expOther, ctx) :
              this.simp.RoundToExponentExact(thisValue, expOther, ctx);
        }

        public T RoundToExponentSimple(
      T thisValue,
      EInteger expOther,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.RoundToExponentSimple(thisValue, expOther, ctx) :
              this.simp.RoundToExponentSimple(thisValue, expOther, ctx);
        }

        public T RoundToExponentNoRoundedFlag(
      T thisValue,
      EInteger exponent,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.RoundToExponentNoRoundedFlag(thisValue, exponent, ctx) :
              this.simp.RoundToExponentNoRoundedFlag(thisValue, exponent, ctx);
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.Reduce(
        thisValue,
        ctx) : this.simp.Reduce(thisValue, ctx);
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.Add(
        thisValue,
        other,
        ctx) : this.simp.Add(thisValue, other, ctx);
        }

        public T AddEx(
      T thisValue,
      T other,
      EContext ctx,
      bool roundToOperandPrecision)
        {
            return (
        ctx == null || !ctx.IsSimplified) ? this.ext.AddEx(
        thisValue,
        other,
        ctx,
        roundToOperandPrecision) :
              this.simp.AddEx(thisValue, other, ctx, roundToOperandPrecision);
        }

        public T CompareToWithContext(
      T thisValue,
      T otherValue,
      bool treatQuietNansAsSignaling,
      EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
            this.ext.CompareToWithContext(
        thisValue,
        otherValue,
        treatQuietNansAsSignaling,
        ctx) : this.simp.CompareToWithContext(
        thisValue,
        otherValue,
        treatQuietNansAsSignaling,
        ctx);
        }

        public int CompareTo(T thisValue, T otherValue)
        {
            return this.ext.CompareTo(thisValue, otherValue);
        }
    }

    internal static class Extras
    {
        public static int[] DoubleToIntegers(double dbl)
        {
            long value = BitConverter.ToInt64(
        BitConverter.GetBytes((double)dbl),
        0);
            int[] ret = new int[2];
            ret[0] = unchecked((int)(value & 0xffffffffL));
            ret[1] = unchecked((int)((value >> 32) & 0xffffffffL));
            return ret;
        }

        public static double IntegersToDouble(int[] integers)
        {
            // NOTE: least significant word first
            long value = ((long)integers[0]) & 0xffffffffL;
            value |= (((long)integers[1]) & 0xffffffffL) << 32;
            return BitConverter.ToDouble(BitConverter.GetBytes((long)value), 0);
        }
    }

    internal sealed class FastInteger : IComparable<FastInteger>
    {
        private sealed class MutableNumber
        {
            private int[] data;
            private int wordCount;

            internal static MutableNumber FromEInteger(EInteger bigintVal)
            {
                MutableNumber mnum = new MutableNumber(0);
                if (bigintVal.Sign < 0)
                {
                    throw new ArgumentException("bigintVal's sign (" + bigintVal.Sign +
                      ") is less than " + "0 ");
                }
                byte[] bytes = bigintVal.ToBytes(true);
                int len = bytes.Length;
                int newWordCount = Math.Max(4, (len / 4) + 1);
                if (newWordCount > mnum.data.Length)
                {
                    mnum.data = new int[newWordCount];
                }
                mnum.wordCount = newWordCount;
                unchecked
                {
                    for (int i = 0; i < len; i += 4)
                    {
                        int x = ((int)bytes[i]) & 0xff;
                        if (i + 1 < len)
                        {
                            x |= (((int)bytes[i + 1]) & 0xff) << 8;
                        }
                        if (i + 2 < len)
                        {
                            x |= (((int)bytes[i + 2]) & 0xff) << 16;
                        }
                        if (i + 3 < len)
                        {
                            x |= (((int)bytes[i + 3]) & 0xff) << 24;
                        }
                        mnum.data[i >> 2] = x;
                    }
                }
                // Calculate the correct data length
                while (mnum.wordCount != 0 && mnum.data[mnum.wordCount - 1] == 0)
                {
                    --mnum.wordCount;
                }
                return mnum;
            }

            internal MutableNumber(int val)
            {
                if (val < 0)
                {
                    throw new ArgumentException("val (" + val + ") is less than " + "0 ");
                }
                this.data = new int[4];
                this.wordCount = (val == 0) ? 0 : 1;
                this.data[0] = val;
            }

            internal MutableNumber SetInt(int val)
            {
                if (val < 0)
                {
                    throw new ArgumentException("val (" + val + ") is less than " + "0 ");
                }
                this.wordCount = (val == 0) ? 0 : 1;
                this.data[0] = val;
                return this;
            }

            internal EInteger ToEInteger()
            {
                if (this.wordCount == 1 && (this.data[0] >> 31) == 0)
                {
                    return (EInteger)((int)this.data[0]);
                }
                if (this.wordCount == 2 && (this.data[1] >> 31) == 0)
                {
                    long longV = unchecked((long)this.data[0]);
                    longV &= 0xffffffffL;
                    longV |= unchecked(((long)this.data[1]) << 32);
                    return EInteger.FromInt64(longV);
                }
                return EInteger.FromInts(this.data, this.wordCount);
                /* var bytes = new byte[(this.wordCount >> 2) + 1];
                var i = 0;
                var j = 0;
                for (i = 0, j = 0; i < this.wordCount; ++i) {
                  int d = this.data[i];
                  bytes[j++] = unchecked((byte)(d));
                  bytes[j++] = unchecked((byte)(d >> 8));
                  bytes[j++] = unchecked((byte)(d >> 16));
                  bytes[j++] = unchecked((byte)(d >> 24));
                }
                bytes[bytes.Length - 1] = (byte)0;
                return EInteger.FromBytes(bytes, true);*/
            }

            internal int[] GetLastWordsInternal(int numWords32Bit)
            {
                int[] ret = new int[numWords32Bit];
                Array.Copy(this.data, ret, Math.Min(numWords32Bit, this.wordCount));
                return ret;
            }

            internal bool CanFitInInt32()
            {
                return this.wordCount == 0 || (this.wordCount == 1 && (this.data[0] >>
                31) == 0);
            }

            internal int ToInt32()
            {
                return this.wordCount == 0 ? 0 : this.data[0];
            }

            public static MutableNumber FromLong(long longVal)
            {
                if (longVal < 0)
                {
                    throw new ArgumentException();
                }
                if (longVal == 0)
                {
                    return new MutableNumber(0);
                }
                MutableNumber mbi = new MutableNumber(0);
                mbi.data[0] = unchecked((int)longVal);
                int mbd = unchecked((int)(longVal >> 32));
                mbi.data[1] = mbd;
                mbi.wordCount = (mbd == 0) ? 1 : 2;
                return mbi;
            }

            internal MutableNumber Copy()
            {
                MutableNumber mbi = new MutableNumber(0);
                if (this.wordCount > mbi.data.Length)
                {
                    mbi.data = new int[this.wordCount];
                }
                Array.Copy(this.data, mbi.data, this.wordCount);
                mbi.wordCount = this.wordCount;
                return mbi;
            }

            internal MutableNumber Multiply(int multiplicand)
            {
                if (multiplicand < 0)
                {
                    throw new ArgumentException("multiplicand (" + multiplicand +
                      ") is less than " + "0 ");
                }
                if (multiplicand != 0)
                {
                    int carry = 0;
                    if (this.wordCount == 0)
                    {
                        if (this.data.Length == 0)
                        {
                            this.data = new int[4];
                        }
                        this.data[0] = 0;
                        this.wordCount = 1;
                    }
                    int result0, result1, result2, result3;
                    if (multiplicand < 65536)
                    {
                        if (this.wordCount == 2 && (this.data[1] >> 16) == 0)
                        {
                            long longV = unchecked((long)this.data[0]);
                            longV &= 0xffffffffL;
                            longV |= unchecked(((long)this.data[1]) << 32);
                            longV = unchecked(longV * multiplicand);
                            this.data[0] = unchecked((int)longV);
                            this.data[1] = unchecked((int)(longV >> 32));
                            carry = 0;
                        }
                        else if (this.wordCount == 1)
                        {
                            long longV = unchecked((long)this.data[0]);
                            longV &= 0xffffffffL;
                            longV = unchecked(longV * multiplicand);
                            this.data[0] = unchecked((int)longV);
                            carry = unchecked((int)(longV >> 32));
                        }
                        else
                        {
                            for (int i = 0; i < this.wordCount; ++i)
                            {
                                int x0 = this.data[i];
                                int x1 = x0;
                                int y0 = multiplicand;
                                x0 &= 65535;
                                x1 = (x1 >> 16) & 65535;
                                int temp = unchecked(x0 * y0);  // a * c
                                result1 = (temp >> 16) & 65535;
                                result0 = temp & 65535;
                                result2 = 0;
                                temp = unchecked(x1 * y0);  // b * c
                                result2 += (temp >> 16) & 65535;
                                result1 += temp & 65535;
                                result2 += (result1 >> 16) & 65535;
                                result1 &= 65535;
                                result3 = (result2 >> 16) & 65535;
                                result2 &= 65535;
                                // Add carry
                                x0 = unchecked((int)(result0 | (result1 << 16)));
                                x1 = unchecked((int)(result2 | (result3 << 16)));
                                int x2 = unchecked(x0 + carry);
                                if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &
                                Int32.MaxValue)) : ((x2 >> 31) == 0))
                                {
                                    // Carry in addition
                                    x1 = unchecked(x1 + 1);
                                }
                                this.data[i] = x2;
                                carry = x1;
                            }
                        }
                    }
                    else
                    {
                        if (this.wordCount == 1)
                        {
                            long longV = unchecked((long)this.data[0]);
                            longV &= 0xffffffffL;
                            longV = unchecked(longV * multiplicand);
                            this.data[0] = unchecked((int)longV);
                            carry = unchecked((int)(longV >> 32));
                        }
                        else
                        {
                            for (int i = 0; i < this.wordCount; ++i)
                            {
                                int x0 = this.data[i];
                                int x1 = x0;
                                int y0 = multiplicand;
                                int y1 = y0;
                                x0 &= 65535;
                                y0 &= 65535;
                                x1 = (x1 >> 16) & 65535;
                                y1 = (y1 >> 16) & 65535;
                                int temp = unchecked(x0 * y0);  // a * c
                                result1 = (temp >> 16) & 65535;
                                result0 = temp & 65535;
                                temp = unchecked(x0 * y1);  // a * d
                                result2 = (temp >> 16) & 65535;
                                result1 += temp & 65535;
                                result2 += (result1 >> 16) & 65535;
                                result1 &= 65535;
                                temp = unchecked(x1 * y0);  // b * c
                                result2 += (temp >> 16) & 65535;
                                result1 += temp & 65535;
                                result2 += (result1 >> 16) & 65535;
                                result1 &= 65535;
                                result3 = (result2 >> 16) & 65535;
                                result2 &= 65535;
                                temp = unchecked(x1 * y1);  // b * d
                                result3 += (temp >> 16) & 65535;
                                result2 += temp & 65535;
                                result3 += (result2 >> 16) & 65535;
                                result2 &= 65535;
                                // Add carry
                                x0 = unchecked((int)(result0 | (result1 << 16)));
                                x1 = unchecked((int)(result2 | (result3 << 16)));
                                int x2 = unchecked(x0 + carry);
                                if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &
                                Int32.MaxValue)) : ((x2 >> 31) == 0))
                                {
                                    // Carry in addition
                                    x1 = unchecked(x1 + 1);
                                }
                                this.data[i] = x2;
                                carry = x1;
                            }
                        }
                    }
                    if (carry != 0)
                    {
                        if (this.wordCount >= this.data.Length)
                        {
                            int[] newdata = new int[this.wordCount + 20];
                            Array.Copy(this.data, 0, newdata, 0, this.data.Length);
                            this.data = newdata;
                        }
                        this.data[this.wordCount] = carry;
                        ++this.wordCount;
                    }
                    // Calculate the correct data length
                    while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                    {
                        --this.wordCount;
                    }
                }
                else
                {
                    if (this.data.Length > 0)
                    {
                        this.data[0] = 0;
                    }
                    this.wordCount = 0;
                }
                return this;
            }

            internal int Sign
            {
                get
                {
                    return this.wordCount == 0 ? 0 : 1;
                }
            }

            internal bool IsEvenNumber
            {
                get
                {
                    return this.wordCount == 0 || (this.data[0] & 1) == 0;
                }
            }

            internal int CompareToInt(int val)
            {
                if (val < 0 || this.wordCount > 1)
                {
                    return 1;
                }
                if (this.wordCount == 0)
                {
                    // this value is 0
                    return (val == 0) ? 0 : -1;
                }
                if (this.data[0] == val)
                {
                    return 0;
                }
                return (((this.data[0] >> 31) == (val >> 31)) ? ((this.data[0] &
                Int32.MaxValue) < (val & Int32.MaxValue)) :
                          ((this.data[0] >> 31) == 0)) ? -1 : 1;
            }

            internal MutableNumber SubtractInt(int other)
            {
                if (other < 0)
                {
                    throw new ArgumentException("other (" + other + ") is less than " +
                           "0 ");
                }
                if (other != 0)
                {
                    unchecked
                    {
                        // Ensure a length of at least 1
                        if (this.wordCount == 0)
                        {
                            if (this.data.Length == 0)
                            {
                                this.data = new int[4];
                            }
                            this.data[0] = 0;
                            this.wordCount = 1;
                        }
                        int borrow;
                        int u;
                        int a = this.data[0];
                        u = a - other;
                        borrow = ((((a >> 31) == (u >> 31)) ?
                                ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :
                                ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;
                        this.data[0] = (int)u;
                        if (borrow != 0)
                        {
                            for (int i = 1; i < this.wordCount; ++i)
                            {
                                u = this.data[i] - borrow;
                                borrow = (((this.data[i] >> 31) == (u >> 31)) ?
                                ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :
                                    ((this.data[i] >> 31) == 0)) ? 1 : 0;
                                this.data[i] = (int)u;
                            }
                        }
                        // Calculate the correct data length
                        while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                        {
                            --this.wordCount;
                        }
                    }
                }
                return this;
            }

            internal MutableNumber Subtract(MutableNumber other)
            {
                unchecked
                {
                    {
                        // Console.WriteLine("" + this.data.Length + " " +
                        // (other.data.Length));
                        int neededSize = (this.wordCount > other.wordCount) ?
                        this.wordCount : other.wordCount;
                        if (this.data.Length < neededSize)
                        {
                            int[] newdata = new int[neededSize + 20];
                            Array.Copy(this.data, 0, newdata, 0, this.data.Length);
                            this.data = newdata;
                        }
                        neededSize = (this.wordCount < other.wordCount) ? this.wordCount :
                        other.wordCount;
                        int u = 0;
                        int borrow = 0;
                        for (int i = 0; i < neededSize; ++i)
                        {
                            int a = this.data[i];
                            u = (a - other.data[i]) - borrow;
                            borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <
                            (u & Int32.MaxValue)) :
                                  ((a >> 31) == 0)) || (a == u && other.data[i] !=
                                  0)) ? 1 : 0;
                            this.data[i] = (int)u;
                        }
                        if (borrow != 0)
                        {
                            for (int i = neededSize; i < this.wordCount; ++i)
                            {
                                int a = this.data[i];
                                u = (a - other.data[i]) - borrow;
                                borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <
                                (u & Int32.MaxValue)) :
                                    ((a >> 31) == 0)) || (a == u && other.data[i] !=
                                    0)) ? 1 : 0;
                                this.data[i] = (int)u;
                            }
                        }
                        // Calculate the correct data length
                        while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                        {
                            --this.wordCount;
                        }
                        return this;
                    }
                }
            }

            public int CompareTo(MutableNumber other)
            {
                if (this.wordCount != other.wordCount)
                {
                    return (this.wordCount < other.wordCount) ? -1 : 1;
                }
                int valueN = this.wordCount;
                while (unchecked(valueN--) != 0)
                {
                    int an = this.data[valueN];
                    int bn = other.data[valueN];
                    // Unsigned less-than check
                    if (((an >> 31) == (bn >> 31)) ?
                        ((an & Int32.MaxValue) < (bn & Int32.MaxValue)) :
                        ((an >> 31) == 0))
                    {
                        return -1;
                    }
                    if (an != bn)
                    {
                        return 1;
                    }
                }
                return 0;
            }

            internal MutableNumber Add(int augend)
            {
                if (augend < 0)
                {
                    throw new ArgumentException("augend (" + augend + ") is less than " +
                             "0 ");
                }
                unchecked
                {
                    if (augend != 0)
                    {
                        int carry = 0;
                        // Ensure a length of at least 1
                        if (this.wordCount == 0)
                        {
                            if (this.data.Length == 0)
                            {
                                this.data = new int[4];
                            }
                            this.data[0] = 0;
                            this.wordCount = 1;
                        }
                        for (int i = 0; i < this.wordCount; ++i)
                        {
                            int u;
                            int a = this.data[i];
                            u = (a + augend) + carry;
                            carry = ((((u >> 31) == (a >> 31)) ? ((u & Int32.MaxValue) < (a &
                            Int32.MaxValue)) :
                                    ((u >> 31) == 0)) || (u == a && augend != 0)) ? 1 : 0;
                            this.data[i] = u;
                            if (carry == 0)
                            {
                                return this;
                            }
                            augend = 0;
                        }
                        if (carry != 0)
                        {
                            if (this.wordCount >= this.data.Length)
                            {
                                int[] newdata = new int[this.wordCount + 20];
                                Array.Copy(this.data, 0, newdata, 0, this.data.Length);
                                this.data = newdata;
                            }
                            this.data[this.wordCount] = carry;
                            ++this.wordCount;
                        }
                    }
                    // Calculate the correct data length
                    while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                    {
                        --this.wordCount;
                    }
                    return this;
                }
            }
        }

        private int smallValue;  // if integerMode is 0
        private MutableNumber mnum;  // if integerMode is 1
        private EInteger largeValue;  // if integerMode is 2
        private int integerMode;

        private bool frozen;

        private static readonly EInteger ValueInt32MinValue =
          (EInteger)Int32.MinValue;

        private static readonly EInteger ValueInt32MaxValue =
          (EInteger)Int32.MaxValue;

        private static readonly EInteger ValueNegativeInt32MinValue =
        -(EInteger)ValueInt32MinValue;

        internal FastInteger(int value)
        {
            this.smallValue = value;
        }

        internal FastInteger Copy()
        {
            FastInteger fi = new FastInteger(this.smallValue)
            {
                integerMode = this.integerMode,
                largeValue = this.largeValue,
                mnum = (this.mnum == null || this.integerMode != 1) ? null :
            this.mnum.Copy()
            };
            return fi;
        }

        internal static FastInteger CopyFrozen(FastInteger value)
        {
            FastInteger fi = new FastInteger(value.smallValue)
            {
                integerMode = value.integerMode,
                largeValue = value.largeValue,
                mnum = (value.mnum == null || value.integerMode != 1) ? null :
            value.mnum.Copy(),
                frozen = true
            };
            return fi;
        }

        internal static FastInteger FromBig(EInteger bigintVal)
        {
            if (bigintVal.CanFitInInt32())
            {
                return new FastInteger(bigintVal.ToInt32Unchecked());
            }
            if (bigintVal.Sign > 0)
            {
                FastInteger fi = new FastInteger(0)
                {
                    integerMode = 1,
                    mnum = MutableNumber.FromEInteger(bigintVal)
                };
                return fi;
            }
            else
            {
                FastInteger fi = new FastInteger(0)
                {
                    integerMode = 2,
                    largeValue = bigintVal
                };
                return fi;
            }
        }

        internal int AsInt32()
        {
            switch (this.integerMode)
            {
                case 0:
                    return this.smallValue;
                case 1:
                    return this.mnum.ToInt32();
                case 2:
                    return (int)this.largeValue;
                default: throw new InvalidOperationException();
            }
        }

        private void CheckFrozen()
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
        }

        public int CompareTo(FastInteger val)
        {
            switch ((this.integerMode << 2) | val.integerMode)
            {
                case (0 << 2) | 0:
                    {
                        int vsv = val.smallValue;
                        return (this.smallValue == vsv) ? 0 : (this.smallValue < vsv ? -1 :
                              1);
                    }
                case (0 << 2) | 1:
                    return -val.mnum.CompareToInt(this.smallValue);
                case (0 << 2) | 2:
                    return this.AsEInteger().CompareTo(val.largeValue);
                case (1 << 2) | 0:
                    return this.mnum.CompareToInt(val.smallValue);
                case (1 << 2) | 1:
                    return this.mnum.CompareTo(val.mnum);
                case (1 << 2) | 2:
                    return this.AsEInteger().CompareTo(val.largeValue);
                case (2 << 2) | 0:
                case (2 << 2) | 1:
                case (2 << 2) | 2:
                    return this.largeValue.CompareTo(val.AsEInteger());
                default: throw new InvalidOperationException();
            }
        }

        internal FastInteger Abs()
        {
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
            switch (this.integerMode)
            {
                case 0:
                    if (this.smallValue == Int32.MinValue)
                    {
                        return this.Negate();
                    }
                    this.smallValue = Math.Abs(this.smallValue);
                    return this;
                default:
                    return (this.Sign < 0) ? this.Negate() : this;
            }
        }

        internal static int[] GetLastWords(EInteger bigint, int numWords32Bit)
        {
            return
            MutableNumber.FromEInteger(bigint).GetLastWordsInternal(numWords32Bit);
        }

        internal FastInteger SetInt(int val)
        {
            this.CheckFrozen();
            this.smallValue = val;
            this.integerMode = 0;
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastInteger.Multiply(System.Int32)"]/*'/>
        internal FastInteger Multiply(int val)
        {
            this.CheckFrozen();
            if (val == 0)
            {
                this.smallValue = 0;
                this.integerMode = 0;
            }
            else
            {
                switch (this.integerMode)
                {
                    case 0:
                        {
                            long amult = ((long)val) * ((long)this.smallValue);
                            if (amult > Int32.MaxValue || amult < Int32.MinValue)
                            {
                                // would overflow, convert to large
                                bool apos = this.smallValue > 0L;
                                bool bpos = val > 0L;
                                if (apos && bpos)
                                {
                                    // if both operands are nonnegative
                                    // convert to mutable big integer
                                    this.integerMode = 1;
                                    this.mnum = MutableNumber.FromLong(amult);
                                }
                                else
                                {
                                    // if either operand is negative
                                    // convert to big integer
                                    this.integerMode = 2;
                                    this.largeValue = EInteger.FromInt64(amult);
                                }
                            }
                            else
                            {
                                this.smallValue = unchecked((int)amult);
                            }
                            break;
                        }
                    case 1:
                        if (val < 0)
                        {
                            this.integerMode = 2;
                            this.largeValue = this.mnum.ToEInteger();
                            this.largeValue *= (EInteger)val;
                        }
                        else
                        {
                            mnum.Multiply(val);
                        }
                        break;
                    case 2:
                        this.largeValue *= (EInteger)val;
                        break;
                    default: throw new InvalidOperationException();
                }
            }
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastInteger.Negate"]/*'/>
        internal FastInteger Negate()
        {
            this.CheckFrozen();
            switch (this.integerMode)
            {
                case 0:
                    if (this.smallValue == Int32.MinValue)
                    {
                        // would overflow, convert to large
                        this.integerMode = 1;
                        this.mnum =
                        MutableNumber.FromEInteger(ValueNegativeInt32MinValue);
                    }
                    else
                    {
                        smallValue = -smallValue;
                    }
                    break;
                case 1:
                    this.integerMode = 2;
                    this.largeValue = this.mnum.ToEInteger();
                    this.largeValue = -(EInteger)this.largeValue;
                    break;
                case 2:
                    this.largeValue = -(EInteger)this.largeValue;
                    break;
                default:
                    throw new InvalidOperationException();
            }
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastInteger.Subtract(PeterO.Numbers.FastInteger)"]/*'/>
        internal FastInteger Subtract(FastInteger val)
        {
            this.CheckFrozen();
            EInteger valValue;
            switch (this.integerMode)
            {
                case 0:
                    if (val.integerMode == 0)
                    {
                        int vsv = val.smallValue;
                        if ((vsv < 0 && Int32.MaxValue + vsv < this.smallValue) ||
                            (vsv > 0 && Int32.MinValue + vsv > this.smallValue))
                        {
                            // would overflow, convert to large
                            this.integerMode = 2;
                            this.largeValue = (EInteger)this.smallValue;
                            this.largeValue -= (EInteger)vsv;
                        }
                        else
                        {
                            this.smallValue -= vsv;
                        }
                    }
                    else
                    {
                        integerMode = 2;
                        largeValue = (EInteger)smallValue;
                        valValue = val.AsEInteger();
                        largeValue -= (EInteger)valValue;
                    }
                    break;
                case 1:
                    if (val.integerMode == 1)
                    {
                        // NOTE: Mutable numbers are
                        // currently always zero or positive
                        this.mnum.Subtract(val.mnum);
                    }
                    else if (val.integerMode == 0 && val.smallValue >= 0)
                    {
                        mnum.SubtractInt(val.smallValue);
                    }
                    else
                    {
                        integerMode = 2;
                        largeValue = mnum.ToEInteger();
                        valValue = val.AsEInteger();
                        largeValue -= (EInteger)valValue;
                    }
                    break;
                case 2:
                    valValue = val.AsEInteger();
                    this.largeValue -= (EInteger)valValue;
                    break;
                default: throw new InvalidOperationException();
            }
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastInteger.SubtractInt(System.Int32)"]/*'/>
        internal FastInteger SubtractInt(int val)
        {
            this.CheckFrozen();
            if (val == Int32.MinValue)
            {
                return this.AddBig(ValueNegativeInt32MinValue);
            }
            if (this.integerMode == 0)
            {
                if ((val < 0 && Int32.MaxValue + val < this.smallValue) ||
                        (val > 0 && Int32.MinValue + val > this.smallValue))
                {
                    // would overflow, convert to large
                    this.integerMode = 2;
                    this.largeValue = (EInteger)this.smallValue;
                    this.largeValue -= (EInteger)val;
                }
                else
                {
                    this.smallValue -= val;
                }
                return this;
            }
            return this.AddInt(-val);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastInteger.AddBig(PeterO.Numbers.EInteger)"]/*'/>
        internal FastInteger AddBig(EInteger bigintVal)
        {
            this.CheckFrozen();
            switch (this.integerMode)
            {
                case 0:
                    {
                        return bigintVal.CanFitInInt32() ? this.AddInt((int)bigintVal) :
                        this.Add(FastInteger.FromBig(bigintVal));
                    }
                case 1:
                    this.integerMode = 2;
                    this.largeValue = this.mnum.ToEInteger();
                    this.largeValue += bigintVal;
                    break;
                case 2:
                    this.largeValue += bigintVal;
                    break;
                default:
                    throw new InvalidOperationException();
            }
            return this;
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastInteger.SubtractBig(PeterO.Numbers.EInteger)"]/*'/>
        internal FastInteger SubtractBig(EInteger bigintVal)
        {
            this.CheckFrozen();
            if (this.integerMode == 2)
            {
                this.largeValue -= (EInteger)bigintVal;
                return this;
            }
            else
            {
                int sign = bigintVal.Sign;
                if (sign == 0)
                {
                    return this;
                }
                // Check if this value fits an int, except if
                // it's MinValue
                if (sign < 0 && bigintVal.CompareTo(ValueInt32MinValue) > 0)
                {
                    return this.AddInt(-((int)bigintVal));
                }
                if (sign > 0 && bigintVal.CompareTo(ValueInt32MaxValue) <= 0)
                {
                    return this.SubtractInt((int)bigintVal);
                }
                bigintVal = -bigintVal;
                return this.AddBig(bigintVal);
            }
        }

        internal FastInteger Add(FastInteger val)
        {
            this.CheckFrozen();
            EInteger valValue;
            switch (this.integerMode)
            {
                case 0:
                    if (val.integerMode == 0)
                    {
                        if ((this.smallValue < 0 && (int)val.smallValue < Int32.MinValue
                        - this.smallValue) ||
                            (this.smallValue > 0 && (int)val.smallValue > Int32.MaxValue
                            - this.smallValue))
                        {
                            // would overflow
                            if (val.smallValue >= 0)
                            {
                                this.integerMode = 1;
                                this.mnum = new MutableNumber(this.smallValue);
                                this.mnum.Add(val.smallValue);
                            }
                            else
                            {
                                this.integerMode = 2;
                                this.largeValue = (EInteger)this.smallValue;
                                this.largeValue += (EInteger)val.smallValue;
                            }
                        }
                        else
                        {
                            this.smallValue += val.smallValue;
                        }
                    }
                    else
                    {
                        integerMode = 2;
                        largeValue = (EInteger)smallValue;
                        valValue = val.AsEInteger();
                        largeValue += (EInteger)valValue;
                    }
                    break;
                case 1:
                    if (val.integerMode == 0 && val.smallValue >= 0)
                    {
                        this.mnum.Add(val.smallValue);
                    }
                    else
                    {
                        integerMode = 2;
                        largeValue = mnum.ToEInteger();
                        valValue = val.AsEInteger();
                        largeValue += (EInteger)valValue;
                    }
                    break;
                case 2:
                    valValue = val.AsEInteger();
                    this.largeValue += (EInteger)valValue;
                    break;
                default: throw new InvalidOperationException();
            }
            return this;
        }

        internal FastInteger Remainder(int divisor)
        {
            // Mod operator will always result in a
            // number that fits an int for int divisors
            this.CheckFrozen();
            if (divisor != 0)
            {
                switch (this.integerMode)
                {
                    case 0:
                        this.smallValue %= divisor;
                        break;
                    case 1:
                        this.largeValue = this.mnum.ToEInteger();
                        this.largeValue %= (EInteger)divisor;
                        this.smallValue = (int)this.largeValue;
                        this.integerMode = 0;
                        break;
                    case 2:
                        this.largeValue %= (EInteger)divisor;
                        this.smallValue = (int)this.largeValue;
                        this.integerMode = 0;
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }
            else
            {
                throw new DivideByZeroException();
            }
            return this;
        }

        internal FastInteger Increment()
        {
            this.CheckFrozen();
            if (this.integerMode == 0)
            {
                if (this.smallValue != Int32.MaxValue)
                {
                    ++this.smallValue;
                }
                else
                {
                    this.integerMode = 1;
                    this.mnum = MutableNumber.FromEInteger(ValueNegativeInt32MinValue);
                }
                return this;
            }
            return this.AddInt(1);
        }

        internal FastInteger Decrement()
        {
            this.CheckFrozen();
            if (this.integerMode == 0)
            {
                if (this.smallValue != Int32.MinValue)
                {
                    --this.smallValue;
                }
                else
                {
                    this.integerMode = 1;
                    this.mnum = MutableNumber.FromEInteger(ValueInt32MinValue);
                    this.mnum.SubtractInt(1);
                }
                return this;
            }
            return this.SubtractInt(1);
        }

        internal FastInteger Divide(int divisor)
        {
            this.CheckFrozen();
            if (divisor != 0)
            {
                switch (this.integerMode)
                {
                    case 0:
                        if (divisor == -1 && this.smallValue == Int32.MinValue)
                        {
                            // would overflow, convert to large
                            this.integerMode = 1;
                            this.mnum =
                            MutableNumber.FromEInteger(ValueNegativeInt32MinValue);
                        }
                        else
                        {
                            smallValue /= divisor;
                        }
                        break;
                    case 1:
                        this.integerMode = 2;
                        this.largeValue = this.mnum.ToEInteger();
                        this.largeValue /= (EInteger)divisor;
                        if (this.largeValue.IsZero)
                        {
                            this.integerMode = 0;
                            this.smallValue = 0;
                        }
                        break;
                    case 2:
                        this.largeValue /= (EInteger)divisor;
                        if (this.largeValue.IsZero)
                        {
                            this.integerMode = 0;
                            this.smallValue = 0;
                        }
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }
            else
            {
                throw new DivideByZeroException();
            }
            return this;
        }

        internal bool IsEvenNumber
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return (this.smallValue & 1) == 0;
                    case 1:
                        return this.mnum.IsEvenNumber;
                    case 2:
                        return this.largeValue.IsEven;
                    default:
                        throw new InvalidOperationException();
                }
            }
        }

        internal FastInteger AddInt(int val)
        {
            this.CheckFrozen();
            EInteger valValue;
            switch (this.integerMode)
            {
                case 0:
                    if ((this.smallValue < 0 && (int)val < Int32.MinValue -
                  this.smallValue) || (this.smallValue > 0 && (int)val >
                      Int32.MaxValue - this.smallValue))
                    {
                        // would overflow
                        if (val >= 0)
                        {
                            this.integerMode = 1;
                            this.mnum = new MutableNumber(this.smallValue);
                            this.mnum.Add(val);
                        }
                        else
                        {
                            this.integerMode = 2;
                            this.largeValue = (EInteger)this.smallValue;
                            this.largeValue += (EInteger)val;
                        }
                    }
                    else
                    {
                        smallValue += val;
                    }
                    break;
                case 1:
                    if (val >= 0)
                    {
                        this.mnum.Add(val);
                    }
                    else
                    {
                        integerMode = 2;
                        largeValue = mnum.ToEInteger();
                        valValue = (EInteger)val;
                        largeValue += (EInteger)valValue;
                    }
                    break;
                case 2:
                    valValue = (EInteger)val;
                    this.largeValue += (EInteger)valValue;
                    break;
                default: throw new InvalidOperationException();
            }
            return this;
        }

        internal bool CanFitInInt32()
        {
            switch (this.integerMode)
            {
                case 0:
                    return true;
                case 1:
                    return this.mnum.CanFitInInt32();
                case 2:
                    {
                        return this.largeValue.CanFitInInt32();
                    }
                default:
                    throw new InvalidOperationException();
            }
        }

        internal bool CanFitInInt64()
        {
            switch (this.integerMode)
            {
                case 0:
                    return true;
                case 1:
                    return this.AsEInteger().CanFitInInt64();
                case 2:
                    {
                        return this.largeValue.CanFitInInt64();
                    }
                default:
                    throw new InvalidOperationException();
            }
        }

        internal long AsInt64()
        {
            switch (this.integerMode)
            {
                case 0:
                    return (long)this.smallValue;
                case 1:
                    return this.AsEInteger().ToInt64Unchecked();
                case 2:
                    {
                        return this.largeValue.ToInt64Unchecked();
                    }
                default:
                    throw new InvalidOperationException();
            }
        }

        private static readonly string HexAlphabet = "0123456789ABCDEF";

        internal static string IntToString(int value)
        {
            if (value == Int32.MinValue)
            {
                return "-2147483648";
            }
            if (value == 0)
            {
                return "0";
            }
            bool neg = value < 0;
            char[] chars = new char[12];
            int count = 11;
            if (neg)
            {
                value = -value;
            }
            while (value > 43698)
            {
                int intdivvalue = value / 10;
                char digit = HexAlphabet[(int)(value - (intdivvalue * 10))];
                chars[count--] = digit;
                value = intdivvalue;
            }
            while (value > 9)
            {
                int intdivvalue = (value * 26215) >> 18;
                char digit = HexAlphabet[(int)(value - (intdivvalue * 10))];
                chars[count--] = digit;
                value = intdivvalue;
            }
            if (value != 0)
            {
                chars[count--] = HexAlphabet[(int)value];
            }
            if (neg)
            {
                chars[count] = '-';
            }
            else
            {
                ++count;
            }
            return new String(chars, count, 12 - count);
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastInteger.ToString"]/*'/>
        public override string ToString()
        {
            switch (this.integerMode)
            {
                case 0:
                    return IntToString(this.smallValue);
                case 1:
                    return this.mnum.ToEInteger().ToString();
                case 2:
                    return this.largeValue.ToString();
                default: return String.Empty;
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="P:PeterO.Numbers.FastInteger.Sign"]/*'/>
        internal int Sign
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return (this.smallValue == 0) ? 0 : ((this.smallValue < 0) ? -1 :
                            1);
                    case 1:
                        return this.mnum.Sign;
                    case 2:
                        return this.largeValue.Sign;
                    default: return 0;
                }
            }
        }

        internal bool IsValueZero
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return this.smallValue == 0;
                    case 1:
                        return this.mnum.Sign == 0;
                    case 2:
                        return this.largeValue.IsZero;
                    default:
                        return false;
                }
            }
        }

        internal int CompareToInt(int val)
        {
            switch (this.integerMode)
            {
                case 0:
                    return (val == this.smallValue) ? 0 : (this.smallValue < val ? -1 :
                    1);
                case 1:
                    return this.mnum.ToEInteger().CompareTo((EInteger)val);
                case 2:
                    return this.largeValue.CompareTo((EInteger)val);
                default: return 0;
            }
        }

        internal EInteger AsEInteger()
        {
            switch (this.integerMode)
            {
                case 0:
                    return EInteger.FromInt32(this.smallValue);
                case 1:
                    return this.mnum.ToEInteger();
                case 2:
                    return this.largeValue;
                default: throw new InvalidOperationException();
            }
        }
    }

    internal sealed class FastIntegerFixed : IComparable<FastIntegerFixed>
    {
        private int smallValue;  // if integerMode is 0
        private EInteger largeValue;  // if integerMode is 2
        private int integerMode;

        public static readonly FastIntegerFixed Zero = new FastIntegerFixed(0);
        public static readonly FastIntegerFixed One = new FastIntegerFixed(1);

        private static readonly EInteger ValueInt32MinValue =
          (EInteger)Int32.MinValue;

        private static readonly EInteger ValueNegativeInt32MinValue =
        -(EInteger)ValueInt32MinValue;

        internal FastIntegerFixed(int value)
        {
            this.smallValue = value;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is FastIntegerFixed fi))
            {
                return false;
            }
            if (this.integerMode != fi.integerMode)
            {
                return false;
            }
            if (this.integerMode == 0)
            {
                if (this.smallValue != fi.smallValue)
                {
                    return false;
                }
            }
            else if (this.integerMode == 1)
            {
                if (!this.largeValue.Equals(fi.largeValue))
                {
                    return false;
                }
            }
            return true;
        }

        public override int GetHashCode()
        {
            int hash = unchecked(31 + this.integerMode);
            if (this.integerMode == 0)
            {
                hash = unchecked((hash * 31) + this.smallValue);
            }
            else if (this.integerMode == 1)
            {
                hash = unchecked((hash * 31) + this.largeValue.GetHashCode());
            }
            return hash;
        }

        internal static FastIntegerFixed FromLong(long longVal)
        {
            if (longVal >= Int32.MinValue && longVal <= Int32.MaxValue)
            {
                return new FastIntegerFixed((int)longVal);
            }
            FastIntegerFixed fi = new FastIntegerFixed(0)
            {
                integerMode = 2,
                largeValue = EInteger.FromInt64(longVal)
            };
            return fi;
        }

        internal static FastIntegerFixed FromBig(EInteger bigintVal)
        {
            if (bigintVal.CanFitInInt32())
            {
                return new FastIntegerFixed(bigintVal.ToInt32Unchecked());
            }
            FastIntegerFixed fi = new FastIntegerFixed(0)
            {
                integerMode = 2,
                largeValue = bigintVal
            };
            return fi;
        }

        internal int AsInt32()
        {
            return (this.integerMode == 0) ?
              this.smallValue : this.largeValue.ToInt32Unchecked();
        }

        public static FastIntegerFixed FromFastInteger(FastInteger fi)
        {
            if (fi.CanFitInInt32())
            {
                return new FastIntegerFixed(fi.AsInt32());
            }
            else
            {
                return FastIntegerFixed.FromBig(fi.AsEInteger());
            }
        }

        public FastInteger ToFastInteger()
        {
            if (this.integerMode == 0)
            {
                return new FastInteger(this.smallValue);
            }
            else
            {
                return FastInteger.FromBig(this.largeValue);
            }
        }

        public FastIntegerFixed Increment()
        {
            if (this.integerMode == 0 && this.smallValue != Int32.MaxValue)
            {
                return new FastIntegerFixed(this.smallValue + 1);
            }
            else
            {
                return Add(this, FastIntegerFixed.One);
            }
        }

        public int Mod(int value)
        {
            if (value < 0)
            {
                throw new NotSupportedException();
            }
            if (this.integerMode == 0 && this.smallValue >= 0)
            {
                return this.smallValue % value;
            }
            else
            {
                EInteger retval = this.ToEInteger().Remainder(EInteger.FromInt32(value));
                return retval.ToInt32Checked();
            }
        }

        public static FastIntegerFixed Add(FastIntegerFixed a, FastIntegerFixed b)
        {
            if (a.integerMode == 0 && b.integerMode == 0)
            {
                if (a.smallValue == 0)
                {
                    return b;
                }
                if (b.smallValue == 0)
                {
                    return a;
                }
                if ((a.smallValue < 0 && b.smallValue >= Int32.MinValue -
                    a.smallValue) || (a.smallValue > 0 && b.smallValue <=
                    Int32.MaxValue - a.smallValue))
                {
                    return new FastIntegerFixed(a.smallValue + b.smallValue);
                }
            }
            EInteger bigA = a.ToEInteger();
            EInteger bigB = b.ToEInteger();
            return FastIntegerFixed.FromBig(bigA.Add(bigB));
        }

        public static FastIntegerFixed Subtract(
      FastIntegerFixed a,
      FastIntegerFixed b)
        {
            if (a.integerMode == 0 && b.integerMode == 0)
            {
                if (b.smallValue == 0)
                {
                    return a;
                }
                if ((b.smallValue < 0 && Int32.MaxValue + b.smallValue >= a.smallValue) ||
                    (b.smallValue > 0 && Int32.MinValue + b.smallValue <=
                            a.smallValue))
                {
                    return new FastIntegerFixed(a.smallValue - b.smallValue);
                }
            }
            EInteger bigA = a.ToEInteger();
            EInteger bigB = b.ToEInteger();
            return FastIntegerFixed.FromBig(bigA.Subtract(bigB));
        }

        public int CompareTo(FastIntegerFixed val)
        {
            switch ((this.integerMode << 2) | val.integerMode)
            {
                case (0 << 2) | 0:
                    {
                        int vsv = val.smallValue;
                        return (this.smallValue == vsv) ? 0 : (this.smallValue < vsv ? -1 :
                              1);
                    }
                case (0 << 2) | 2:
                    return this.ToEInteger().CompareTo(val.largeValue);
                case (2 << 2) | 0:
                case (2 << 2) | 2:
                    return this.largeValue.CompareTo(val.ToEInteger());
                default: throw new InvalidOperationException();
            }
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastIntegerFixed.Negate"]/*'/>
        internal FastIntegerFixed Negate()
        {
            switch (this.integerMode)
            {
                case 0:
                    if (this.smallValue == Int32.MinValue)
                    {
                        return FastIntegerFixed.FromBig(ValueNegativeInt32MinValue);
                    }
                    else
                    {
                        return new FastIntegerFixed(-smallValue);
                    }
                case 2:
                    return FastIntegerFixed.FromBig(-(EInteger)this.largeValue);
                default: throw new InvalidOperationException();
            }
        }

        internal bool IsEvenNumber
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return (this.smallValue & 1) == 0;
                    case 2:
                        return this.largeValue.IsEven;
                    default:
                        throw new InvalidOperationException();
                }
            }
        }

        internal bool CanFitInInt32()
        {
            return this.integerMode == 0 || this.largeValue.CanFitInInt32();
        }

        /// <include file='../../docs.xml'
        /// path='docs/doc[@name="M:PeterO.Numbers.FastIntegerFixed.ToString"]/*'/>
        public override string ToString()
        {
            switch (this.integerMode)
            {
                case 0:
                    return FastInteger.IntToString(this.smallValue);
                case 2:
                    return this.largeValue.ToString();
                default: return String.Empty;
            }
        }

        internal int Sign
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return (this.smallValue == 0) ? 0 : ((this.smallValue < 0) ? -1 :
                            1);
                    case 2:
                        return this.largeValue.Sign;
                    default: return 0;
                }
            }
        }

        internal bool IsValueZero
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return this.smallValue == 0;
                    case 2:
                        return this.largeValue.IsZero;
                    default:
                        return false;
                }
            }
        }

        internal bool CanFitInInt64()
        {
            switch (this.integerMode)
            {
                case 0:
                    return true;
                case 2:
                    {
                        return this.largeValue.CanFitInInt64();
                    }
                default:
                    throw new InvalidOperationException();
            }
        }

        internal long AsInt64()
        {
            switch (this.integerMode)
            {
                case 0:
                    return (long)this.smallValue;
                case 2:
                    {
                        return this.largeValue.ToInt64Unchecked();
                    }
                default:
                    throw new InvalidOperationException();
            }
        }

        internal int CompareToInt(int val)
        {
            switch (this.integerMode)
            {
                case 0:
                    return (val == this.smallValue) ? 0 : (this.smallValue < val ? -1 :
                    1);
                case 2:
                    return this.largeValue.CompareTo((EInteger)val);
                default: return 0;
            }
        }

        internal EInteger ToEInteger()
        {
            switch (this.integerMode)
            {
                case 0:
                    return EInteger.FromInt32(this.smallValue);
                case 2:
                    return this.largeValue;
                default: throw new InvalidOperationException();
            }
        }
    }

    internal interface IRadixMath<T>
    {
        IRadixMathHelper<T> GetHelper();

        T DivideToIntegerNaturalScale(T thisValue, T divisor, EContext ctx);

        T DivideToIntegerZeroScale(T thisValue, T divisor, EContext ctx);

        T Abs(T value, EContext ctx);

        T Negate(T value, EContext ctx);

        T Remainder(T thisValue, T divisor, EContext ctx, bool roundAfterDivide);

        T RemainderNear(T thisValue, T divisor, EContext ctx);

        T Pi(EContext ctx);

        T Power(T thisValue, T pow, EContext ctx);

        T Log10(T thisValue, EContext ctx);

        T Ln(T thisValue, EContext ctx);

        T Exp(T thisValue, EContext ctx);

        T SquareRoot(T thisValue, EContext ctx);

        T NextMinus(T thisValue, EContext ctx);

        T NextToward(T thisValue, T otherValue, EContext ctx);

        T NextPlus(T thisValue, EContext ctx);

        T DivideToExponent(
      T thisValue,
      T divisor,
      EInteger desiredExponent,
      EContext ctx);

        T Divide(T thisValue, T divisor, EContext ctx);

        T MinMagnitude(T a, T b, EContext ctx);

        T MaxMagnitude(T a, T b, EContext ctx);

        T Max(T a, T b, EContext ctx);

        T Min(T a, T b, EContext ctx);

        T Multiply(T thisValue, T other, EContext ctx);

        T MultiplyAndAdd(
      T thisValue,
      T multiplicand,
      T augend,
      EContext ctx);

        T Plus(T thisValue, EContext ctx);

        T RoundToPrecision(T thisValue, EContext ctx);

        T RoundAfterConversion(T thisValue, EContext ctx);

        T Quantize(T thisValue, T otherValue, EContext ctx);

        T RoundToExponentExact(
      T thisValue,
      EInteger expOther,
      EContext ctx);

        T RoundToExponentSimple(
      T thisValue,
      EInteger expOther,
      EContext ctx);

        T RoundToExponentNoRoundedFlag(
      T thisValue,
      EInteger exponent,
      EContext ctx);

        T Reduce(T thisValue, EContext ctx);

        T Add(T thisValue, T other, EContext ctx);

        T AddEx(
      T thisValue,
      T other,
      EContext ctx,
      bool roundToOperandPrecision);

        T CompareToWithContext(
      T thisValue,
      T otherValue,
      bool treatQuietNansAsSignaling,
      EContext ctx);

        int CompareTo(T thisValue, T otherValue);
    }

    internal interface IRadixMathHelper<T>
    {
        int GetRadix();

        int GetArithmeticSupport();

        int GetSign(T value);

        int GetFlags(T value);

        EInteger GetMantissa(T value);

        EInteger GetExponent(T value);

        FastIntegerFixed GetMantissaFastInt(T value);

        FastIntegerFixed GetExponentFastInt(T value);

        T ValueOf(int val);

        T CreateNewWithFlags(EInteger mantissa, EInteger exponent, int flags);

        T CreateNewWithFlagsFastInt(
      FastIntegerFixed mantissa,
      FastIntegerFixed exponent,
      int flags);

        IShiftAccumulator CreateShiftAccumulatorWithDigits(
      EInteger value,
      int lastDigit,
      int olderDigits);

        IShiftAccumulator CreateShiftAccumulatorWithDigitsFastInt(
      FastIntegerFixed value,
      int lastDigit,
      int olderDigits);

        IShiftAccumulator CreateShiftAccumulator(EInteger value);

        FastInteger DivisionShift(EInteger num, EInteger den);

        EInteger MultiplyByRadixPower(EInteger value, FastInteger power);
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.IShiftAccumulator"]/*'/>
    internal interface IShiftAccumulator
    {
        EInteger ShiftedInt { get; }

        FastInteger GetDigitLength();

        int OlderDiscardedDigits { get; }

        int LastDiscardedDigit { get; }

        FastInteger ShiftedIntFast { get; }

        FastInteger DiscardedDigitCount { get; }

        void TruncateRight(FastInteger bits);

        void ShiftRight(FastInteger bits);

        void ShiftRightInt(int bits);

        void ShiftToDigits(FastInteger bits, FastInteger preShift, bool truncate);
    }

    internal static class NumberUtility
    {
        private static readonly EInteger[] ValueBigIntPowersOfTen = {
      EInteger.One, (EInteger)10, (EInteger)100, (EInteger)1000,
      (EInteger)10000, (EInteger)100000, (EInteger)1000000,
      (EInteger)10000000, (EInteger)100000000, (EInteger)1000000000,
      (EInteger)10000000000L, (EInteger)100000000000L,
      (EInteger)1000000000000L, (EInteger)10000000000000L,
      (EInteger)100000000000000L, (EInteger)1000000000000000L,
      (EInteger)10000000000000000L,
      (EInteger)100000000000000000L, (EInteger)1000000000000000000L
    };

        private static readonly EInteger[] ValueBigIntPowersOfFive = {
      EInteger.One, (EInteger)5, (EInteger)25, (EInteger)125,
      (EInteger)625, (EInteger)3125, (EInteger)15625,
      (EInteger)78125, (EInteger)390625,
      (EInteger)1953125, (EInteger)9765625, (EInteger)48828125,
      (EInteger)244140625, (EInteger)1220703125,
      (EInteger)6103515625L, (EInteger)30517578125L,
      (EInteger)152587890625L, (EInteger)762939453125L,
      (EInteger)3814697265625L, (EInteger)19073486328125L,
      (EInteger)95367431640625L,
      (EInteger)476837158203125L, (EInteger)2384185791015625L,
      (EInteger)11920928955078125L,
      (EInteger)59604644775390625L, (EInteger)298023223876953125L,
      (EInteger)1490116119384765625L, (EInteger)7450580596923828125L
    };

        internal static int ShiftLeftOne(int[] arr)
        {
            unchecked
            {
                int carry = 0;
                for (int i = 0; i < arr.Length; ++i)
                {
                    int item = arr[i];
                    arr[i] = (int)(arr[i] << 1) | (int)carry;
                    carry = ((item >> 31) != 0) ? 1 : 0;
                }
                return carry;
            }
        }

        private static int CountTrailingZeros(int numberValue)
        {
            if (numberValue == 0)
            {
                return 32;
            }
            int i = 0;
            unchecked
            {
                if ((numberValue << 16) == 0)
                {
                    numberValue >>= 16;
                    i += 16;
                }
                if ((numberValue << 24) == 0)
                {
                    numberValue >>= 8;
                    i += 8;
                }
                if ((numberValue << 28) == 0)
                {
                    numberValue >>= 4;
                    i += 4;
                }
                if ((numberValue << 30) == 0)
                {
                    numberValue >>= 2;
                    i += 2;
                }
                if ((numberValue << 31) == 0)
                {
                    ++i;
                }
            }
            return i;
        }

        internal static int BitPrecisionInt(int numberValue)
        {
            if (numberValue == 0)
            {
                return 0;
            }
            int i = 32;
            unchecked
            {
                if ((numberValue >> 16) == 0)
                {
                    numberValue <<= 16;
                    i -= 8;
                }
                if ((numberValue >> 24) == 0)
                {
                    numberValue <<= 8;
                    i -= 8;
                }
                if ((numberValue >> 28) == 0)
                {
                    numberValue <<= 4;
                    i -= 4;
                }
                if ((numberValue >> 30) == 0)
                {
                    numberValue <<= 2;
                    i -= 2;
                }
                if ((numberValue >> 31) == 0)
                {
                    --i;
                }
            }
            return i;
        }

        internal static int ShiftAwayTrailingZerosTwoElements(int[] arr)
        {
            int a0 = arr[0];
            int a1 = arr[1];
            int tz = CountTrailingZeros(a0);
            if (tz == 0)
            {
                return 0;
            }
            unchecked
            {
                if (tz < 32)
                {
                    int carry = a1 << (32 - tz);
                    arr[0] = (int)((a0 >> tz) & (0x7fffffff >> (tz - 1))) | (int)carry;
                    arr[1] = (a1 >> tz) & (0x7fffffff >> (tz - 1));
                    return tz;
                }
                tz = CountTrailingZeros(a1);
                if (tz == 32)
                {
                    arr[0] = 0;
                }
                else if (tz > 0)
                {
                    arr[0] = (a1 >> tz) & (0x7fffffff >> (tz - 1));
                }
                else
                {
                    arr[0] = a1;
                }
                arr[1] = 0;
                return 32 + tz;
            }
        }

        private static readonly EInteger ValueBigShiftIteration =
          (EInteger)1000000;

        internal static EInteger ShiftLeft(EInteger val, EInteger bigShift)
        {
#if DEBUG
            if (val == null)
            {
                throw new ArgumentNullException(nameof(val));
            }
            if (bigShift == null)
            {
                throw new ArgumentNullException(nameof(bigShift));
            }
#endif
            if (val.IsZero)
            {
                return val;
            }
            while (bigShift.CompareTo(ValueBigShiftIteration) > 0)
            {
                val <<= 1000000;
                bigShift -= (EInteger)ValueBigShiftIteration;
            }
            int lastshift = (int)bigShift;
            val <<= lastshift;
            return val;
        }

        internal static EInteger ShiftLeftInt(EInteger val, int shift)
        {
#if DEBUG
            if (val == null)
            {
                throw new ArgumentNullException(nameof(val));
            }
#endif
            if (val.IsZero)
            {
                return val;
            }
            while (shift > 1000000)
            {
                val <<= 1000000;
                shift -= 1000000;
            }
            int lastshift = (int)shift;
            val <<= lastshift;
            return val;
        }

        internal static bool HasBitSet(int[] arr, int bit)
        {
            return (bit >> 5) < arr.Length && (arr[bit >> 5] & (1 << (bit & 31))) !=
            0;
        }

        private sealed class PowerCache
        {
            private const int MaxSize = 128;
            private readonly EInteger[] outputs;
            private readonly EInteger[] inputs;
            private readonly int[] inputsInts;

            public PowerCache()
            {
                this.outputs = new EInteger[MaxSize];
                this.inputs = new EInteger[MaxSize];
                this.inputsInts = new int[MaxSize];
            }

            private int size;

            public EInteger[] FindCachedPowerOrSmaller(EInteger bi)
            {
                EInteger[] ret = null;
                EInteger minValue = null;
                if (bi.CanFitInInt32())
                {
                    return this.FindCachedPowerIntOrSmaller(bi.ToInt32Checked());
                }
                lock (this.outputs)
                {
                    for (int i = 0; i < this.size; ++i)
                    {
                        if (this.inputs[i].CompareTo(bi) <= 0 && (minValue == null ||
                        this.inputs[i].CompareTo(minValue) >= 0))
                        {
                            // DebugUtility.Log("Have cached power (" + inputs[i] + "," + bi + ") ");
                            ret = new EInteger[2];
                            ret[0] = this.inputs[i];
                            ret[1] = this.outputs[i];
                            minValue = this.inputs[i];
                        }
                    }
                }
                return ret;
            }

            public EInteger[] FindCachedPowerIntOrSmaller(int precision)
            {
                EInteger[] ret = null;
                int integerMinValue = -1;
                lock (this.outputs)
                {
                    for (int i = 0; i < this.size; ++i)
                    {
                        if (this.inputsInts[i] >= 0 &&
                            this.inputsInts[i] <= precision && (integerMinValue == -1 ||
                        this.inputsInts[i] >= integerMinValue))
                        {
                            // DebugUtility.Log("Have cached power (" + inputs[i] + "," + bi + ") ");
                            ret = new EInteger[2];
                            ret[0] = this.inputs[i];
                            ret[1] = this.outputs[i];
                            integerMinValue = this.inputsInts[i];
                        }
                    }
                }
                return ret;
            }

            public EInteger GetCachedPower(EInteger bi)
            {
                if (bi.CanFitInInt32())
                {
                    return this.GetCachedPowerInt(bi.ToInt32Checked());
                }
                lock (this.outputs)
                {
                    for (int i = 0; i < this.size; ++i)
                    {
                        if (bi.Equals(this.inputs[i]))
                        {
                            if (i != 0)
                            {
                                EInteger tmp;
                                // Move to head of cache if it isn't already
                                tmp = this.inputs[i]; this.inputs[i] = this.inputs[0];
                                this.inputs[0] = tmp;
                                int tmpi = this.inputsInts[i]; this.inputsInts[i] =
                                this.inputsInts[0]; this.inputsInts[0] = tmpi;
                                tmp = this.outputs[i]; this.outputs[i] = this.outputs[0];
                                this.outputs[0] = tmp;
                                // Move formerly newest to next newest
                                if (i != 1)
                                {
                                    tmp = this.inputs[i]; this.inputs[i] = this.inputs[1];
                                    this.inputs[1] = tmp;
                                    tmpi = this.inputsInts[i]; this.inputsInts[i] =
                                    this.inputsInts[1]; this.inputsInts[1] = tmpi;
                                    tmp = this.outputs[i]; this.outputs[i] = this.outputs[1];
                                    this.outputs[1] = tmp;
                                }
                            }
                            return this.outputs[0];
                        }
                    }
                }
                return null;
            }

            public EInteger GetCachedPowerInt(int bi)
            {
                lock (this.outputs)
                {
                    for (int i = 0; i < this.size; ++i)
                    {
                        if (this.inputsInts[i] >= 0 && this.inputsInts[i] == bi)
                        {
                            if (i != 0)
                            {
                                EInteger tmp;
                                // Move to head of cache if it isn't already
                                tmp = this.inputs[i]; this.inputs[i] = this.inputs[0];
                                this.inputs[0] = tmp;
                                int tmpi = this.inputsInts[i]; this.inputsInts[i] =
                                this.inputsInts[0]; this.inputsInts[0] = tmpi;
                                tmp = this.outputs[i]; this.outputs[i] = this.outputs[0];
                                this.outputs[0] = tmp;
                                // Move formerly newest to next newest
                                if (i != 1)
                                {
                                    tmp = this.inputs[i]; this.inputs[i] = this.inputs[1];
                                    this.inputs[1] = tmp;
                                    tmpi = this.inputsInts[i]; this.inputsInts[i] =
                                    this.inputsInts[1]; this.inputsInts[1] = tmpi;
                                    tmp = this.outputs[i]; this.outputs[i] = this.outputs[1];
                                    this.outputs[1] = tmp;
                                }
                            }
                            return this.outputs[0];
                        }
                    }
                }
                return null;
            }

            public void AddPower(EInteger input, EInteger output)
            {
                lock (this.outputs)
                {
                    if (this.size < MaxSize)
                    {
                        // Shift newer entries down
                        for (int i = this.size; i > 0; --i)
                        {
                            this.inputs[i] = this.inputs[i - 1];
                            this.inputsInts[i] = this.inputsInts[i - 1];
                            this.outputs[i] = this.outputs[i - 1];
                        }
                        this.inputs[0] = input;
                        this.inputsInts[0] = input.CanFitInInt32() ? input.ToInt32Checked() : -1;
                        this.outputs[0] = output;
                        ++this.size;
                    }
                    else
                    {
                        // Shift newer entries down
                        for (int i = MaxSize - 1; i > 0; --i)
                        {
                            this.inputs[i] = this.inputs[i - 1];
                            this.inputsInts[i] = this.inputsInts[i - 1];
                            this.outputs[i] = this.outputs[i - 1];
                        }
                        this.inputs[0] = input;
                        this.inputsInts[0] = input.CanFitInInt32() ? input.ToInt32Checked() : -1;
                        this.outputs[0] = output;
                    }
                }
            }
        }

        private static readonly PowerCache ValuePowerOfFiveCache = new
        NumberUtility.PowerCache();

        private static readonly PowerCache ValuePowerOfTenCache = new
          NumberUtility.PowerCache();

        internal static EInteger FindPowerOfFiveFromBig(EInteger diff)
        {
            int sign = diff.Sign;
            if (sign < 0)
            {
                return EInteger.Zero;
            }
            if (sign == 0)
            {
                return EInteger.One;
            }
            FastInteger intcurexp = FastInteger.FromBig(diff);
            if (intcurexp.CompareToInt(54) <= 0)
            {
                return FindPowerOfFive(intcurexp.AsInt32());
            }
            EInteger mantissa = EInteger.One;
            EInteger bigpow;
            EInteger origdiff = diff;
            bigpow = ValuePowerOfFiveCache.GetCachedPower(origdiff);
            if (bigpow != null)
            {
                return bigpow;
            }
            EInteger[] otherPower =
            ValuePowerOfFiveCache.FindCachedPowerOrSmaller(origdiff);
            if (otherPower != null)
            {
                intcurexp.SubtractBig(otherPower[0]);
                bigpow = otherPower[1];
                mantissa = bigpow;
            }
            else
            {
                bigpow = EInteger.Zero;
            }
            while (intcurexp.Sign > 0)
            {
                if (intcurexp.CompareToInt(27) <= 0)
                {
                    bigpow = FindPowerOfFive(intcurexp.AsInt32());
                    mantissa *= (EInteger)bigpow;
                    break;
                }
                if (intcurexp.CompareToInt(9999999) <= 0)
                {
                    bigpow = FindPowerOfFive(1).Pow(intcurexp.AsInt32());
                    mantissa *= (EInteger)bigpow;
                    break;
                }
                if (bigpow.IsZero)
                {
                    bigpow = FindPowerOfFive(1).Pow(9999999);
                }
                mantissa *= bigpow;
                intcurexp.AddInt(-9999999);
            }
            ValuePowerOfFiveCache.AddPower(origdiff, mantissa);
            return mantissa;
        }

        private static readonly EInteger ValueBigInt36 = (EInteger)36;

        internal static EInteger FindPowerOfTenFromBig(EInteger
        bigintExponent)
        {
            int sign = bigintExponent.Sign;
            if (sign < 0)
            {
                return EInteger.Zero;
            }
            if (sign == 0)
            {
                return EInteger.One;
            }
            if (bigintExponent.CompareTo(ValueBigInt36) <= 0)
            {
                return FindPowerOfTen((int)bigintExponent);
            }
            FastInteger intcurexp = FastInteger.FromBig(bigintExponent);
            EInteger mantissa = EInteger.One;
            EInteger bigpow = EInteger.Zero;
            while (intcurexp.Sign > 0)
            {
                if (intcurexp.CompareToInt(18) <= 0)
                {
                    bigpow = FindPowerOfTen(intcurexp.AsInt32());
                    mantissa *= (EInteger)bigpow;
                    break;
                }
                if (intcurexp.CompareToInt(9999999) <= 0)
                {
                    int val = intcurexp.AsInt32();
                    bigpow = FindPowerOfFive(val);
                    bigpow <<= val;
                    mantissa *= (EInteger)bigpow;
                    break;
                }
                if (bigpow.IsZero)
                {
                    bigpow = FindPowerOfFive(9999999);
                    bigpow <<= 9999999;
                }
                mantissa *= bigpow;
                intcurexp.AddInt(-9999999);
            }
            return mantissa;
        }

        private static readonly EInteger ValueFivePower40 =
        ((EInteger)95367431640625L) * (EInteger)95367431640625L;

        internal static EInteger FindPowerOfFive(int precision)
        {
            if (precision < 0)
            {
                return EInteger.Zero;
            }
            if (precision <= 27)
            {
                return ValueBigIntPowersOfFive[(int)precision];
            }
            EInteger bigpow;
            EInteger ret;
            if (precision == 40)
            {
                return ValueFivePower40;
            }
            int startPrecision = precision;
            bigpow = ValuePowerOfFiveCache.GetCachedPowerInt(precision);
            if (bigpow != null)
            {
                return bigpow;
            }
            EInteger origPrecision = (EInteger)precision;
            if (precision <= 54)
            {
                if ((precision & 1) == 0)
                {
                    ret = ValueBigIntPowersOfFive[(int)(precision >> 1)];
                    ret *= (EInteger)ret;
                    ValuePowerOfFiveCache.AddPower(origPrecision, ret);
                    return ret;
                }
                ret = ValueBigIntPowersOfFive[27];
                bigpow = ValueBigIntPowersOfFive[((int)precision) - 27];
                ret *= (EInteger)bigpow;
                ValuePowerOfFiveCache.AddPower(origPrecision, ret);
                return ret;
            }
            if (precision > 40 && precision <= 94)
            {
                ret = ValueFivePower40;
                bigpow = FindPowerOfFive(precision - 40);
                ret *= (EInteger)bigpow;
                ValuePowerOfFiveCache.AddPower(origPrecision, ret);
                return ret;
            }
            EInteger[] otherPower;
            bool first = true;
            bigpow = EInteger.Zero;
            while (true)
            {
                otherPower =
                ValuePowerOfFiveCache.FindCachedPowerIntOrSmaller(precision);
                if (otherPower != null)
                {
                    EInteger otherPower0 = otherPower[0];
                    EInteger otherPower1 = otherPower[1];
                    precision -= (int)otherPower0;
                    if (first)
                    {
                        bigpow = otherPower[1];
                    }
                    else
                    {
                        bigpow *= (EInteger)otherPower1;
                    }
                    first = false;
                }
                else
                {
                    break;
                }
            }
            ret = !first ? bigpow : EInteger.One;
            while (precision > 0)
            {
                if (precision <= 27)
                {
                    bigpow = ValueBigIntPowersOfFive[(int)precision];
                    if (first)
                    {
                        ret = bigpow;
                    }
                    else
                    {
                        ret *= (EInteger)bigpow;
                    }
                    first = false;
                    break;
                }
                if (precision <= 9999999)
                {
                    // DebugUtility.Log("calcing pow for "+precision);
                    bigpow = ValueBigIntPowersOfFive[1].Pow(precision);
                    if (precision != startPrecision)
                    {
                        EInteger bigprec = (EInteger)precision;
                        ValuePowerOfFiveCache.AddPower(bigprec, bigpow);
                    }
                    if (first)
                    {
                        ret = bigpow;
                    }
                    else
                    {
                        ret *= (EInteger)bigpow;
                    }
                    first = false;
                    break;
                }
                if (bigpow.IsZero)
                {
                    bigpow = FindPowerOfFive(9999999);
                }
                if (first)
                {
                    ret = bigpow;
                }
                else
                {
                    ret *= (EInteger)bigpow;
                }
                first = false;
                precision -= 9999999;
            }
            ValuePowerOfFiveCache.AddPower(origPrecision, ret);
            return ret;
        }

        internal static EInteger FindPowerOfTen(int precision)
        {
            if (precision < 0)
            {
                return EInteger.Zero;
            }
            if (precision <= 18)
            {
                return ValueBigIntPowersOfTen[(int)precision];
            }
            EInteger bigpow;
            EInteger ret;
            int startPrecision = precision;
            bigpow = ValuePowerOfTenCache.GetCachedPowerInt(precision);
            if (bigpow != null)
            {
                return bigpow;
            }
            EInteger origPrecision = (EInteger)precision;
            if (precision <= 27)
            {
                int prec = (int)precision;
                ret = ValueBigIntPowersOfFive[prec];
                ret <<= prec;
                ValuePowerOfTenCache.AddPower(origPrecision, ret);
                return ret;
            }
            if (precision <= 36)
            {
                if ((precision & 1) == 0)
                {
                    ret = ValueBigIntPowersOfTen[(int)(precision >> 1)];
                    ret *= (EInteger)ret;
                    ValuePowerOfTenCache.AddPower(origPrecision, ret);
                    return ret;
                }
                ret = ValueBigIntPowersOfTen[18];
                bigpow = ValueBigIntPowersOfTen[((int)precision) - 18];
                ret *= (EInteger)bigpow;
                ValuePowerOfTenCache.AddPower(origPrecision, ret);
                return ret;
            }
            EInteger[] otherPower;
            bool first = true;
            bigpow = EInteger.Zero;
            while (true)
            {
                otherPower =
                ValuePowerOfTenCache.FindCachedPowerOrSmaller((EInteger)precision);
                if (otherPower != null)
                {
                    EInteger otherPower0 = otherPower[0];
                    EInteger otherPower1 = otherPower[1];
                    if (precision != otherPower0.ToInt32Checked())
                    {
                        // DebugUtility.Log("bigcachedpower miss {0} -> {1}"
                        // , precision, otherPower0);
                    }
                    precision -= (int)otherPower0;
                    if (first)
                    {
                        bigpow = otherPower[1];
                    }
                    else
                    {
                        bigpow *= (EInteger)otherPower1;
                    }
                    first = false;
                }
                else
                {
                    break;
                }
            }
            ret = !first ? bigpow : EInteger.One;
            while (precision > 0)
            {
                if (precision <= 18)
                {
                    bigpow = ValueBigIntPowersOfTen[(int)precision];
                    if (first)
                    {
                        ret = bigpow;
                    }
                    else
                    {
                        ret *= (EInteger)bigpow;
                    }
                    first = false;
                    break;
                }
                if (precision <= 9999999)
                {
                    // DebugUtility.Log("calcing pow for "+precision);
                    bigpow = FindPowerOfFive(precision);
                    bigpow <<= precision;
                    if (precision != startPrecision)
                    {
                        EInteger bigprec = (EInteger)precision;
                        ValuePowerOfTenCache.AddPower(bigprec, bigpow);
                    }
                    if (first)
                    {
                        ret = bigpow;
                    }
                    else
                    {
                        ret *= (EInteger)bigpow;
                    }
                    first = false;
                    break;
                }
                if (bigpow.IsZero)
                {
                    bigpow = FindPowerOfTen(9999999);
                }
                if (first)
                {
                    ret = bigpow;
                }
                else
                {
                    ret *= (EInteger)bigpow;
                }
                first = false;
                precision -= 9999999;
            }
            ValuePowerOfTenCache.AddPower(origPrecision, ret);
            return ret;
        }

        public static EInteger ReduceTrailingZeros(
          EInteger bigmant,
          FastInteger exponentMutable,
          int radix,
          FastInteger digits,
          FastInteger precision,
          FastInteger idealExp)
        {
#if DEBUG
            if (precision != null && digits == null)
            {
                throw new ArgumentException("doesn't satisfy precision==null || digits!=null");
            }
#endif
            if (bigmant.IsZero)
            {
                exponentMutable.SetInt(0);
                return bigmant;
            }
            EInteger bigradix = (EInteger)radix;
            int bitToTest = 0;
            FastInteger bitsToShift = new FastInteger(0);
            while (!bigmant.IsZero)
            {
                if (precision != null && digits.CompareTo(precision) == 0)
                {
                    break;
                }
                if (idealExp != null && exponentMutable.CompareTo(idealExp) == 0)
                {
                    break;
                }
                if (radix == 2)
                {
                    if (bitToTest < Int32.MaxValue)
                    {
                        if (bigmant.GetSignedBit(bitToTest))
                        {
                            break;
                        }
                        ++bitToTest;
                        bitsToShift.Increment();
                    }
                    else
                    {
                        if (!bigmant.IsEven)
                        {
                            break;
                        }
                        bigmant >>= 1;
                    }
                }
                else
                {
                    EInteger bigrem;
                    EInteger bigquo;
                    {
                        EInteger[] divrem = bigmant.DivRem(bigradix);
                        bigquo = divrem[0];
                        bigrem = divrem[1];
                    }
                    if (!bigrem.IsZero)
                    {
                        break;
                    }
                    bigmant = bigquo;
                }
                exponentMutable.Increment();
                if (digits != null)
                {
                    digits.Decrement();
                }
            }
            if (radix == 2 && !bitsToShift.IsValueZero)
            {
                while (bitsToShift.CompareToInt(1000000) > 0)
                {
                    bigmant >>= 1000000;
                    bitsToShift.SubtractInt(1000000);
                }
                int tmpshift = bitsToShift.AsInt32();
                bigmant >>= tmpshift;
            }
            return bigmant;
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.RadixMath`1"]/*'/>
    internal class RadixMath<T> : IRadixMath<T>
    {
        // Use given exponent
        private const int IntegerModeFixedScale = 1;
        // Use flexible exponent
        private const int IntegerModeRegular = 0;

        private static readonly int[] BitMasks = {
      0x7fffffff, 0x3fffffff, 0x1fffffff,
      0xfffffff, 0x7ffffff, 0x3ffffff, 0x1ffffff,
      0xffffff, 0x7fffff, 0x3fffff, 0x1fffff,
      0xfffff, 0x7ffff, 0x3ffff, 0x1ffff,
      0xffff, 0x7fff, 0x3fff, 0x1fff,
      0xfff, 0x7ff, 0x3ff, 0x1ff,
      0xff, 0x7f, 0x3f, 0x1f,
      0xf, 0x7, 0x3, 0x1
    };

        private static readonly long[] BitMasks64 = {
      0x7fffffffffffffffL, 0x3fffffffffffffffL, 0x1fffffffffffffffL,
  0xfffffffffffffffL, 0x7ffffffffffffffL, 0x3ffffffffffffffL,
        0x1ffffffffffffffL,
    0xffffffffffffffL, 0x7fffffffffffffL, 0x3fffffffffffffL,
        0x1fffffffffffffL,
      0xfffffffffffffL, 0x7ffffffffffffL, 0x3ffffffffffffL, 0x1ffffffffffffL,
      0xffffffffffffL, 0x7fffffffffffL, 0x3fffffffffffL, 0x1fffffffffffL,
      0xfffffffffffL, 0x7ffffffffffL, 0x3ffffffffffL, 0x1ffffffffffL,
      0xffffffffffL, 0x7fffffffffL, 0x3fffffffffL, 0x1fffffffffL,
      0xfffffffffL, 0x7ffffffffL, 0x3ffffffffL, 0x1ffffffffL,
      0xffffffffL, 0x7fffffff, 0x3fffffff, 0x1fffffff,
      0xfffffff, 0x7ffffff, 0x3ffffff, 0x1ffffff,
      0xffffff, 0x7fffff, 0x3fffff, 0x1fffff,
      0xfffff, 0x7ffff, 0x3ffff, 0x1ffff,
      0xffff, 0x7fff, 0x3fff, 0x1fff,
      0xfff, 0x7ff, 0x3ff, 0x1ff,
      0xff, 0x7f, 0x3f, 0x1f,
      0xf, 0x7, 0x3, 0x1
    };

        private static readonly int[] OverflowMaxes = {
     2147483647, 214748364, 21474836,
     2147483, 214748, 21474, 2147, 214, 21, 2
    };

        private static readonly EInteger ValueMinusOne = EInteger.Zero -
          EInteger.One;

        private static readonly int[] ValueTenPowers = {
      1, 10, 100, 1000, 10000, 100000,
      1000000, 10000000, 100000000,
      1000000000
    };

        private static readonly long[] OverflowMaxes64 = {
9223372036854775807L, 922337203685477580L,
  92233720368547758L, 9223372036854775L,
  922337203685477L, 92233720368547L,
  9223372036854L, 922337203685L,
  92233720368L, 9223372036L,
      922337203L, 92233720, 9223372,
      922337, 92233, 9223, 922, 92, 9 };

        private static readonly long[] ValueTenPowers64 = {
      1, 10, 100, 1000,
      10000, 100000, 1000000,
      10000000, 100000000, 1000000000,
      10000000000L, 100000000000L,
      1000000000000L, 10000000000000L,
      100000000000000L, 1000000000000000L,
      10000000000000000L, 100000000000000000L,
      1000000000000000000L
    };

        private readonly IRadixMathHelper<T> helper;
        private readonly int support;
        private readonly int thisRadix;

        // Conservative maximum base-10 radix power for
        // TryMultiplyByRadix Power; derived from
        // Int32.MaxValue*8/3 (8 is the number of bits in a byte;
        // 3 is a conservative estimate of log(10)/log(2).)
        private static EInteger valueMaxDigits = (EInteger)5726623058L;

        public RadixMath(IRadixMathHelper<T> helper)
        {
            this.helper = helper;
            this.support = helper.GetArithmeticSupport();
            this.thisRadix = helper.GetRadix();
        }

        public T Abs(T value, EContext ctx)
        {
            int flags = this.helper.GetFlags(value);
            return ((flags & BigNumberFlags.FlagSignalingNaN) != 0) ?
              this.SignalingNaNInvalid(value, ctx) : (
                ((flags & BigNumberFlags.FlagQuietNaN) != 0) ?
                this.ReturnQuietNaN(
        value,
        ctx) : (((flags & BigNumberFlags.FlagNegative) != 0) ? this.RoundToPrecision(
                   this.helper.CreateNewWithFlags(this.helper.GetMantissa(value), this.helper.GetExponent(value), flags & ~BigNumberFlags.FlagNegative),
                   ctx) : this.RoundToPrecision(
        value,
        ctx)));
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            if ((object)thisValue == null)
            {
                throw new ArgumentNullException(nameof(thisValue));
            }
            if ((object)other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            return this.AddEx(thisValue, other, ctx, false);
        }

        private FastInteger MaxDigitLengthForBitLength(FastInteger prec)
        {
            FastInteger result;
            if (this.thisRadix == 2)
            {
                result = prec;
            }
            else
            {
                if (this.thisRadix == 10 && prec.CompareToInt(2135) <= 0)
                {
                    int value = checked(1 + (((prec.AsInt32() - 1) * 631305) >> 21));
                    result = new FastInteger(value);
                }
                else
                {
                    EInteger valueEInteger = ShiftedMask(prec);
                    valueEInteger -= EInteger.One;
                    IShiftAccumulator shiftAccumulator =
                      this.helper.CreateShiftAccumulator(valueEInteger);
                    result = shiftAccumulator.GetDigitLength();
                }
            }
            return result;
        }

        private static EInteger ShiftedMask(FastInteger prec)
        {
            EInteger bthis = EInteger.One;
            prec = prec.Copy();
            while (prec.Sign > 0)
            {
                int num = (prec.CompareToInt(1000000) >= 0) ? 1000000 : prec.AsInt32();
                bthis <<= num;
                prec.SubtractInt(num);
            }
            return bthis - EInteger.One;
        }

        private bool IsHigherThanBitLength(EInteger ei, FastInteger prec)
        {
            return prec.CompareTo(FastInteger.FromBig(
              ei.GetUnsignedBitLengthAsEInteger())) < 0;
        }

        private T AddEx32Bit(
          int expcmp,
          FastIntegerFixed op1Exponent,
          FastIntegerFixed op1Mantissa,
          FastIntegerFixed op2Exponent,
          FastIntegerFixed op2Mantissa,
          FastIntegerFixed resultExponent,
          int thisFlags,
          int otherFlags,
          EContext ctx)
        {
            T retval = default(T);
            if ((expcmp == 0 || (op1Exponent.CanFitInInt32() &&
              op2Exponent.CanFitInInt32())) &&
              op1Mantissa.CanFitInInt32() && op2Mantissa.CanFitInInt32() &&
              (thisFlags & BigNumberFlags.FlagNegative) == (otherFlags &
                BigNumberFlags.FlagNegative))
            {
                int negflag = thisFlags & BigNumberFlags.FlagNegative;
                int e1int = 0;
                int e2int = 0;
                if (expcmp != 0)
                {
                    e1int = op1Exponent.AsInt32();
                    e2int = op2Exponent.AsInt32();
                }
                int m1, m2;
                bool haveRetval = false;
                if (expcmp == 0 || (e1int != Int32.MinValue && e2int !=
                     Int32.MinValue))
                {
                    int ediff = (expcmp == 0) ? 0 : ((e1int > e2int) ? (e1int - e2int) :
                      (e2int - e1int));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.AsInt32();
                        m2 = op2Mantissa.AsInt32();
                        if (m2 <= Int32.MaxValue - m1)
                        {
                            m1 += m2;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                              new FastIntegerFixed(m1),
                              resultExponent,
                              negflag);
                            haveRetval = true;
                        }
                    }
                    else if (ediff <= 9 && radix == 10)
                    {
                        int power = ValueTenPowers[ediff];
                        int maxoverflow = OverflowMaxes[ediff];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.AsInt32();
                            m2 = op2Mantissa.AsInt32();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op2Mantissa,
                                  op2Exponent,
                                  otherFlags);
                            }
                            else if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                if (m2 <= Int32.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      new FastIntegerFixed(m1),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.AsInt32();
                            m2 = op2Mantissa.AsInt32();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op1Mantissa,
                                  op1Exponent,
                                  thisFlags);
                            }
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                if (m1 <= Int32.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      new FastIntegerFixed(m2),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                    else if (ediff <= 30 && radix == 2)
                    {
                        int mask = BitMasks[ediff];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.AsInt32();
                            m2 = op2Mantissa.AsInt32();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op2Mantissa,
                                  op2Exponent,
                                  otherFlags);
                            }
                            else if ((m1 & mask) == m1)
                            {
                                m1 <<= ediff;
                                if (m2 <= Int32.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      new FastIntegerFixed(m1),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.AsInt32();
                            m2 = op2Mantissa.AsInt32();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op1Mantissa,
                                  op1Exponent,
                                  thisFlags);
                            }
                            else if ((m2 & mask) == m2)
                            {
                                m2 <<= ediff;
                                if (m1 <= Int32.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      new FastIntegerFixed(m2),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                }
                if (haveRetval)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
            }
            if ((thisFlags & BigNumberFlags.FlagNegative) != 0 &&
                (otherFlags & BigNumberFlags.FlagNegative) == 0)
            {
                FastIntegerFixed fftmp;
                fftmp = op1Exponent; op1Exponent = op2Exponent; op2Exponent = fftmp;
                fftmp = op1Mantissa; op1Mantissa = op2Mantissa; op2Mantissa = fftmp;
                int tmp;
                tmp = thisFlags; thisFlags = otherFlags; otherFlags = tmp;
                expcmp = -expcmp;
                resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
            }
            if ((expcmp == 0 || (op1Exponent.CanFitInInt32() &&
              op2Exponent.CanFitInInt32())) &&
              op1Mantissa.CanFitInInt32() && op2Mantissa.CanFitInInt32() &&
              (thisFlags & BigNumberFlags.FlagNegative) == 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) != 0 &&
              !op2Mantissa.IsValueZero && !op1Mantissa.IsValueZero)
            {
                int e1int = 0;
                int e2int = 0;
                int result = 0;
                if (expcmp != 0)
                {
                    e1int = op1Exponent.AsInt32();
                    e2int = op2Exponent.AsInt32();
                }
                int m1, m2;
                bool haveRetval = false;
                if (expcmp == 0 || (e1int != Int32.MinValue && e2int !=
                     Int32.MinValue))
                {
                    int ediff = (expcmp == 0) ? 0 : ((e1int > e2int) ? (e1int - e2int) :
                      (e2int - e1int));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.AsInt32();
                        m2 = op2Mantissa.AsInt32();
                        if (Int32.MinValue + m2 <= m1 && m1 >= m2)
                        {
                            m1 -= m2;
                            result = m1;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                              new FastIntegerFixed(m1),
                              resultExponent,
                              0);
                            haveRetval = true;
                        }
                    }
                    else if (radix == 10 && ediff <= 9)
                    {
                        int power = ValueTenPowers[ediff];
                        int maxoverflow = OverflowMaxes[ediff];
                        m1 = op1Mantissa.AsInt32();
                        m2 = op2Mantissa.AsInt32();
                        bool negbit = false;
                        bool multed = false;
                        if (expcmp < 0)
                        {
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                multed = true;
                            }
                        }
                        else
                        {
                            if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                multed = true;
                            }
                        }
                        if (multed && Int32.MinValue + m2 <= m1)
                        {
                            m1 -= m2;
                            if (m1 != Int32.MinValue)
                            {
                                negbit = m1 < 0;
                                result = Math.Abs(m1);
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  new FastIntegerFixed(result),
                                  resultExponent,
                                  negbit ? BigNumberFlags.FlagNegative : 0);
                                haveRetval = true;
                            }
                        }
                    }
                }
                if (haveRetval && result != 0)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
            }
            return default(T);
        }

        private T AddEx64Bit(
          long expcmp,
          FastIntegerFixed op1Exponent,
          FastIntegerFixed op1Mantissa,
          FastIntegerFixed op2Exponent,
          FastIntegerFixed op2Mantissa,
          FastIntegerFixed resultExponent,
          int thisFlags,
          int otherFlags,
          EContext ctx)
        {
            T retval = default(T);
            if ((expcmp == 0 || (op1Exponent.CanFitInInt64() &&
              op2Exponent.CanFitInInt64())) &&
              op1Mantissa.CanFitInInt64() && op2Mantissa.CanFitInInt64() &&
              (thisFlags & BigNumberFlags.FlagNegative) == (otherFlags &
                BigNumberFlags.FlagNegative))
            {
                int negflag = thisFlags & BigNumberFlags.FlagNegative;
                long e1long = 0;
                long e2long = 0;
                if (expcmp != 0)
                {
                    e1long = op1Exponent.AsInt64();
                    e2long = op2Exponent.AsInt64();
                }
                long m1, m2;
                bool haveRetval = false;
                if (expcmp == 0 || (e1long != Int64.MinValue && e2long !=
                       Int64.MinValue))
                {
                    long ediffLong = (expcmp == 0) ? 0 : ((e1long > e2long) ? (e1long -
                              e2long) : (e2long - e1long));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.AsInt64();
                        m2 = op2Mantissa.AsInt64();
                        if (m2 <= Int64.MaxValue - m1)
                        {
                            m1 += m2;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                              FastIntegerFixed.FromLong(m1),
                              resultExponent,
                              negflag);
                            haveRetval = true;
                        }
                    }
                    else if (ediffLong < ValueTenPowers64.Length && radix == 10)
                    {
                        long power = ValueTenPowers64[(int)ediffLong];
                        long maxoverflow = OverflowMaxes64[(int)ediffLong];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.AsInt64();
                            m2 = op2Mantissa.AsInt64();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op2Mantissa,
                                  op2Exponent,
                                  otherFlags);
                            }
                            else if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                if (m2 <= Int64.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      FastIntegerFixed.FromLong(m1),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.AsInt64();
                            m2 = op2Mantissa.AsInt64();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op1Mantissa,
                                  op1Exponent,
                                  thisFlags);
                            }
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                if (m1 <= Int64.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      FastIntegerFixed.FromLong(m2),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                    else if (ediffLong < BitMasks64.Length && radix == 2)
                    {
                        long mask = BitMasks64[(int)ediffLong];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.AsInt64();
                            m2 = op2Mantissa.AsInt64();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op2Mantissa,
                                  op2Exponent,
                                  otherFlags);
                            }
                            else if ((m1 & mask) == m1)
                            {
                                m1 <<= (int)ediffLong;
                                if (m2 <= Int64.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      FastIntegerFixed.FromLong(m1),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.AsInt64();
                            m2 = op2Mantissa.AsInt64();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  op1Mantissa,
                                  op1Exponent,
                                  thisFlags);
                            }
                            else if ((m2 & mask) == m2)
                            {
                                m2 <<= (int)ediffLong;
                                if (m1 <= Int64.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                      FastIntegerFixed.FromLong(m2),
                                      resultExponent,
                                      negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                }
                if (haveRetval)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
            }
            if ((thisFlags & BigNumberFlags.FlagNegative) != 0 &&
                (otherFlags & BigNumberFlags.FlagNegative) == 0)
            {
                FastIntegerFixed fftmp;
                fftmp = op1Exponent; op1Exponent = op2Exponent; op2Exponent = fftmp;
                fftmp = op1Mantissa; op1Mantissa = op2Mantissa; op2Mantissa = fftmp;
                int tmp;
                tmp = thisFlags; thisFlags = otherFlags; otherFlags = tmp;
                expcmp = -expcmp;
                resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
            }
            if ((expcmp == 0 || (op1Exponent.CanFitInInt64() &&
              op2Exponent.CanFitInInt64())) &&
              op1Mantissa.CanFitInInt64() && op2Mantissa.CanFitInInt64() &&
              (thisFlags & BigNumberFlags.FlagNegative) == 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) != 0 &&
              !op2Mantissa.IsValueZero && !op1Mantissa.IsValueZero)
            {
                long e1long = 0;
                long e2long = 0;
                long result = 0;
                if (expcmp != 0)
                {
                    e1long = op1Exponent.AsInt64();
                    e2long = op2Exponent.AsInt64();
                }
                long m1, m2;
                bool haveRetval = false;
                if (expcmp == 0 || (e1long != Int64.MinValue && e2long !=
                       Int64.MinValue))
                {
                    long ediffLong = (expcmp == 0) ? 0 : ((e1long > e2long) ? (e1long -
                              e2long) : (e2long - e1long));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.AsInt64();
                        m2 = op2Mantissa.AsInt64();
                        if (Int64.MinValue + m2 <= m1 && m1 >= m2)
                        {
                            m1 -= m2;
                            result = m1;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                              FastIntegerFixed.FromLong(m1),
                              resultExponent,
                              0);
                            haveRetval = true;
                        }
                    }
                    else if (radix == 10 && ediffLong < ValueTenPowers64.Length)
                    {
                        long power = ValueTenPowers64[(int)ediffLong];
                        long maxoverflow = OverflowMaxes64[(int)ediffLong];
                        m1 = op1Mantissa.AsInt64();
                        m2 = op2Mantissa.AsInt64();
                        bool negbit = false;
                        bool multed = false;
                        if (expcmp < 0)
                        {
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                multed = true;
                            }
                        }
                        else
                        {
                            if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                multed = true;
                            }
                        }
                        if (multed && Int64.MinValue + m2 <= m1)
                        {
                            m1 -= m2;
                            if (m1 != Int64.MinValue)
                            {
                                negbit = m1 < 0;
                                result = Math.Abs(m1);
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                  FastIntegerFixed.FromLong(result),
                                  resultExponent,
                                  negbit ? BigNumberFlags.FlagNegative : 0);
                                haveRetval = true;
                            }
                        }
                    }
                }
                if (haveRetval && result != 0)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
            }
            return default(T);
        }

        public T AddEx(
      T thisValue,
      T other,
      EContext ctx,
      bool roundToOperandPrecision)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                    {
                        if ((thisFlags & BigNumberFlags.FlagNegative) != (otherFlags &
              BigNumberFlags.FlagNegative))
                        {
                            return this.SignalInvalid(ctx);
                        }
                    }
                    return thisValue;
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return other;
                }
            }
            FastIntegerFixed op1Exponent = this.helper.GetExponentFastInt(thisValue);
            FastIntegerFixed op2Exponent = this.helper.GetExponentFastInt(other);
            FastIntegerFixed op1Mantissa = this.helper.GetMantissaFastInt(thisValue);
            FastIntegerFixed op2Mantissa = this.helper.GetMantissaFastInt(other);
            int expcmp = op1Exponent.CompareTo(op2Exponent);
            FastIntegerFixed resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
            T retval = default(T);
            if ((thisFlags & BigNumberFlags.FlagNegative) == 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) == 0)
            {
                if (expcmp < 0 && op2Mantissa.IsValueZero)
                {
                    return IsNullOrSimpleContext(ctx) ?
                     thisValue : this.RoundToPrecision(thisValue, ctx);
                }
                else if (expcmp >= 0 && op1Mantissa.IsValueZero)
                {
                    return IsNullOrSimpleContext(ctx) ?
                     other : this.RoundToPrecision(other, ctx);
                }
            }
            if (!roundToOperandPrecision)
            {
                retval = this.AddEx32Bit(
            expcmp,
            op1Exponent,
            op1Mantissa,
            op2Exponent,
            op2Mantissa,
            resultExponent,
            thisFlags,
            otherFlags,
            ctx);
                if ((object)retval != (object)default(T))
                {
                    return retval;
                }
                retval = this.AddEx64Bit(
            expcmp,
            op1Exponent,
            op1Mantissa,
            op2Exponent,
            op2Mantissa,
            resultExponent,
            thisFlags,
            otherFlags,
            ctx);
                if ((object)retval != (object)default(T))
                {
                    return retval;
                }
            }
            if (expcmp == 0)
            {
                retval = this.AddCore2(
                  op1Mantissa,
                  op2Mantissa,
                  op1Exponent,
                  thisFlags,
                  otherFlags,
                  ctx);
                if (!IsNullOrSimpleContext(ctx))
                {
                    retval = this.RoundToPrecision(retval, ctx);
                }
            }
            else
            {
                retval = this.AddExDiffExp(
          thisValue,
          other,
          thisFlags,
          otherFlags,
          ctx,
          expcmp,
          roundToOperandPrecision);
            }
            return retval;
        }

        public int CompareTo(T thisValue, T otherValue)
        {
            if (otherValue == null)
            {
                return 1;
            }
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                return CompareToHandleSpecial2(
          thisValue,
          otherValue,
          thisFlags,
          otherFlags);
            }
            return CompareToInternal(thisValue, otherValue, true, this.helper);
        }

        public T CompareToWithContext(
      T thisValue,
      T otherValue,
      bool treatQuietNansAsSignaling,
      EContext ctx)
        {
            if (otherValue == null)
            {
                return this.SignalInvalid(ctx);
            }
            T result = this.CompareToHandleSpecial(
        thisValue,
        otherValue,
        treatQuietNansAsSignaling,
        ctx);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = CompareToInternal(thisValue, otherValue, false, this.helper);
            return (cmp == -2) ? this.SignalInvalidWithMessage(
              ctx,
              "Out of memory ") :
              this.ValueOf(this.CompareTo(thisValue, otherValue), null);
        }

        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            return this.DivideInternal(
        thisValue,
        divisor,
        ctx,
        IntegerModeRegular,
        EInteger.Zero);
        }

        public T DivideToExponent(
      T thisValue,
      T divisor,
      EInteger desiredExponent,
      EContext ctx)
        {
            if (ctx != null && !ctx.ExponentWithinRange(desiredExponent))
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "Exponent not within exponent range: " + desiredExponent);
            }
            EContext ctx2 = (ctx == null) ?
              EContext.ForRounding(ERounding.HalfDown) :
              ctx.WithUnlimitedExponents().WithPrecision(0);
            T ret = this.DivideInternal(
        thisValue,
        divisor,
        ctx2,
        IntegerModeFixedScale,
        desiredExponent);
            if (!ctx2.HasMaxPrecision && this.IsFinite(ret))
            {
                // If a precision is given, call Quantize to ensure
                // that the value fits the precision
                ret = this.Quantize(ret, ret, ctx2);
                if ((ctx2.Flags & EContext.FlagInvalid) != 0)
                {
                    ctx2.Flags = EContext.FlagInvalid;
                }
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= ctx2.Flags;
            }
            return ret;
        }

        public T DivideToIntegerNaturalScale(
      T thisValue,
      T divisor,
      EContext ctx)
        {
            FastInteger desiredScale =
              FastInteger.FromBig(this.helper.GetExponent(thisValue))
              .SubtractBig(this.helper.GetExponent(divisor));
            EContext ctx2 =
              EContext.ForRounding(ERounding.Down).WithBigPrecision(ctx == null ?
        EInteger.Zero :
      ctx.Precision).WithBlankFlags();
            T ret = this.DivideInternal(
        thisValue,
        divisor,
        ctx2,
        IntegerModeFixedScale,
        EInteger.Zero);
            if ((ctx2.Flags & (EContext.FlagInvalid |
                          EContext.FlagDivideByZero)) != 0)
            {
                if (ctx != null && ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInvalid | EContext.FlagDivideByZero;
                }
                return ret;
            }
            bool neg = (this.helper.GetSign(thisValue) < 0) ^
              (this.helper.GetSign(divisor) < 0);
            // Now the exponent's sign can only be 0 or positive
            if (this.helper.GetMantissa(ret).IsZero)
            {
                // Value is 0, so just change the exponent
                // to the preferred one
                EInteger dividendExp = this.helper.GetExponent(thisValue);
                EInteger divisorExp = this.helper.GetExponent(divisor);
                ret = this.helper.CreateNewWithFlags(
          EInteger.Zero,
          dividendExp - (EInteger)divisorExp,
          this.helper.GetFlags(ret));
            }
            else
            {
                if (desiredScale.Sign < 0)
                {
                    // Desired scale is negative, shift left
                    desiredScale.Negate();
                    EInteger bigmantissa = this.helper.GetMantissa(ret);
                    bigmantissa = this.TryMultiplyByRadixPower(bigmantissa, desiredScale);
                    if (bigmantissa == null)
                    {
                        return this.SignalInvalidWithMessage(
                          ctx,
                          "Result requires too much memory");
                    }
                    EInteger exponentDivisor = this.helper.GetExponent(divisor);
                    ret = this.helper.CreateNewWithFlags(
            bigmantissa,
            this.helper.GetExponent(thisValue) - (EInteger)exponentDivisor,
            this.helper.GetFlags(ret));
                }
                else if (desiredScale.Sign > 0)
                {
                    // Desired scale is positive, shift away zeros
                    // but not after scale is reached
                    EInteger bigmantissa = this.helper.GetMantissa(ret);
                    FastInteger fastexponent =
                      FastInteger.FromBig(this.helper.GetExponent(ret));
                    EInteger bigradix = (EInteger)this.thisRadix;
                    while (true)
                    {
                        if (desiredScale.CompareTo(fastexponent) == 0)
                        {
                            break;
                        }
                        EInteger bigrem;
                        EInteger bigquo;
                        {
                            EInteger[] divrem = bigmantissa.DivRem(bigradix);
                            bigquo = divrem[0];
                            bigrem = divrem[1];
                        }
                        if (!bigrem.IsZero)
                        {
                            break;
                        }
                        bigmantissa = bigquo;
                        fastexponent.Increment();
                    }
                    ret = this.helper.CreateNewWithFlags(
                      bigmantissa,
                      fastexponent.AsEInteger(),
                      this.helper.GetFlags(ret));
                }
            }
            if (ctx != null)
            {
                ret = this.RoundToPrecision(ret, ctx);
            }
            ret = this.EnsureSign(ret, neg);
            return ret;
        }

        public T DivideToIntegerZeroScale(
      T thisValue,
      T divisor,
      EContext ctx)
        {
            EContext ctx2 = EContext.ForRounding(ERounding.Down)
              .WithBigPrecision(ctx == null ? EInteger.Zero :
                          ctx.Precision).WithBlankFlags();
            T ret = this.DivideInternal(
              thisValue,
              divisor,
              ctx2,
              IntegerModeFixedScale,
              EInteger.Zero);
            if ((ctx2.Flags & (EContext.FlagInvalid |
                          EContext.FlagDivideByZero)) != 0)
            {
                if (ctx.HasFlags)
                {
                    ctx.Flags |= ctx2.Flags & (EContext.FlagInvalid |
                              EContext.FlagDivideByZero);
                }
                return ret;
            }
            if (ctx != null)
            {
                ctx2 = ctx.WithBlankFlags().WithUnlimitedExponents();
                ret = this.RoundToPrecision(ret, ctx2);
                if ((ctx2.Flags & EContext.FlagRounded) != 0)
                {
                    return this.SignalInvalid(ctx);
                }
            }
            return ret;
        }

        public T Exp(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                // NOTE: Returning a signaling NaN is independent of
                // rounding mode
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                // NOTE: Returning a quiet NaN is independent of
                // rounding mode
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            EContext ctxCopy = ctx.WithBlankFlags();
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                if ((flags & BigNumberFlags.FlagNegative) != 0)
                {
                    T retval = this.helper.CreateNewWithFlags(
                      EInteger.Zero,
                      EInteger.Zero,
                      0);
                    retval = this.RoundToPrecision(
                      retval,
                      ctxCopy);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxCopy.Flags;
                    }
                    return retval;
                }
                return thisValue;
            }
            int sign = this.helper.GetSign(thisValue);
            T one = this.helper.ValueOf(1);
            EInteger guardDigits = this.thisRadix == 2 ? ctx.Precision +
              (EInteger)10 : (EInteger)10;
            EContext ctxdiv = SetPrecisionIfLimited(
              ctx,
              ctx.Precision + guardDigits)
              .WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
            if (sign == 0)
            {
                thisValue = this.RoundToPrecision(one, ctxCopy);
            }
            else if (sign > 0 && this.CompareTo(thisValue, one) <= 0)
            {
                thisValue = this.ExpInternal(thisValue, ctxdiv.Precision, ctxCopy);
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInexact |
                      EContext.FlagRounded;
                }
            }
            else if (sign < 0)
            {
                // exp(x) = 1/exp(-x) where x<0
                T val = this.Exp(this.NegateRaw(thisValue), ctxdiv);
                if ((ctxdiv.Flags & EContext.FlagOverflow) != 0 ||
                    !this.IsFinite(val))
                {
                    // Overflow, try again with expanded exponent range
                    EInteger newMax;
                    ctxdiv.Flags = 0;
                    newMax = ctx.EMax;
                    EInteger expdiff = ctx.EMin;
                    expdiff = newMax - (EInteger)expdiff;
                    newMax += (EInteger)expdiff;
                    ctxdiv = ctxdiv.WithBigExponentRange(ctxdiv.EMin, newMax);
                    thisValue = this.Exp(this.NegateRaw(thisValue), ctxdiv);
                    if ((ctxdiv.Flags & EContext.FlagOverflow) != 0)
                    {
                        // Still overflowed
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= BigNumberFlags.UnderflowFlags;
                        }
                        // Return a "subnormal" zero, with fake extra digits to stimulate
                        // rounding
                        EInteger ctxdivPrec = ctxdiv.Precision;
                        newMax = ctx.EMin;
                        if (ctx.AdjustExponent)
                        {
                            newMax -= (EInteger)ctxdivPrec;
                            newMax += EInteger.One;
                        }
                        thisValue = this.helper.CreateNewWithFlags(
                          EInteger.Zero,
                          newMax,
                          0);
                        return this.RoundToPrecisionInternal(
                          thisValue,
                          0,
                          1,
                          null,
                          false,
                          ctx);
                    }
                }
                else
                {
                    thisValue = val;
                }
                thisValue = this.Divide(one, thisValue, ctxCopy);
                // DebugUtility.Log("end= " + thisValue);
                // DebugUtility.Log("endbit "+this.BitMantissa(thisValue));
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInexact |
                      EContext.FlagRounded;
                }
            }
            else
            {
                T intpart = this.Quantize(
                  thisValue,
                  one,
                  EContext.ForRounding(ERounding.Down));
                if (!this.GetHelper().GetExponent(intpart).IsZero)
                {
                    throw new ArgumentException("integer part not zero, as expected");
                }
                if (this.CompareTo(thisValue, this.helper.ValueOf(50000)) > 0 &&
                    ctx.HasExponentRange)
                {
                    // Try to check for overflow quickly
                    // Do a trial powering using a lower number than e,
                    // and a power of 50000
                    this.PowerIntegral(
            this.helper.ValueOf(2),
            (EInteger)50000,
            ctxCopy);
                    if ((ctxCopy.Flags & EContext.FlagOverflow) != 0)
                    {
                        // The trial powering caused overflow, so exp will
                        // cause overflow as well
                        return this.SignalOverflow2(ctx, false);
                    }
                    ctxCopy.Flags = 0;
                    // Now do the same using the integer part of the operand
                    // as the power
                    this.PowerIntegral(
            this.helper.ValueOf(2),
            this.helper.GetMantissa(intpart),
            ctxCopy);
                    if ((ctxCopy.Flags & EContext.FlagOverflow) != 0)
                    {
                        // The trial powering caused overflow, so exp will
                        // cause overflow as well
                        return this.SignalOverflow2(ctx, false);
                    }
                    ctxCopy.Flags = 0;
                }
                T fracpart = this.Add(thisValue, this.NegateRaw(intpart), null);
                ctxdiv = SetPrecisionIfLimited(ctxdiv, ctxdiv.Precision + guardDigits)
                   .WithBlankFlags();
                fracpart = this.Add(one, this.Divide(fracpart, intpart, ctxdiv), null);
                ctxdiv.Flags = 0;
                // DebugUtility.Log("fracpart=" + fracpart);
                EInteger workingPrec = ctxdiv.Precision;
                workingPrec += (EInteger)17;
                thisValue = this.ExpInternal(fracpart, workingPrec, ctxdiv);
                // DebugUtility.Log("thisValue=" + thisValue);
                if ((ctxdiv.Flags & EContext.FlagUnderflow) != 0)
                {
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxdiv.Flags;
                    }
                }
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInexact |
                      EContext.FlagRounded;
                }
                thisValue = this.PowerIntegral(
          thisValue,
          this.helper.GetMantissa(intpart),
          ctxCopy);
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= ctxCopy.Flags;
            }
            return thisValue;
        }

        public IRadixMathHelper<T> GetHelper()
        {
            return this.helper;
        }

        public T Ln(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                // NOTE: Returning a signaling NaN is independent of
                // rounding mode
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                // NOTE: Returning a quiet NaN is independent of
                // rounding mode
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            int sign = this.helper.GetSign(thisValue);
            if (sign < 0)
            {
                return this.SignalInvalid(ctx);
            }
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                return thisValue;
            }
            EContext ctxCopy = ctx.WithBlankFlags();
            T one = this.helper.ValueOf(1);
            if (sign == 0)
            {
                return this.helper.CreateNewWithFlags(
          EInteger.Zero,
          EInteger.Zero,
          BigNumberFlags.FlagNegative | BigNumberFlags.FlagInfinity);
            }
            else
            {
                int cmpOne = this.CompareTo(thisValue, one);
                EContext ctxdiv = null;
                if (cmpOne == 0)
                {
                    // Equal to 1
                    thisValue = this.RoundToPrecision(
                     this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                     ctxCopy);
                }
                else if (cmpOne < 0)
                {
                    // Less than 1
                    FastInteger error = new FastInteger(10);
                    EInteger bigError = error.AsEInteger();
                    ctxdiv = SetPrecisionIfLimited(ctx, ctx.Precision + bigError)
                      .WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
                    T quarter = this.Divide(one, this.helper.ValueOf(4), ctxCopy);
                    if (this.CompareTo(thisValue, quarter) <= 0)
                    {
                        // One quarter or less
                        T half = this.Multiply(quarter, this.helper.ValueOf(2), null);
                        FastInteger roots = new FastInteger(0);
                        // Take square root until this value
                        // is one half or more
                        while (this.CompareTo(thisValue, half) < 0)
                        {
                            thisValue = this.SquareRoot(
                thisValue,
                ctxdiv.WithUnlimitedExponents());
                            roots.Increment();
                        }
                        thisValue = this.LnInternal(thisValue, ctxdiv.Precision, ctxdiv);
                        EInteger bigintRoots = PowerOfTwo(roots);
                        // Multiply back 2^X, where X is the number
                        // of square root calls
                        thisValue = this.Multiply(
              thisValue,
              this.helper.CreateNewWithFlags(bigintRoots, EInteger.Zero, 0),
              ctxCopy);
                    }
                    else
                    {
                        T smallfrac = this.Divide(one, this.helper.ValueOf(16), ctxdiv);
                        T closeToOne = this.Add(one, this.NegateRaw(smallfrac), null);
                        if (this.CompareTo(thisValue, closeToOne) >= 0)
                        {
                            // This value is close to 1, so use a higher working precision
                            error =

                this.helper.CreateShiftAccumulator(this.helper.GetMantissa(thisValue))
                              .GetDigitLength();
                            error = error.Copy();
                            error.AddInt(6);
                            error.AddBig(ctx.Precision);
                            bigError = error.AsEInteger();
                            thisValue = this.LnInternal(
                thisValue,
                error.AsEInteger(),
                ctxCopy);
                        }
                        else
                        {
                            thisValue = this.LnInternal(thisValue, ctxdiv.Precision, ctxCopy);
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        ctxCopy.Flags |= EContext.FlagInexact;
                        ctxCopy.Flags |= EContext.FlagRounded;
                    }
                }
                else
                {
                    // Greater than 1
                    T two = this.helper.ValueOf(2);
                    if (this.CompareTo(thisValue, two) >= 0)
                    {
                        FastInteger roots = new FastInteger(0);
                        FastInteger error;
                        EInteger bigError;
                        error = new FastInteger(10);
                        bigError = error.AsEInteger();
                        ctxdiv = SetPrecisionIfLimited(ctx, ctx.Precision + bigError)
                          .WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
                        T smallfrac = this.Divide(one, this.helper.ValueOf(10), ctxdiv);
                        T closeToOne = this.Add(one, smallfrac, null);
                        // Take square root until this value
                        // is close to 1
                        while (this.CompareTo(thisValue, closeToOne) >= 0)
                        {
                            thisValue = this.SquareRoot(
                thisValue,
                ctxdiv.WithUnlimitedExponents());
                            roots.Increment();
                        }
                        // Find -Ln(1/thisValue)
                        thisValue = this.Divide(one, thisValue, ctxdiv);
                        thisValue = this.LnInternal(thisValue, ctxdiv.Precision, ctxdiv);
                        thisValue = this.NegateRaw(thisValue);
                        EInteger bigintRoots = PowerOfTwo(roots);
                        // Multiply back 2^X, where X is the number
                        // of square root calls
                        thisValue = this.Multiply(
              thisValue,
              this.helper.CreateNewWithFlags(bigintRoots, EInteger.Zero, 0),
              ctxCopy);
                    }
                    else
                    {
                        FastInteger error;
                        EInteger bigError;
                        error = new FastInteger(10);
                        bigError = error.AsEInteger();
                        ctxdiv = SetPrecisionIfLimited(ctx, ctx.Precision + bigError)
                          .WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
                        T smallfrac = this.Divide(one, this.helper.ValueOf(16), ctxdiv);
                        T closeToOne = this.Add(one, smallfrac, null);
                        if (this.CompareTo(thisValue, closeToOne) < 0)
                        {
                            error =

                this.helper.CreateShiftAccumulator(this.helper.GetMantissa(thisValue))
                              .GetDigitLength();
                            error = error.Copy();
                            error.AddInt(6);
                            error.AddBig(ctx.Precision);
                            bigError = error.AsEInteger();
                            // Greater than 1 and close to 1, will require a higher working
                            // precision
                            thisValue = this.LnInternal(
                thisValue,
                error.AsEInteger(),
                ctxCopy);
                        }
                        else
                        {
                            // Find -Ln(1/thisValue)
                            thisValue = this.Divide(one, thisValue, ctxdiv);
                            thisValue = this.LnInternal(thisValue, ctxdiv.Precision, ctxCopy);
                            thisValue = this.NegateRaw(thisValue);
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        ctxCopy.Flags |= EContext.FlagInexact;
                        ctxCopy.Flags |= EContext.FlagRounded;
                    }
                }
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= ctxCopy.Flags;
            }
            return thisValue;
        }

        public T Log10(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                // NOTE: Returning a signaling NaN is independent of
                // rounding mode
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                // NOTE: Returning a quiet NaN is independent of
                // rounding mode
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            int sign = this.helper.GetSign(thisValue);
            if (sign < 0)
            {
                return this.SignalInvalid(ctx);
            }
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                return thisValue;
            }
            EContext ctxCopy = ctx.WithBlankFlags();
            T one = this.helper.ValueOf(1);
            // DebugUtility.Log("input " + thisValue);
            if (sign == 0)
            {
                // Result is negative infinity if input is 0
                thisValue = this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, BigNumberFlags.FlagNegative | BigNumberFlags.FlagInfinity),
                    ctxCopy);
            }
            else if (this.CompareTo(thisValue, one) == 0)
            {
                // Result is 0 if input is 1
                thisValue = this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                    ctxCopy);
            }
            else
            {
                EInteger exp = this.helper.GetExponent(thisValue);
                EInteger mant = this.helper.GetMantissa(thisValue);
                if (mant.Equals(EInteger.One) && this.thisRadix == 10)
                {
                    // Value is 1 and radix is 10, so the result is the exponent
                    thisValue = this.helper.CreateNewWithFlags(
                      exp.Abs(),
                      EInteger.Zero,
                      exp.Sign < 0 ? BigNumberFlags.FlagNegative : 0);
                    thisValue = this.RoundToPrecision(
            thisValue,
            ctxCopy);
                }
                else
                {
                    EInteger mantissa = this.helper.GetMantissa(thisValue);
                    FastInteger expTmp = FastInteger.FromBig(exp);
                    EInteger tenBig = (EInteger)10;
                    while (true)
                    {
                        EInteger bigrem;
                        EInteger bigquo;
                        {
                            EInteger[] divrem = mantissa.DivRem(tenBig);
                            bigquo = divrem[0];
                            bigrem = divrem[1];
                        }
                        if (!bigrem.IsZero)
                        {
                            break;
                        }
                        mantissa = bigquo;
                        expTmp.Increment();
                    }
                    if (mantissa.CompareTo(EInteger.One) == 0 &&
                        (this.thisRadix == 10 || expTmp.Sign == 0 || exp.IsZero))
                    {
                        // Value is an integer power of 10
                        thisValue = this.helper.CreateNewWithFlags(
                          expTmp.AsEInteger().Abs(),
                          EInteger.Zero,
                          expTmp.Sign < 0 ? BigNumberFlags.FlagNegative : 0);
                        thisValue = this.RoundToPrecision(
                            thisValue,
                            ctxCopy);
                    }
                    else
                    {
                        EContext ctxdiv = SetPrecisionIfLimited(
                          ctx,
                          ctx.Precision + (EInteger)10)
                          .WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
                        T logNatural = this.Ln(thisValue, ctxdiv);
                        T logTen = this.LnTenConstant(ctxdiv);
                        thisValue = this.Divide(logNatural, logTen, ctx);
                        // Treat result as inexact
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= EContext.FlagInexact |
                              EContext.FlagRounded;
                        }
                    }
                }
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= ctxCopy.Flags;
            }
            return thisValue;
        }

        public T Max(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, false, false);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(a, b);
            if (cmp != 0)
            {
                return cmp < 0 ? this.RoundToPrecision(b, ctx) :
                  this.RoundToPrecision(a, ctx);
            }
            int flagNegA = this.helper.GetFlags(a) & BigNumberFlags.FlagNegative;
            return (flagNegA != (this.helper.GetFlags(b) &
                          BigNumberFlags.FlagNegative)) ? ((flagNegA != 0) ?
                      this.RoundToPrecision(b, ctx) : this.RoundToPrecision(a, ctx)) :
              ((flagNegA == 0) ?
               (this.helper.GetExponent(a).CompareTo(this.helper.GetExponent(b)) > 0 ?
                this.RoundToPrecision(a, ctx) : this.RoundToPrecision(b, ctx)) :
               (this.helper.GetExponent(a).CompareTo(this.helper.GetExponent(b)) > 0 ?
                this.RoundToPrecision(b, ctx) : this.RoundToPrecision(a, ctx)));
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, false, true);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(this.AbsRaw(a), this.AbsRaw(b));
            return (cmp == 0) ? this.Max(a, b, ctx) : ((cmp > 0) ?
                      this.RoundToPrecision(
        a,
        ctx) : this.RoundToPrecision(
        b,
        ctx));
        }

        public T Min(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, true, false);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(a, b);
            if (cmp != 0)
            {
                return cmp > 0 ? this.RoundToPrecision(b, ctx) :
                  this.RoundToPrecision(a, ctx);
            }
            int signANeg = this.helper.GetFlags(a) & BigNumberFlags.FlagNegative;
            return (signANeg != (this.helper.GetFlags(b) &
                          BigNumberFlags.FlagNegative)) ? ((signANeg != 0) ?
                      this.RoundToPrecision(a, ctx) : this.RoundToPrecision(b, ctx)) :
              ((signANeg == 0) ?
               (this.helper.GetExponent(a).CompareTo(this.helper.GetExponent(b)) > 0 ?
                this.RoundToPrecision(b, ctx) : this.RoundToPrecision(a, ctx)) :
               (this.helper.GetExponent(a).CompareTo(this.helper.GetExponent(b)) > 0 ?
                this.RoundToPrecision(a, ctx) : this.RoundToPrecision(b, ctx)));
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, true, true);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(this.AbsRaw(a), this.AbsRaw(b));
            return (cmp == 0) ? this.Min(a, b, ctx) : ((cmp < 0) ?
                      this.RoundToPrecision(
        a,
        ctx) : this.RoundToPrecision(
        b,
        ctx));
        }

        public T Multiply(T thisValue, T other, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Attempt to multiply infinity by 0
                    bool negflag = ((thisFlags & BigNumberFlags.FlagNegative) != 0) ^
                      ((otherFlags & BigNumberFlags.FlagNegative) != 0);
                    return ((otherFlags & BigNumberFlags.FlagSpecial) == 0 &&
                       this.helper.GetMantissa(other).IsZero) ? this.SignalInvalid(ctx) :
                      this.EnsureSign(
            thisValue,
            negflag);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Attempt to multiply infinity by 0
                    bool negflag = ((thisFlags & BigNumberFlags.FlagNegative) != 0) ^
                      ((otherFlags & BigNumberFlags.FlagNegative) != 0);
                    return ((thisFlags & BigNumberFlags.FlagSpecial) == 0 &&
                            this.helper.GetMantissa(thisValue).IsZero) ?
                      this.SignalInvalid(ctx) : this.EnsureSign(other, negflag);
                }
            }
            EInteger bigintOp2 = this.helper.GetExponent(other);
            EInteger newexp = this.helper.GetExponent(thisValue) +
                (EInteger)bigintOp2;
            EInteger mantissaOp2 = this.helper.GetMantissa(other);
            // DebugUtility.Log("" + (this.helper.GetMantissa(thisValue)) + "," +
            // (this.helper.GetExponent(thisValue)) + " -> " + mantissaOp2 +", " +
            // (bigintOp2));
            thisFlags = (thisFlags & BigNumberFlags.FlagNegative) ^ (otherFlags &
        BigNumberFlags.FlagNegative);
            T ret =
              this.helper.CreateNewWithFlags(
                this.helper.GetMantissa(thisValue) * (EInteger)mantissaOp2,
                newexp,
                thisFlags);
            if (ctx != null && ctx != EContext.UnlimitedHalfEven)
            {
                ret = this.RoundToPrecision(ret, ctx);
            }
            return ret;
        }

        private T RoundIfPossible(T thisValue, EContext ctx)
        {
            if (this.helper.GetRadix() == 10 && ctx.HasMaxPrecision)
            {
                int flags = this.helper.GetFlags(thisValue);
                if ((flags & BigNumberFlags.FlagSpecial) != 0)
                {
                    return thisValue;
                }
                EInteger ei = this.helper.GetMantissa(thisValue);
                if (!ei.IsEven)
                {
                    return thisValue;
                }
                // Stores an underestimating approximation
                // of the digit length
                FastInteger approxDigitLength = new FastInteger(
                  ei.GetUnsignedBitLength() >> 2);
                FastInteger precision = FastInteger.FromBig(ctx.Precision);
                if (approxDigitLength.CompareTo(precision) <= 0)
                {
                    return thisValue;
                }
                // DebugUtility.Log("trying to round " + thisValue);
                EContext ctxCopy = ctx.WithBlankFlags();
                T newValue = this.RoundToPrecision(thisValue, ctxCopy);
                if ((ctxCopy.Flags & EContext.FlagInexact) == 0)
                {
                    // DebugUtility.Log("rounded to " + newValue);
                    return newValue;
                }
            }
            return thisValue;
        }

        public T MultiplyAndAdd(
      T thisValue,
      T multiplicand,
      T augend,
      EContext ctx)
        {
            if (multiplicand == null)
            {
                throw new ArgumentNullException(nameof(multiplicand));
            }
            if (augend == null)
            {
                throw new ArgumentNullException(nameof(augend));
            }
            EContext ctx2 = EContext.UnlimitedHalfEven.WithBlankFlags();
            T ret = this.MultiplyAddHandleSpecial(
        thisValue,
        multiplicand,
        augend,
        ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            T product = this.Multiply(thisValue, multiplicand, ctx2);
            ret = this.Add(product, augend, ctx);
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= ctx2.Flags;
            }
            return ret;
        }

        public T Negate(T value, EContext ctx)
        {
            int flags = this.helper.GetFlags(value);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(value, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(value, ctx);
            }
            EInteger mant = this.helper.GetMantissa(value);
            T zero;
            if ((flags & BigNumberFlags.FlagInfinity) == 0 && mant.IsZero)
            {
                if ((flags & BigNumberFlags.FlagNegative) == 0)
                {
                    // positive 0 minus positive 0 is always positive 0
                    zero = this.helper.CreateNewWithFlags(
            mant,
            this.helper.GetExponent(value),
            flags & ~BigNumberFlags.FlagNegative);
                    return this.RoundToPrecision(zero, ctx);
                }
                zero = ctx != null && ctx.Rounding == ERounding.Floor ?
                  this.helper.CreateNewWithFlags(
          mant,
          this.helper.GetExponent(value),
          flags | BigNumberFlags.FlagNegative) : this.helper.CreateNewWithFlags(
          mant,
          this.helper.GetExponent(value),
          flags & ~BigNumberFlags.FlagNegative);
                return this.RoundToPrecision(zero, ctx);
            }
            flags ^= BigNumberFlags.FlagNegative;
            return this.RoundToPrecision(
         this.helper.CreateNewWithFlags(mant, this.helper.GetExponent(value), flags),
         ctx);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            if (!ctx.HasExponentRange)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "doesn't satisfy ctx.HasExponentRange");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                if ((flags & BigNumberFlags.FlagNegative) != 0)
                {
                    return thisValue;
                }
                else
                {
                    EInteger bigexp2 = ctx.EMax;
                    EInteger bigprec = ctx.Precision;
                    if (ctx.AdjustExponent)
                    {
                        bigexp2 += EInteger.One;
                        bigexp2 -= (EInteger)bigprec;
                    }
                    EInteger overflowMant = this.TryMultiplyByRadixPower(
                        EInteger.One,
                        FastInteger.FromBig(ctx.Precision));
                    if (overflowMant == null)
                    {
                        return this.SignalInvalidWithMessage(
                          ctx,
                          "Result requires too much memory");
                    }
                    overflowMant -= EInteger.One;
                    return this.helper.CreateNewWithFlags(overflowMant, bigexp2, 0);
                }
            }
            FastInteger minexp = FastInteger.FromBig(ctx.EMin);
            if (ctx.AdjustExponent)
            {
                minexp.SubtractBig(ctx.Precision).Increment();
            }
            FastInteger bigexp =
              FastInteger.FromBig(this.helper.GetExponent(thisValue));
            if (bigexp.CompareTo(minexp) <= 0)
            {
                // Use a smaller exponent if the input exponent is already
                // very small
                minexp = bigexp.Copy().SubtractInt(2);
            }
            T quantum = this.helper.CreateNewWithFlags(
              EInteger.One,
              minexp.AsEInteger(),
              BigNumberFlags.FlagNegative);
            EContext ctx2;
            ctx2 = ctx.WithRounding(ERounding.Floor);
            return this.Add(thisValue, quantum, ctx2);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            if (!ctx.HasExponentRange)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "doesn't satisfy ctx.HasExponentRange");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                if ((flags & BigNumberFlags.FlagNegative) != 0)
                {
                    EInteger bigexp2 = ctx.EMax;
                    EInteger bigprec = ctx.Precision;
                    if (ctx.AdjustExponent)
                    {
                        bigexp2 += EInteger.One;
                        bigexp2 -= (EInteger)bigprec;
                    }
                    EInteger overflowMant = this.TryMultiplyByRadixPower(
                        EInteger.One,
                        FastInteger.FromBig(ctx.Precision));
                    if (overflowMant == null)
                    {
                        return this.SignalInvalidWithMessage(
                          ctx,
                          "Result requires too much memory");
                    }
                    overflowMant -= EInteger.One;
                    return this.helper.CreateNewWithFlags(
            overflowMant,
            bigexp2,
            BigNumberFlags.FlagNegative);
                }
                return thisValue;
            }
            FastInteger minexp = FastInteger.FromBig(ctx.EMin);
            if (ctx.AdjustExponent)
            {
                minexp.SubtractBig(ctx.Precision).Increment();
            }
            FastInteger bigexp =
              FastInteger.FromBig(this.helper.GetExponent(thisValue));
            if (bigexp.CompareTo(minexp) <= 0)
            {
                // Use a smaller exponent if the input exponent is already
                // very small
                minexp = bigexp.Copy().SubtractInt(2);
            }
            T quantum = this.helper.CreateNewWithFlags(
              EInteger.One,
              minexp.AsEInteger(),
              0);
            EContext ctx2;
            T val = thisValue;
            ctx2 = ctx.WithRounding(ERounding.Ceiling);
            return this.Add(val, quantum, ctx2);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            if (!ctx.HasExponentRange)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "doesn't satisfy ctx.HasExponentRange");
            }
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, otherValue, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
            }
            EContext ctx2;
            int cmp = this.CompareTo(thisValue, otherValue);
            if (cmp == 0)
            {
                return this.RoundToPrecision(
           this.EnsureSign(thisValue, (otherFlags & BigNumberFlags.FlagNegative) != 0),
           ctx.WithNoFlags());
            }
            else
            {
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if ((thisFlags & (BigNumberFlags.FlagInfinity |
                              BigNumberFlags.FlagNegative)) == (otherFlags &
                              (BigNumberFlags.FlagInfinity |
            BigNumberFlags.FlagNegative)))
                    {
                        // both values are the same infinity
                        return thisValue;
                    }
                    else
                    {
                        EInteger bigexp2 = ctx.EMax;
                        EInteger bigprec = ctx.Precision;
                        if (ctx.AdjustExponent)
                        {
                            bigexp2 += EInteger.One;
                            bigexp2 -= (EInteger)bigprec;
                        }
                        EInteger overflowMant = this.TryMultiplyByRadixPower(
                            EInteger.One,
                            FastInteger.FromBig(ctx.Precision));
                        if (overflowMant == null)
                        {
                            return this.SignalInvalidWithMessage(
                              ctx,
                              "Result requires too much memory");
                        }
                        overflowMant -= EInteger.One;
                        return this.helper.CreateNewWithFlags(
              overflowMant,
              bigexp2,
              thisFlags & BigNumberFlags.FlagNegative);
                    }
                }
                FastInteger minexp = FastInteger.FromBig(ctx.EMin);
                if (ctx.AdjustExponent)
                {
                    minexp.SubtractBig(ctx.Precision).Increment();
                }
                FastInteger bigexp =
                  FastInteger.FromBig(this.helper.GetExponent(thisValue));
                if (bigexp.CompareTo(minexp) < 0)
                {
                    // Use a smaller exponent if the input exponent is already
                    // very small
                    minexp = bigexp.Copy().SubtractInt(2);
                }
                else
                {
                    // Ensure the exponent is lower than the exponent range
                    // (necessary to flag underflow correctly)
                    minexp.SubtractInt(2);
                }
                T quantum = this.helper.CreateNewWithFlags(
                  EInteger.One,
                  minexp.AsEInteger(),
                  (cmp > 0) ? BigNumberFlags.FlagNegative : 0);
                T val = thisValue;
                ctx2 = ctx.WithRounding((cmp > 0) ? ERounding.Floor :
                            ERounding.Ceiling).WithBlankFlags();
                val = this.Add(val, quantum, ctx2);
                if ((ctx2.Flags & (EContext.FlagOverflow |
                            EContext.FlagUnderflow)) == 0)
                {
                    // Don't set flags except on overflow or underflow,
                    // in accordance with the DecTest test cases
                    ctx2.Flags = 0;
                }
                if ((ctx2.Flags & EContext.FlagUnderflow) != 0)
                {
                    EInteger bigmant = this.helper.GetMantissa(val);
                    EInteger maxmant = this.TryMultiplyByRadixPower(
                      EInteger.One,
                      FastInteger.FromBig(ctx.Precision).Decrement());
                    if (maxmant == null)
                    {
                        return this.SignalInvalidWithMessage(
                          ctx,
                          "Result requires too much memory");
                    }
                    if (bigmant.CompareTo(maxmant) >= 0 ||
                        ctx.Precision.CompareTo(EInteger.One) == 0)
                    {
                        // don't treat max-precision results as having underflowed
                        ctx2.Flags = 0;
                    }
                }
                if (ctx.HasFlags)
                {
                    ctx.Flags |= ctx2.Flags;
                }
                return val;
            }
        }

        public T Pi(EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            // Gauss-Legendre algorithm
            T a = this.helper.ValueOf(1);
            EContext ctxdiv = SetPrecisionIfLimited(
              ctx,
              ctx.Precision + (EInteger)10)
              .WithRounding(ERounding.OddOrZeroFiveUp);
            T two = this.helper.ValueOf(2);
            T b = this.Divide(a, this.SquareRoot(two, ctxdiv), ctxdiv);
            T four = this.helper.ValueOf(4);
            T half = ((this.thisRadix & 1) == 0) ?
              this.helper.CreateNewWithFlags(
        (EInteger)(this.thisRadix / 2),
        ValueMinusOne,
        0) : default(T);
            T t = this.Divide(a, four, ctxdiv);
            bool more = true;
            int lastCompare = 0;
            int vacillations = 0;
            T lastGuess = default(T);
            T guess = default(T);
            EInteger powerTwo = EInteger.One;
            while (more)
            {
                lastGuess = guess;
                T aplusB = this.Add(a, b, null);
                T newA = (half == null) ? this.Divide(aplusB, two, ctxdiv) :
                  this.Multiply(aplusB, half, null);
                T valueAMinusNewA = this.Add(a, this.NegateRaw(newA), null);
                if (!a.Equals(b))
                {
                    T atimesB = this.Multiply(a, b, ctxdiv);
                    b = this.SquareRoot(atimesB, ctxdiv);
                }
                a = newA;
                guess = this.Multiply(aplusB, aplusB, null);
                guess = this.Divide(guess, this.Multiply(t, four, null), ctxdiv);
                T newGuess = guess;
                if ((object)lastGuess != (object)default(T))
                {
                    int guessCmp = this.CompareTo(lastGuess, newGuess);
                    if (guessCmp == 0)
                    {
                        more = false;
                    }
                    else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                            guessCmp < 0))
                    {
                        // Guesses are vacillating
                        ++vacillations;
                        more &= vacillations <= 3 || guessCmp <= 0;
                    }
                    lastCompare = guessCmp;
                }
                if (more)
                {
                    T tmpT = this.Multiply(valueAMinusNewA, valueAMinusNewA, null);
                    tmpT = this.Multiply(
            tmpT,
            this.helper.CreateNewWithFlags(powerTwo, EInteger.Zero, 0),
            null);
                    t = this.Add(t, this.NegateRaw(tmpT), ctxdiv);
                    powerTwo <<= 1;
                }
                guess = newGuess;
            }
            return this.RoundToPrecision(guess, ctx);
        }

        public T Plus(T thisValue, EContext context)
        {
            return this.RoundToPrecisionInternal(
        thisValue,
        0,
        0,
        null,
        true,
        context);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            T ret = this.HandleNotANumber(thisValue, pow, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            int thisSign = this.helper.GetSign(thisValue);
            int powSign = this.helper.GetSign(pow);
            int thisFlags = this.helper.GetFlags(thisValue);
            int powFlags = this.helper.GetFlags(pow);
            if (thisSign == 0 && powSign == 0)
            {
                // Both operands are zero: invalid
                return this.SignalInvalid(ctx);
            }
            if (thisSign < 0 && (powFlags & BigNumberFlags.FlagInfinity) != 0)
            {
                // This value is negative and power is infinity: invalid
                return this.SignalInvalid(ctx);
            }
            if (thisSign > 0 && (thisFlags & BigNumberFlags.FlagInfinity) == 0 &&
                (powFlags & BigNumberFlags.FlagInfinity) != 0)
            {
                // Power is infinity and this value is greater than
                // zero and not infinity
                int cmp = this.CompareTo(thisValue, this.helper.ValueOf(1));
                if (cmp < 0)
                {
                    // Value is less than 1
                    if (powSign < 0)
                    {
                        // Power is negative infinity, return positive infinity
                        return this.helper.CreateNewWithFlags(
              EInteger.Zero,
              EInteger.Zero,
              BigNumberFlags.FlagInfinity);
                    }
                    // Power is positive infinity, return 0
                    return this.RoundToPrecision(
                     this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                     ctx);
                }
                if (cmp == 0)
                {
                    // Extend the precision of the mantissa as much as possible,
                    // in the special case that this value is 1
                    return this.ExtendPrecision(this.helper.ValueOf(1), ctx);
                }
                // Value is greater than 1
                if (powSign > 0)
                {
                    // Power is positive infinity, return positive infinity
                    return pow;
                }
                // Power is negative infinity, return 0
                return this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                    ctx);
            }
            EInteger powExponent = this.helper.GetExponent(pow);
            bool isPowIntegral = powExponent.Sign > 0;
            bool isPowOdd = false;
            T powInt = default(T);
            if (!isPowIntegral)
            {
                powInt = this.Quantize(
              pow,
              this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
              EContext.ForRounding(ERounding.Down));
                isPowIntegral = this.CompareTo(powInt, pow) == 0;
                isPowOdd = !this.helper.GetMantissa(powInt).IsEven;
            }
            else
            {
                if (powExponent.Equals(EInteger.Zero))
                {
                    isPowOdd = !this.helper.GetMantissa(powInt).IsEven;
                }
                else if (this.thisRadix % 2 == 0)
                {
                    // Never odd for even radixes
                    isPowOdd = false;
                }
                else
                {
                    powInt = this.Quantize(
            pow,
            this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
            EContext.ForRounding(ERounding.Down));
                    isPowOdd = !this.helper.GetMantissa(powInt).IsEven;
                }
            }
            // DebugUtility.Log("pow=" + pow + " powint=" + powInt);
            bool isResultNegative = (thisFlags & BigNumberFlags.FlagNegative) != 0 &&
              (powFlags & BigNumberFlags.FlagInfinity) == 0 && isPowIntegral &&
              isPowOdd;
            if (thisSign == 0 && powSign != 0)
            {
                int infinityFlags = (powSign < 0) ? BigNumberFlags.FlagInfinity : 0;
                if (isResultNegative)
                {
                    infinityFlags |= BigNumberFlags.FlagNegative;
                }
                thisValue = this.helper.CreateNewWithFlags(
                  EInteger.Zero,
                  EInteger.Zero,
                  infinityFlags);
                if ((infinityFlags & BigNumberFlags.FlagInfinity) == 0)
                {
                    thisValue = this.RoundToPrecision(thisValue, ctx);
                }
                return thisValue;
            }
            if ((!isPowIntegral || powSign < 0) && (ctx == null ||
                          !ctx.HasMaxPrecision))
            {
                const string ValueOutputMessage =
                    "ctx is null or has unlimited precision, " +
                    "and pow's exponent is not an integer or is negative";
                return this.SignalInvalidWithMessage(
          ctx,
          ValueOutputMessage);
            }
            if (thisSign < 0 && !isPowIntegral)
            {
                return this.SignalInvalid(ctx);
            }
            if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
            {
                // This value is infinity
                int negflag = isResultNegative ? BigNumberFlags.FlagNegative : 0;
                return (powSign > 0) ? this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, negflag | BigNumberFlags.FlagInfinity),
                    ctx) : ((powSign < 0) ? this.RoundToPrecision(
             this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, negflag),
             ctx) : this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.One, EInteger.Zero, 0),
                    ctx));
            }
            if (powSign == 0)
            {
                return
                  this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.One, EInteger.Zero, 0),
                    ctx);
            }
            if (isPowIntegral)
            {
                // Special case for 1
                if (this.CompareTo(thisValue, this.helper.ValueOf(1)) == 0)
                {
                    return (!this.IsWithinExponentRangeForPow(pow, ctx)) ?
                      this.SignalInvalid(ctx) : this.helper.ValueOf(1);
                }
                if ((object)powInt == (object)default(T))
                {
                    powInt = this.Quantize(
            pow,
            this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
            EContext.ForRounding(ERounding.Down));
                }
                EInteger signedMant = this.helper.GetMantissa(powInt);
                if (powSign < 0)
                {
                    signedMant = -signedMant;
                }
                // DebugUtility.Log("tv=" + thisValue + " mant=" + signedMant);
                return this.PowerIntegral(thisValue, signedMant, ctx);
            }
            // Special case for 1
            if (this.CompareTo(thisValue, this.helper.ValueOf(1)) == 0 && powSign >
                0)
            {
                return (!this.IsWithinExponentRangeForPow(pow, ctx)) ?
                  this.SignalInvalid(ctx) :
                  this.ExtendPrecision(this.helper.ValueOf(1), ctx);
            }
#if DEBUG
            if (ctx == null)
            {
                throw new ArgumentNullException(nameof(ctx));
            }
#endif
            // Special case for 0.5
            if (this.thisRadix == 10 || this.thisRadix == 2)
            {
                T half = (this.thisRadix == 10) ? this.helper.CreateNewWithFlags(
                    (EInteger)5,
                    ValueMinusOne,
                    0) : this.helper.CreateNewWithFlags(
          EInteger.One,
          ValueMinusOne,
          0);
                if (this.CompareTo(pow, half) == 0 &&
                    this.IsWithinExponentRangeForPow(pow, ctx) &&
                    this.IsWithinExponentRangeForPow(thisValue, ctx))
                {
                    EContext ctxCopy = ctx.WithBlankFlags();
                    thisValue = this.SquareRoot(thisValue, ctxCopy);
                    ctxCopy.Flags |= EContext.FlagInexact;
                    ctxCopy.Flags |= EContext.FlagRounded;
                    if ((ctxCopy.Flags & EContext.FlagSubnormal) != 0)
                    {
                        ctxCopy.Flags |= EContext.FlagUnderflow;
                    }
                    thisValue = this.ExtendPrecision(thisValue, ctxCopy);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxCopy.Flags;
                    }
                    return thisValue;
                }
            }
            int guardDigitCount = this.thisRadix == 2 ? 32 : 10;
            EInteger guardDigits = (EInteger)guardDigitCount;
            EContext ctxdiv = SetPrecisionIfLimited(
              ctx,
              ctx.Precision + guardDigits);
            ctxdiv = ctxdiv.WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
            T lnresult = this.Ln(thisValue, ctxdiv);
            /* DebugUtility.Log("guard= " + guardDigits + " prec=" + ctx.Precision+
              " newprec= " + ctxdiv.Precision);
            DebugUtility.Log("pwrIn " + pow);
            DebugUtility.Log("lnIn " + thisValue);
            DebugUtility.Log("lnOut " + lnresult);
            DebugUtility.Log("lnOut[n] "+this.NextPlus(lnresult,ctxdiv));*/
            lnresult = this.Multiply(lnresult, pow, ctxdiv);
            // DebugUtility.Log("expIn " + lnresult);
            // Now use original precision and rounding mode
            ctxdiv = ctx.WithBlankFlags();
            lnresult = this.Exp(lnresult, ctxdiv);
            if ((ctxdiv.Flags & (EContext.FlagClamped |
                          EContext.FlagOverflow)) != 0)
            {
                if (!this.IsWithinExponentRangeForPow(thisValue, ctx))
                {
                    return this.SignalInvalid(ctx);
                }
                if (!this.IsWithinExponentRangeForPow(pow, ctx))
                {
                    return this.SignalInvalid(ctx);
                }
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= ctxdiv.Flags;
            }
            return lnresult;
        }

        private bool IsSubnormal(T value, EContext ctx)
        {
            bool flag = ctx == null || !ctx.HasMaxPrecision;
            bool result;
            if (flag)
            {
                result = false;
            }
            else
            {
                FastInteger fastInteger = FastInteger.FromBig(this.helper.GetExponent(value));
                FastInteger val = FastInteger.FromBig(ctx.EMin);
                bool adjustExponent = ctx.AdjustExponent;
                if (adjustExponent)
                {
                    FastIntegerFixed mantissaFastInt = this.helper.GetMantissaFastInt(value);
                    FastInteger digitLength =
                      this.helper.CreateShiftAccumulatorWithDigitsFastInt(
                mantissaFastInt,
                0,
                0).GetDigitLength();
                    fastInteger.Add(digitLength).SubtractInt(1);
                }
                result = fastInteger.CompareTo(val) < 0;
            }
            return result;
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, otherValue, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if (((thisFlags & otherFlags) & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.RoundToPrecision(thisValue, ctx);
                }
                // At this point, it's only the case that either value
                // is infinity
                return this.SignalInvalid(ctx);
            }
            EInteger expOther = this.helper.GetExponent(otherValue);
            if (ctx != null && !ctx.ExponentWithinRange(expOther))
            {
                // DebugUtility.Log("exp not within range");
                return this.SignalInvalidWithMessage(
          ctx,
          "Exponent not within exponent range: " + expOther);
            }
            EContext tmpctx = (ctx == null ?
        EContext.ForRounding(ERounding.HalfEven) :
                          ctx.Copy()).WithBlankFlags();
            EInteger mantThis = this.helper.GetMantissa(thisValue);
            EInteger expThis = this.helper.GetExponent(thisValue);
            int expcmp = expThis.CompareTo(expOther);
            int negativeFlag = this.helper.GetFlags(thisValue) &
              BigNumberFlags.FlagNegative;
            T ret = default(T);
            if (expcmp == 0)
            {
                // DebugUtility.Log("exp same");
                ret = this.RoundToPrecision(thisValue, tmpctx);
            }
            else if (mantThis.IsZero)
            {
                // DebugUtility.Log("mant is 0");
                ret = this.helper.CreateNewWithFlags(
          EInteger.Zero,
          expOther,
          negativeFlag);
                ret = this.RoundToPrecision(ret, tmpctx);
            }
            else if (expcmp > 0)
            {
                // Other exponent is less
                // DebugUtility.Log("other exp less");
                FastInteger radixPower =
                       FastInteger.FromBig(expThis).SubtractBig(expOther);
                if (tmpctx.Precision.Sign > 0 &&
                    radixPower.CompareTo(FastInteger.FromBig(tmpctx.Precision)
                        .AddInt(10)) > 0)
                {
                    // Radix power is much too high for the current precision
                    // DebugUtility.Log("result too high for prec:" +
                    // tmpctx.Precision + " radixPower= " + radixPower);
                    return this.SignalInvalidWithMessage(
            ctx,
            "Result too high for current precision");
                }
                mantThis = this.TryMultiplyByRadixPower(mantThis, radixPower);
                if (mantThis == null)
                {
                    return this.SignalInvalidWithMessage(
                      ctx,
                      "Result requires too much memory");
                }
                ret = this.helper.CreateNewWithFlags(mantThis, expOther, negativeFlag);
                ret = this.RoundToPrecision(ret, tmpctx);
            }
            else
            {
                // Other exponent is greater
                // DebugUtility.Log("other exp greater");
                FastInteger shift = FastInteger.FromBig(expOther).SubtractBig(expThis);
                ret = this.RoundToPrecisionInternal(
          thisValue,
          0,
          0,
          shift,
          false,
          tmpctx);
            }
            if ((tmpctx.Flags & EContext.FlagOverflow) != 0)
            {
                // DebugUtility.Log("overflow occurred");
                return this.SignalInvalid(ctx);
            }
            if (ret == null || !this.helper.GetExponent(ret).Equals(expOther))
            {
                // DebugUtility.Log("exp not same "+ret);
                return this.SignalInvalid(ctx);
            }
            ret = this.EnsureSign(ret, negativeFlag != 0);
            if (ctx != null && ctx.HasFlags)
            {
                int flags = tmpctx.Flags;
                flags &= ~EContext.FlagUnderflow;
                bool flag12 = expcmp < 0 && !this.helper.GetMantissa(ret).IsZero &&
                  this.IsSubnormal(ret, ctx);
                if (flag12)
                {
                    flags |= EContext.FlagSubnormal;
                }
                ctx.Flags |= flags;
            }
            return ret;
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            return this.ReduceToPrecisionAndIdealExponent(thisValue, ctx, null, null);
        }

        public T Remainder(
      T thisValue,
      T divisor,
      EContext ctx,
      bool roundAfterDivide)
        {
            EContext ctx2 = ctx?.WithBlankFlags();
            T ret = this.RemainderHandleSpecial(thisValue, divisor, ctx2);
            if ((object)ret != (object)default(T))
            {
                TransferFlags(ctx, ctx2);
                return ret;
            }
            ret = this.DivideToIntegerZeroScale(
        thisValue,
        divisor,
        roundAfterDivide ? ctx2 : null);
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            ret = this.Add(
        thisValue,
        this.NegateRaw(this.Multiply(ret, divisor, null)),
        ctx2);
            ret = this.EnsureSign(
          ret,
          (this.helper.GetFlags(thisValue) & BigNumberFlags.FlagNegative) != 0);
            TransferFlags(ctx, ctx2);
            return ret;
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            EContext ctx2 = ctx == null ?
              EContext.ForRounding(ERounding.HalfEven).WithBlankFlags() :
              ctx.WithRounding(ERounding.HalfEven).WithBlankFlags();
            T ret = this.RemainderHandleSpecial(thisValue, divisor, ctx2);
            if ((object)ret != (object)default(T))
            {
                TransferFlags(ctx, ctx2);
                return ret;
            }
            ret = this.DivideInternal(
        thisValue,
        divisor,
        ctx2,
        IntegerModeFixedScale,
        EInteger.Zero);
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            ctx2 = ctx2.WithBlankFlags();
            ret = this.RoundToPrecision(ret, ctx2);
            if ((ctx2.Flags & (EContext.FlagRounded |
                          EContext.FlagInvalid)) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            ctx2 = ctx == null ? EContext.UnlimitedHalfEven.WithBlankFlags() :
              ctx.WithBlankFlags();
            T ret2 = this.Add(
              thisValue,
              this.NegateRaw(this.Multiply(ret, divisor, null)),
              ctx2);
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            if (this.helper.GetFlags(ret2) == 0 &&
                   this.helper.GetMantissa(ret2).IsZero)
            {
                ret2 = this.EnsureSign(
          ret2,
          (this.helper.GetFlags(thisValue) & BigNumberFlags.FlagNegative) != 0);
            }
            TransferFlags(ctx, ctx2);
            return ret2;
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            // DebugUtility.Log("RM RoundAfterConversion");
            return this.RoundToPrecision(thisValue, ctx);
        }

        public T RoundToExponentExact(
      T thisValue,
      EInteger expOther,
      EContext ctx)
        {
            if (this.helper.GetExponent(thisValue).CompareTo(expOther) >= 0)
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            else
            {
                EContext pctx = ctx?.WithPrecision(0).WithBlankFlags();
                T ret = this.Quantize(
                thisValue,
                this.helper.CreateNewWithFlags(EInteger.One, expOther, 0),
                pctx);
                if (ctx != null && ctx.HasFlags)
                {
                    ctx.Flags |= pctx.Flags;
                }
                return ret;
            }
        }

        public T RoundToExponentNoRoundedFlag(
      T thisValue,
      EInteger exponent,
      EContext ctx)
        {
            EContext pctx = ctx?.WithBlankFlags();
            T ret = this.RoundToExponentExact(thisValue, exponent, pctx);
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= pctx.Flags & ~(EContext.FlagInexact |
                            EContext.FlagRounded);
            }
            return ret;
        }

        public T RoundToExponentSimple(
      T thisValue,
      EInteger expOther,
      EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, thisValue, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return thisValue;
                }
            }
            if (this.helper.GetExponent(thisValue).CompareTo(expOther) >= 0)
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            else
            {
                if (ctx != null && !ctx.ExponentWithinRange(expOther))
                {
                    return this.SignalInvalidWithMessage(
            ctx,
            "Exponent not within exponent range: " + expOther);
                }
                FastInteger shift = FastInteger.FromBig(expOther)
                  .SubtractBig(this.helper.GetExponent(thisValue));
                if (shift.Sign == 0 && IsSimpleContext(ctx))
                {
                    return thisValue;
                }
                EInteger bigmantissa = this.helper.GetMantissa(thisValue);
                IShiftAccumulator accum =
                     this.helper.CreateShiftAccumulator(bigmantissa);
                if (IsSimpleContext(ctx) && ctx.Rounding == ERounding.Down)
                {
                    accum.TruncateRight(shift);
                    return this.helper.CreateNewWithFlags(
                       accum.ShiftedInt,
                       expOther,
                       thisFlags);
                }
                else
                {
                    accum.ShiftRight(shift);
                }
                bigmantissa = accum.ShiftedInt;
                thisValue = this.helper.CreateNewWithFlags(
                  bigmantissa,
                  expOther,
                  thisFlags);
                return this.RoundToPrecisionInternal(
                  thisValue,
                  accum.LastDiscardedDigit,
                  accum.OlderDiscardedDigits,
                  null,
                  false,
                  ctx);
            }
        }

        public T RoundToPrecision(T thisValue, EContext context)
        {
            return this.RoundToPrecisionInternal(
        thisValue,
        0,
        0,
        null,
        false,
        context);
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
          ctx,
          "ctx has unlimited precision");
            }
            T ret = this.SquareRootHandleSpecial(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctxtmp = ctx.WithBlankFlags();
            EInteger currentExp = this.helper.GetExponent(thisValue);
            EInteger origExp = currentExp;
            EInteger idealExp;
            idealExp = currentExp;
            idealExp /= (EInteger)2;
            if (currentExp.Sign < 0 && !currentExp.IsEven)
            {
                // Round towards negative infinity; BigInteger's
                // division operation rounds towards zero
                idealExp -= EInteger.One;
            }
            // DebugUtility.Log("curr=" + currentExp + " ideal=" + idealExp);
            if (this.helper.GetSign(thisValue) == 0)
            {
                ret = this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.Zero, idealExp, this.helper.GetFlags(thisValue)),
                    ctxtmp);
                if (ctx.HasFlags)
                {
                    ctx.Flags |= ctxtmp.Flags;
                }
                return ret;
            }
            EInteger mantissa = this.helper.GetMantissa(thisValue);
            IShiftAccumulator accum = this.helper.CreateShiftAccumulator(mantissa);
            FastInteger digitCount = accum.GetDigitLength();
            FastInteger targetPrecision = FastInteger.FromBig(ctx.Precision);
            FastInteger precision = targetPrecision.Copy().Multiply(2).AddInt(2);
            bool rounded = false;
            bool inexact = false;
            if (digitCount.CompareTo(precision) < 0)
            {
                FastInteger diff = precision.Copy().Subtract(digitCount);
                // DebugUtility.Log(diff);
                if ((!diff.IsEvenNumber) ^ (!origExp.IsEven))
                {
                    diff.Increment();
                }
                EInteger bigdiff = diff.AsEInteger();
                currentExp -= (EInteger)bigdiff;
                mantissa = this.TryMultiplyByRadixPower(mantissa, diff);
                if (mantissa == null)
                {
                    return this.SignalInvalidWithMessage(
                      ctx,
                      "Result requires too much memory");
                }
            }
            EInteger[] sr = mantissa.SqrtRem();
            digitCount = this.helper.CreateShiftAccumulator(sr[0]).GetDigitLength();
            EInteger squareRootRemainder = sr[1];
            // DebugUtility.Log("I " + mantissa + " -> " + sr[0] + " [target="+
            // targetPrecision + "], (zero= " + squareRootRemainder.IsZero +") "
            mantissa = sr[0];
            if (!squareRootRemainder.IsZero)
            {
                rounded = true;
                inexact = true;
            }
            EInteger oldexp = currentExp;
            currentExp /= (EInteger)2;
            if (oldexp.Sign < 0 && !oldexp.IsEven)
            {
                // Round towards negative infinity; BigInteger's
                // division operation rounds towards zero
                currentExp -= EInteger.One;
            }
            T retval = this.helper.CreateNewWithFlags(mantissa, currentExp, 0);
            // DebugUtility.Log("idealExp= " + idealExp + ", curr" + currentExp
            // +" guess= " + mantissa);
            retval = this.RoundToPrecisionInternal(
        retval,
        0,
        inexact ? 1 : 0,
        null,
        false,
        ctxtmp);
            currentExp = this.helper.GetExponent(retval);
            // DebugUtility.Log("guess I " + guess + " idealExp=" + idealExp
            // +", curr " + currentExp + " clamped= " +
            // (ctxtmp.Flags&PrecisionContext.FlagClamped));
            if ((ctxtmp.Flags & EContext.FlagUnderflow) == 0)
            {
                int expcmp = currentExp.CompareTo(idealExp);
                if (expcmp <= 0 || !this.IsFinite(retval))
                {
                    retval = this.ReduceToPrecisionAndIdealExponent(
                      retval,
                      ctx.HasExponentRange ? ctxtmp : null,
                      inexact ? targetPrecision : null,
                      FastInteger.FromBig(idealExp));
                }
            }
            if (ctx.HasFlags)
            {
                if (ctx.ClampNormalExponents &&
                    !this.helper.GetExponent(retval).Equals(idealExp) && (ctxtmp.Flags &
            EContext.FlagInexact) == 0)
                {
                    ctx.Flags |= EContext.FlagClamped;
                }
                rounded |= (ctxtmp.Flags & EContext.FlagOverflow) != 0;
                // DebugUtility.Log("guess II " + guess);
                currentExp = this.helper.GetExponent(retval);
                if (rounded)
                {
                    ctxtmp.Flags |= EContext.FlagRounded;
                }
                else
                {
                    if (currentExp.CompareTo(idealExp) > 0)
                    {
                        // Greater than the ideal, treat as rounded anyway
                        ctxtmp.Flags |= EContext.FlagRounded;
                    }
                    else
                    {
                        // DebugUtility.Log("idealExp= " + idealExp + ", curr" +
                        // currentExp + " (II)");
                        ctxtmp.Flags &= ~EContext.FlagRounded;
                    }
                }
                if (inexact)
                {
                    ctxtmp.Flags |= EContext.FlagRounded;
                    ctxtmp.Flags |= EContext.FlagInexact;
                }
                ctx.Flags |= ctxtmp.Flags;
            }
            return retval;
        }

        private static EInteger AbsInt(EInteger ei)
        {
            return ei.Abs();
        }

        private static int CompareToFast(
      int e1int,
      int e2int,
      int expcmp,
      int signA,
      FastIntegerFixed op1Mantissa,
      FastIntegerFixed op2Mantissa,
      int radix)
        {
            int m1, m2;
            if (unchecked(Int32.MinValue + e2int) < e1int)
            {
                int ediff = (e1int > e2int) ? (e1int - e2int) : (e2int - e1int);
                if (ediff <= 9 && radix == 10)
                {
                    int power = ValueTenPowers[ediff];
                    int maxoverflow = OverflowMaxes[ediff];
                    if (expcmp > 0)
                    {
                        m1 = op1Mantissa.AsInt32();
                        m2 = op2Mantissa.AsInt32();
                        if (m1 <= maxoverflow)
                        {
                            m1 *= power;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                    else
                    {
                        m1 = op1Mantissa.AsInt32();
                        m2 = op2Mantissa.AsInt32();
                        if (m2 <= maxoverflow)
                        {
                            m2 *= power;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                }
                else if (ediff <= 30 && radix == 2)
                {
                    int mask = BitMasks[ediff];
                    if (expcmp > 0)
                    {
                        m1 = op1Mantissa.AsInt32();
                        m2 = op2Mantissa.AsInt32();
                        if ((m1 & mask) == m1)
                        {
                            m1 <<= ediff;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                    else
                    {
                        m1 = op1Mantissa.AsInt32();
                        m2 = op2Mantissa.AsInt32();
                        if ((m2 & mask) == m2)
                        {
                            m2 <<= ediff;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                }
            }
            return 2;
        }

        private static int CompareToSlow<TMath>(
      EInteger op1Exponent,
      EInteger op2Exponent,
      int expcmp,
      int signA,
      EInteger op1Mantissa,
      EInteger op2Mantissa,
      IRadixMathHelper<TMath> helper,
      bool reportOOM)
        {
            FastInteger fastOp1Exp = FastInteger.FromBig(op1Exponent);
            FastInteger fastOp2Exp = FastInteger.FromBig(op2Exponent);

            FastInteger expdiff = fastOp1Exp.Copy().Subtract(fastOp2Exp).Abs();
            // Check if exponent difference is too big for
            // radix-power calculation to work quickly
            if (expdiff.CompareToInt(100) >= 0)
            {
                EInteger op1MantAbs = op1Mantissa;
                EInteger op2MantAbs = op2Mantissa;
                FastInteger precision1 =
                  helper.CreateShiftAccumulator(op1MantAbs).GetDigitLength();
                FastInteger precision2 =
                  helper.CreateShiftAccumulator(op2MantAbs).GetDigitLength();
                FastInteger exp1 = fastOp1Exp.Copy().Add(precision1).Decrement();
                FastInteger exp2 = fastOp2Exp.Copy().Add(precision2).Decrement();
                int adjcmp = exp1.CompareTo(exp2);
                if (adjcmp != 0)
                {
                    return (signA < 0) ? -adjcmp : adjcmp;
                }
                FastInteger maxPrecision = null;
                maxPrecision = (precision1.CompareTo(precision2) > 0) ? precision1 :
                  precision2;
                // If exponent difference is greater than the
                // maximum precision of the two operands
                if (expdiff.Copy().CompareTo(maxPrecision) > 0)
                {
                    int expcmp2 = fastOp1Exp.CompareTo(fastOp2Exp);
                    if (expcmp2 < 0)
                    {
                        if (!op2MantAbs.IsZero)
                        {
                            // first operand's exponent is less
                            // and second operand isn't zero
                            // second mantissa will be shifted by the exponent
                            // difference
                            FastInteger digitLength1 =
                              helper.CreateShiftAccumulator(op1MantAbs).GetDigitLength();
                            if (fastOp1Exp.Copy().Add(digitLength1).AddInt(2)
                              .CompareTo(fastOp2Exp) < 0)
                            {
                                // first operand's mantissa can't reach the
                                // second operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastInteger tmp = fastOp2Exp.Copy()
                                .SubtractInt(8).Subtract(digitLength1).Subtract(maxPrecision);
                                FastInteger newDiff = tmp.Copy().Subtract(fastOp2Exp).Abs();
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // At this point, both operands have the same sign
                                    return (signA < 0) ? 1 : -1;
                                }
                            }
                        }
                    }
                    else if (expcmp2 > 0)
                    {
                        if (!op1MantAbs.IsZero)
                        {
                            // first operand's exponent is greater
                            // and second operand isn't zero
                            // first mantissa will be shifted by the exponent
                            // difference
                            FastInteger digitLength2 =
                               helper.CreateShiftAccumulator(op2MantAbs).GetDigitLength();
                            if (fastOp2Exp.Copy()
                                .Add(digitLength2).AddInt(2).CompareTo(fastOp1Exp) <
                              0)
                            {
                                // second operand's mantissa can't reach the
                                // first operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastInteger tmp = fastOp1Exp.Copy()
                                .SubtractInt(8).Subtract(digitLength2).Subtract(maxPrecision);
                                FastInteger newDiff = tmp.Copy().Subtract(fastOp1Exp).Abs();
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // At this point, both operands have the same sign
                                    return (signA < 0) ? -1 : 1;
                                }
                            }
                        }
                    }
                    expcmp = op1Exponent.CompareTo((EInteger)op2Exponent);
                }
            }
            if (expcmp > 0)
            {
                // if ((op1Exponent-op2Exponent).Abs() > 10) {
                // DebugUtility.Log("" + op1Mantissa + " " + op2Mantissa + " [exp="
                // + op1Exponent + " " + op2Exponent + "]");
                // }
                EInteger newmant = RescaleByExponentDiff(
          op1Mantissa,
          op1Exponent,
          op2Exponent,
          helper);
                if (newmant == null)
                {
                    if (reportOOM)
                    {
                        throw new OutOfMemoryException("Result requires too much memory");
                    }
                    return -2;
                }
                int mantcmp = newmant.CompareTo(op2Mantissa);
                return (signA < 0) ? -mantcmp : mantcmp;
            }
            else
            {
                // if ((op1Exponent-op2Exponent).Abs() > 10) {
                // DebugUtility.Log("" + op1Mantissa + " " + op2Mantissa + " [exp="
                // + op1Exponent + " " + op2Exponent + "]");
                // }
                EInteger newmant = RescaleByExponentDiff(
                    op2Mantissa,
                    op1Exponent,
                    op2Exponent,
                    helper);
                if (newmant == null)
                {
                    if (reportOOM)
                    {
                        throw new OutOfMemoryException("Result requires too much memory");
                    }
                    return -2;
                }
                int mantcmp = op1Mantissa.CompareTo(newmant);
                return (signA < 0) ? -mantcmp : mantcmp;
            }
        }

        private static bool IsNullOrSimpleContext(EContext ctx)
        {
            return ctx == null || ctx == EContext.UnlimitedHalfEven ||
             (!ctx.HasExponentRange && !ctx.HasMaxPrecision && ctx.Traps == 0 &&
              !ctx.HasFlags);
        }

        private static bool IsSimpleContext(EContext ctx)
        {
            return ctx != null && (ctx == EContext.UnlimitedHalfEven ||
             (!ctx.HasExponentRange && !ctx.HasMaxPrecision && ctx.Traps == 0 &&
              !ctx.HasFlags));
        }

        private static EInteger PowerOfTwo(FastInteger fi)
        {
            if (fi.Sign <= 0)
            {
                return EInteger.One;
            }
            if (fi.CanFitInInt32())
            {
                int val = fi.AsInt32();
                if (val <= 30)
                {
                    val = 1 << val;
                    return (EInteger)val;
                }
                return EInteger.One << val;
            }
            else
            {
                EInteger bi = EInteger.One;
                FastInteger fi2 = fi.Copy();
                while (fi2.Sign > 0)
                {
                    int count = 1000000;
                    if (fi2.CompareToInt(1000000) < 0)
                    {
                        count = (int)bi;
                    }
                    bi <<= count;
                    fi2.SubtractInt(count);
                }
                return bi;
            }
        }

        private static EInteger RescaleByExponentDiff<TMath>(
      EInteger mantissa,
      EInteger e1,
      EInteger e2,
      IRadixMathHelper<TMath> helper)
        {
            if (mantissa.Sign == 0)
            {
                return EInteger.Zero;
            }
            FastInteger diff = FastInteger.FromBig(e1).SubtractBig(e2).Abs();
            if (!diff.CanFitInInt32())
            {
                // NOTE: For radix 10, each digit fits less than 1 byte; the
                // supported byte length is thus less than the maximum value
                // of a 32-bit integer (2GB).
                FastInteger fastBI = FastInteger.FromBig(mantissa);
                if (helper.GetRadix() != 10 || diff.CompareTo(fastBI) > 0)
                {
                    return null;
                }
            }
            return helper.MultiplyByRadixPower(mantissa, diff);
        }

        private static EContext SetPrecisionIfLimited(
          EContext ctx,
          EInteger bigPrecision)
        {
            return (ctx == null || !ctx.HasMaxPrecision) ? ctx :
              ctx.WithBigPrecision(bigPrecision);
        }

        private static void TransferFlags(
      EContext ctxDst,
      EContext ctxSrc)
        {
            if (ctxDst != null && ctxDst.HasFlags)
            {
                if ((ctxSrc.Flags & (EContext.FlagInvalid |
                            EContext.FlagDivideByZero)) != 0)
                {
                    ctxDst.Flags |= ctxSrc.Flags & (EContext.FlagInvalid |
                              EContext.FlagDivideByZero);
                }
                else
                {
                    ctxDst.Flags |= ctxSrc.Flags;
                }
            }
        }

        private T AbsRaw(T value)
        {
            return this.EnsureSign(value, false);
        }

        // mant1 and mant2 are assumed to be nonnegative
        private T AddCore2(
      FastIntegerFixed mant1,
      FastIntegerFixed mant2,
      FastIntegerFixed exponent,
      int flags1,
      int flags2,
      EContext ctx)
        {
#if DEBUG
            if (mant1.Sign < 0)
            {
                throw new InvalidOperationException();
            }
            if (mant2.Sign < 0)
            {
                throw new InvalidOperationException();
            }
#endif
            bool neg1 = (flags1 & BigNumberFlags.FlagNegative) != 0;
            bool neg2 = (flags2 & BigNumberFlags.FlagNegative) != 0;
            bool negResult = false;
            // DebugUtility.Log("neg1=" + neg1 + " neg2=" + neg2);
            if (neg1 != neg2)
            {
                // Signs are different, treat as a subtraction
                mant1 = FastIntegerFixed.Subtract(mant1, mant2);
                int mant1Sign = mant1.Sign;
                if (mant1Sign < 0)
                {
                    negResult = !neg1;
                    mant1 = mant1.Negate();
                }
                else if (mant1Sign == 0)
                {
                    // Result is negative zero
                    negResult = neg1 ^ neg2;
                    if (negResult)
                    {
                        negResult &= (neg1 && neg2) || ((neg1 ^ neg2) && ctx != null &&
                                ctx.Rounding == ERounding.Floor);
                    }
                }
                else
                {
                    negResult = neg1;
                }
            }
            else
            {
                // Signs are same, treat as an addition
                mant1 = FastIntegerFixed.Add(mant1, mant2);
                negResult = neg1;
                if (negResult && mant1.IsValueZero)
                {
                    // Result is negative zero
                    negResult &= (neg1 && neg2) || ((neg1 ^ neg2) && ctx != null &&
                              ctx.Rounding == ERounding.Floor);
                }
            }
            // DebugUtility.Log("mant1= " + mant1 + " exp= " + exponent +" neg= "+
            // (negResult));
            return this.helper.CreateNewWithFlagsFastInt(
        mant1,
        exponent,
        negResult ? BigNumberFlags.FlagNegative : 0);
        }

        // mant1 and mant2 are assumed to be nonnegative
        private T AddCore(
      EInteger mant1,
      EInteger mant2,
      EInteger exponent,
      int flags1,
      int flags2,
      EContext ctx)
        {
#if DEBUG
            if (mant1.Sign < 0)
            {
                throw new InvalidOperationException();
            }
            if (mant2.Sign < 0)
            {
                throw new InvalidOperationException();
            }
#endif
            bool neg1 = (flags1 & BigNumberFlags.FlagNegative) != 0;
            bool neg2 = (flags2 & BigNumberFlags.FlagNegative) != 0;
            bool negResult = false;
            // DebugUtility.Log("neg1=" + neg1 + " neg2=" + neg2);
            if (neg1 != neg2)
            {
                // Signs are different, treat as a subtraction
                // DebugUtility.Log("sub " + mant1 + " " + mant2);
                mant1 -= (EInteger)mant2;
                int mant1Sign = mant1.Sign;
                negResult = neg1 ^ (mant1Sign == 0 ? neg2 : (mant1Sign < 0));
                if (mant1Sign < 0)
                {
                    mant1 = mant1.Negate();
                }
            }
            else
            {
                // Signs are same, treat as an addition
                // DebugUtility.Log("add " + mant1 + " " + mant2);
                mant1 += (EInteger)mant2;
                negResult = neg1;
            }
            if (negResult && mant1.IsZero)
            {
                // Result is negative zero
                negResult &= (neg1 && neg2) || ((neg1 ^ neg2) && ctx != null &&
                            ctx.Rounding == ERounding.Floor);
            }
            // DebugUtility.Log("mant1= " + mant1 + " exp= " + exponent +" neg= "+
            // (negResult));
            return this.helper.CreateNewWithFlags(
        mant1,
        exponent,
        negResult ? BigNumberFlags.FlagNegative : 0);
        }

        private FastInteger OverestimateDigitLength(EInteger ei)
        {
            if (this.thisRadix == 2)
            {
                return new FastInteger(ei.GetUnsignedBitLength());
            }
            else if (this.thisRadix == 10)
            {
                int bitLength = ei.GetUnsignedBitLength();
                if (bitLength <= 2135)
                {
                    // May overestimate by 1
                    return new FastInteger(1 + ((bitLength * 631305) >> 21));
                }
                return new FastInteger(bitLength >> 2);
            }
            else
            {
                return this.helper.CreateShiftAccumulator(ei)
                        .GetDigitLength();
            }
        }

        private static FastInteger valueFastIntegerTwo = new FastInteger(2);

        private T AddExDiffExp(
      T thisValue,
      T other,
      int thisFlags,
      int otherFlags,
      EContext ctx,
      int expcmp,
      bool roundToOperandPrecision)
        {
            T retval = default(T);
            // choose the minimum exponent
            T op1 = thisValue;
            T op2 = other;
            EInteger op1MantAbs = this.helper.GetMantissa(thisValue);
            EInteger op2MantAbs = this.helper.GetMantissa(other);
            EInteger op1Exponent = this.helper.GetExponent(op1);
            EInteger op2Exponent = this.helper.GetExponent(op2);
            EInteger resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
            if (ctx != null && ctx.HasMaxPrecision && ctx.Precision.Sign > 0)
            {
                FastInteger fastOp1Exp = FastInteger.FromBig(op1Exponent);
                FastInteger fastOp2Exp = FastInteger.FromBig(op2Exponent);
                FastInteger expdiff = fastOp1Exp.Copy().Subtract(fastOp2Exp).Abs();
                // Check if exponent difference is too big for
                // radix-power calculation to work quickly
                FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
                bool moreDistantThanPrecision = expdiff.CompareTo(fastPrecision) > 0;
                // If exponent difference is greater than the precision
                // if (true || moreDistantThanPrecision) {
                if (moreDistantThanPrecision)
                {
                    int expcmp2 = fastOp1Exp.CompareTo(fastOp2Exp);
                    if (expcmp2 < 0)
                    {
                        if (!op2MantAbs.IsZero)
                        {
                            // first operand's exponent is less
                            // and second operand isn't zero
                            // second mantissa will be shifted by the exponent
                            // difference
                            // _________________________111111111111|_
                            // ___222222222222222|____________________
                            FastInteger digitLength1 = this.OverestimateDigitLength(op1MantAbs);
                            if (fastOp1Exp.Copy().Add(digitLength1).AddInt(2)
                            .CompareTo(fastOp2Exp) < 0)
                            {
                                // first operand's mantissa can't reach the
                                // second operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastInteger tmp = fastOp2Exp.Copy().SubtractInt(4)
                                  .Subtract(digitLength1).SubtractBig(ctx.Precision);
                                FastInteger newDiff = tmp.Copy().Subtract(fastOp2Exp).Abs();
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // First operand can be treated as almost zero
                                    bool sameSign = this.helper.GetSign(thisValue) ==
                                    this.helper.GetSign(other);
                                    bool oneOpIsZero = op1MantAbs.IsZero;
                                    FastInteger digitLength2 =
                                    this.helper.CreateShiftAccumulator(op2MantAbs)
                                    .GetDigitLength();
                                    if (digitLength2.CompareTo(fastPrecision) < 0)
                                    {
                                        // Second operand's precision too short, extend
                                        // it to the full precision
                                        FastInteger precisionDiff =
                                        fastPrecision.Copy().Subtract(digitLength2);
                                        if (!oneOpIsZero && !sameSign)
                                        {
                                            precisionDiff.AddInt(2);
                                        }
                                        op2MantAbs = this.TryMultiplyByRadixPower(
                                        op2MantAbs,
                                        precisionDiff);
                                        if (op2MantAbs == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                            ctx,
                                            "Result requires too much memory");
                                        }
                                        EInteger bigintTemp = precisionDiff.AsEInteger();
                                        op2Exponent -= (EInteger)bigintTemp;
                                        if (!oneOpIsZero && !sameSign)
                                        {
                                            op2MantAbs -= EInteger.One;
                                        }
                                        other = this.helper.CreateNewWithFlags(
                              op2MantAbs,
                              op2Exponent,
                              this.helper.GetFlags(other));
                                        FastInteger shift = digitLength2.Copy().Subtract(fastPrecision);
                                        if (oneOpIsZero && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }
                                        // DebugUtility.Log("Second op's prec too short:
                                        // op2MantAbs=" + op2MantAbs + " precdiff= " +
                                        // (precisionDiff));
                                        return this.RoundToPrecisionInternal(
                              other,
                               (oneOpIsZero || sameSign) ? 0 : 1,
                               (oneOpIsZero && !sameSign) ? 0 : 1,
                               shift,
                               false,
                                        ctx);
                                    }
                                    if (!oneOpIsZero && !sameSign)
                                    {
                                        op2MantAbs = this.TryMultiplyByRadixPower(
                                        op2MantAbs,
                                        valueFastIntegerTwo);
                                        if (op2MantAbs == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                            ctx,
                                            "Result requires too much memory");
                                        }
                                        op2Exponent -= (EInteger)2;
                                        op2MantAbs -= EInteger.One;
                                        other = this.helper.CreateNewWithFlags(
                                        op2MantAbs,
                                        op2Exponent,
                                        this.helper.GetFlags(other));
                                        FastInteger shift =
                                        digitLength2.Copy().Subtract(fastPrecision);

                                        return this.RoundToPrecisionInternal(
                              other,
                              0,
                              0,
                              shift,
                              false,
                              ctx);
                                    }
                                    else
                                    {
                                        FastInteger shift2 =
                                        digitLength2.Copy().Subtract(fastPrecision);
                                        if (!sameSign && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }

                                        return this.RoundToPrecisionInternal(
                                        other,
                                        0,
                                        sameSign ? 1 : 0,
                                        shift2,
                                        false,
                                        ctx);
                                    }
                                }
                            }
                        }
                    }
                    else if (expcmp2 > 0)
                    {
                        if (!op1MantAbs.IsZero)
                        {
                            // first operand's exponent is greater
                            // and first operand isn't zero
                            // first mantissa will be shifted by the exponent
                            // difference
                            // __111111111111|
                            // ____________________222222222222222|
                            FastInteger digitLength2 = this.OverestimateDigitLength(op2MantAbs);
                            if (fastOp2Exp.Copy().Add(digitLength2).AddInt(2)
                            .CompareTo(fastOp1Exp) < 0)
                            {
                                // second operand's mantissa can't reach the
                                // first operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastInteger tmp = fastOp1Exp.Copy().SubtractInt(4)
                                .Subtract(digitLength2).SubtractBig(ctx.Precision);
                                FastInteger newDiff = tmp.Copy().Subtract(fastOp1Exp).Abs();
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // Second operand can be treated as almost zero
                                    bool sameSign = this.helper.GetSign(thisValue) ==
                                    this.helper.GetSign(other);
                                    bool oneOpIsZero = op2MantAbs.IsZero;
                                    digitLength2 = this.helper.CreateShiftAccumulator(op1MantAbs)
                                      .GetDigitLength();
                                    if (digitLength2.CompareTo(fastPrecision) < 0)
                                    {
                                        // First operand's precision too short; extend it
                                        // to the full precision
                                        FastInteger precisionDiff =
                                        fastPrecision.Copy().Subtract(digitLength2);
                                        if (!oneOpIsZero && !sameSign)
                                        {
                                            precisionDiff.AddInt(2);
                                        }
                                        op1MantAbs = this.TryMultiplyByRadixPower(
                                        op1MantAbs,
                                        precisionDiff);
                                        if (op1MantAbs == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                            ctx,
                                            "Result requires too much memory");
                                        }
                                        EInteger bigintTemp = precisionDiff.AsEInteger();
                                        op1Exponent -= (EInteger)bigintTemp;
                                        if (!oneOpIsZero && !sameSign)
                                        {
                                            op1MantAbs -= EInteger.One;
                                        }
                                        thisValue = this.helper.CreateNewWithFlags(
                                        op1MantAbs,
                                        op1Exponent,
                                        this.helper.GetFlags(thisValue));
                                        FastInteger shift =
                                        digitLength2.Copy().Subtract(fastPrecision);
                                        if (oneOpIsZero && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }

                                        return this.RoundToPrecisionInternal(
                                        thisValue,
                         (oneOpIsZero || sameSign) ? 0 : 1,
                         (oneOpIsZero && !sameSign) ? 0 : 1,
                         shift,
                         false,
                                        ctx);
                                    }
                                    if (!oneOpIsZero && !sameSign)
                                    {
                                        op1MantAbs = this.TryMultiplyByRadixPower(
                                        op1MantAbs,
                                        valueFastIntegerTwo);
                                        if (op1MantAbs == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                            ctx,
                                            "Result requires too much memory");
                                        }
                                        op1Exponent -= (EInteger)2;
                                        op1MantAbs -= EInteger.One;
                                        thisValue = this.helper.CreateNewWithFlags(
                                        op1MantAbs,
                                        op1Exponent,
                                        this.helper.GetFlags(thisValue));
                                        FastInteger shift =
                                        digitLength2.Copy().Subtract(fastPrecision);

                                        return this.RoundToPrecisionInternal(
                              thisValue,
                              0,
                              0,
                              shift,
                              false,
                              ctx);
                                    }
                                    else
                                    {
                                        FastInteger shift2 =
                                        digitLength2.Copy().Subtract(fastPrecision);
                                        if (!sameSign && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }

                                        return this.RoundToPrecisionInternal(
                                        thisValue,
                                        0,
                                        sameSign ? 1 : 0,
                                        shift2,
                                        false,
                                        ctx);
                                    }
                                }
                            }
                        }
                    }
                    expcmp = op1Exponent.CompareTo((EInteger)op2Exponent);
                    resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
                }
            }
            if (expcmp > 0)
            {
                op1MantAbs = RescaleByExponentDiff(
          op1MantAbs,
          op1Exponent,
          op2Exponent,
          this.helper);
                if (op1MantAbs == null)
                {
                    return this.SignalInvalidWithMessage(
                      ctx,
                      "Result requires too much memory");
                }
                retval = this.AddCore(
                  op1MantAbs,
                  op2MantAbs,
                  resultExponent,
                  thisFlags,
                  otherFlags,
                  ctx);
            }
            else
            {
                op2MantAbs = RescaleByExponentDiff(
          op2MantAbs,
          op1Exponent,
          op2Exponent,
          this.helper);
                if (op2MantAbs == null)
                {
                    return this.SignalInvalidWithMessage(
                      ctx,
                      "Result requires too much memory");
                }
                retval = this.AddCore(
          op1MantAbs,
          op2MantAbs,
          resultExponent,
          thisFlags,
          otherFlags,
          ctx);
            }
            if (roundToOperandPrecision && ctx != null && ctx.HasMaxPrecision)
            {
                FastInteger digitLength1 =
                  this.helper.CreateShiftAccumulator(op1MantAbs)
                  .GetDigitLength();
                FastInteger digitLength2 =
                  this.helper.CreateShiftAccumulator(op2MantAbs)
                  .GetDigitLength();
                FastInteger maxDigitLength =
                  (digitLength1.CompareTo(digitLength2) > 0) ? digitLength1 :
                  digitLength2;
                maxDigitLength.SubtractBig(ctx.Precision);
                // DebugUtility.Log("retval= " + retval + " maxdl=" +
                // maxDigitLength + " prec= " + (ctx.Precision));
                return (maxDigitLength.Sign > 0) ? this.RoundToPrecisionInternal(
                    retval,
                    0,
                    0,
                    maxDigitLength,
                    false,
                    ctx) : this.RoundToPrecision(retval, ctx);
                // DebugUtility.Log("retval now " + retval);
            }
            else
            {
                return IsNullOrSimpleContext(ctx) ? retval :
                  this.RoundToPrecision(retval, ctx);
            }
        }

        private T CompareToHandleSpecial(
      T thisValue,
      T other,
      bool treatQuietNansAsSignaling,
      EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                // Check this value then the other value for signaling NaN
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(thisValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(other, ctx);
                }
                if (treatQuietNansAsSignaling)
                {
                    if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.SignalingNaNInvalid(thisValue, ctx);
                    }
                    if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.SignalingNaNInvalid(other, ctx);
                    }
                }
                else
                {
                    // Check this value then the other value for quiet NaN
                    if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.ReturnQuietNaN(thisValue, ctx);
                    }
                    if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.ReturnQuietNaN(other, ctx);
                    }
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // thisValue is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                              BigNumberFlags.FlagNegative)) == (otherFlags &
            (BigNumberFlags.FlagInfinity |
            BigNumberFlags.FlagNegative))) ? this.ValueOf(0, null) : (((thisFlags &
                          BigNumberFlags.FlagNegative) == 0) ? this.ValueOf(
            1,
            null) : this.ValueOf(-1, null));
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // the other value is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                              BigNumberFlags.FlagNegative)) == (otherFlags &
            (BigNumberFlags.FlagInfinity |
            BigNumberFlags.FlagNegative))) ? this.ValueOf(0, null) : (((otherFlags &
                              BigNumberFlags.FlagNegative) == 0) ?
                          this.ValueOf(-1, null) : this.ValueOf(1, null));
                }
            }
            return default(T);
        }

        private static int CompareToHandleSpecial2<TMath>(
          TMath thisValue,
          TMath other,
          int thisFlags,
          int otherFlags)
        {
            // Assumes either value is NaN and/or infinity
            {
                if ((thisFlags & BigNumberFlags.FlagNaN) != 0)
                {
                    if ((otherFlags & BigNumberFlags.FlagNaN) != 0)
                    {
                        return 0;
                    }
                    // Consider NaN to be greater
                    return 1;
                }
                if ((otherFlags & BigNumberFlags.FlagNaN) != 0)
                {
                    // Consider this to be less than NaN
                    return -1;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // thisValue is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                              BigNumberFlags.FlagNegative)) == (otherFlags &
            (BigNumberFlags.FlagInfinity |
            BigNumberFlags.FlagNegative))) ? 0 :
                      (((thisFlags & BigNumberFlags.FlagNegative) == 0) ? 1 : -1);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // the other value is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                              BigNumberFlags.FlagNegative)) == (otherFlags &
            (BigNumberFlags.FlagInfinity |
            BigNumberFlags.FlagNegative))) ? 0 :
                      (((otherFlags & BigNumberFlags.FlagNegative) == 0) ? -1 : 1);
                }
            }
            return 2;
        }

        private static int CompareToInternal<TMath>(
          TMath thisValue,
          TMath otherValue,
          bool reportOOM,
          IRadixMathHelper<TMath> helper)
        {
            int signA = helper.GetSign(thisValue);
            int signB = helper.GetSign(otherValue);
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            FastIntegerFixed op1Exponent = helper.GetExponentFastInt(thisValue);
            FastIntegerFixed op2Exponent = helper.GetExponentFastInt(otherValue);
            FastIntegerFixed op1Mantissa = helper.GetMantissaFastInt(thisValue);
            FastIntegerFixed op2Mantissa = helper.GetMantissaFastInt(otherValue);
            int expcmp = op1Exponent.CompareTo(op2Exponent);
            // At this point, the signs are equal so we can compare
            // their absolute values instead
            int mantcmp = op1Mantissa.CompareTo(op2Mantissa);
            if (mantcmp == 0)
            {
                // Special case: Mantissas are equal
                return signA < 0 ? -expcmp : expcmp;
            }
            if (expcmp == 0)
            {
                return signA < 0 ? -mantcmp : mantcmp;
            }
            if (op1Exponent.CanFitInInt32() && op2Exponent.CanFitInInt32() &&
                op1Mantissa.CanFitInInt32() && op2Mantissa.CanFitInInt32())
            {
                int e1int = op1Exponent.AsInt32();
                int e2int = op2Exponent.AsInt32();
                int c = CompareToFast(
          e1int,
          e2int,
          expcmp,
          signA,
          op1Mantissa,
          op2Mantissa,
          helper.GetRadix());
                if (c <= 1)
                {
                    return c;
                }
            }
            return CompareToSlow(
              op1Exponent.ToEInteger(),
              op2Exponent.ToEInteger(),
              expcmp,
              signA,
              op1Mantissa.ToEInteger(),
              op2Mantissa.ToEInteger(),
              helper,
              reportOOM);
        }

        private T DivideInternal(
      T thisValue,
      T divisor,
      EContext ctx,
      int integerMode,
      EInteger desiredExponent)
        {
            T ret = this.DivisionHandleSpecial(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            int signA = this.helper.GetSign(thisValue);
            int signB = this.helper.GetSign(divisor);
            if (signB == 0)
            {
                if (signA == 0)
                {
                    return this.SignalInvalid(ctx);
                }
                bool flagsNeg = ((this.helper.GetFlags(thisValue) &
                   BigNumberFlags.FlagNegative) != 0) ^
                          ((this.helper.GetFlags(divisor) &
                    BigNumberFlags.FlagNegative) != 0);
                return this.SignalDivideByZero(ctx, flagsNeg);
            }
            int radix = this.thisRadix;
            if (signA == 0)
            {
                T retval = default(T);
                if (integerMode == IntegerModeFixedScale)
                {
                    int newflags = (this.helper.GetFlags(thisValue) &
                          BigNumberFlags.FlagNegative) ^ (this.helper.GetFlags(divisor) &
                       BigNumberFlags.FlagNegative);
                    retval = this.helper.CreateNewWithFlags(
                      EInteger.Zero,
                      desiredExponent,
                      newflags);
                }
                else
                {
                    EInteger dividendExp = this.helper.GetExponent(thisValue);
                    EInteger divisorExp = this.helper.GetExponent(divisor);
                    int newflags = (this.helper.GetFlags(thisValue) &
                          BigNumberFlags.FlagNegative) ^ (this.helper.GetFlags(divisor) &
                       BigNumberFlags.FlagNegative);
                    retval =
                      this.RoundToPrecision(
                        this.helper.CreateNewWithFlags(EInteger.Zero, dividendExp - (EInteger)divisorExp, newflags),
                        ctx);
                }
                return retval;
            }
            else
            {
                EInteger mantissaDividend = this.helper.GetMantissa(thisValue);
                EInteger mantissaDivisor = this.helper.GetMantissa(divisor);
                FastInteger expDividend =
                  this.helper.GetExponentFastInt(thisValue).ToFastInteger();
                FastInteger expDivisor =
                  this.helper.GetExponentFastInt(divisor).ToFastInteger();
                FastInteger expdiff = expDividend.Copy().Subtract(expDivisor);
                FastInteger adjust = new FastInteger(0);
                FastInteger result = new FastInteger(0);
                FastInteger naturalExponent = expdiff.Copy();
                bool hasPrecision = ctx != null && ctx.Precision.Sign != 0;
                bool resultNeg = (this.helper.GetFlags(thisValue) &
                        BigNumberFlags.FlagNegative) != (this.helper.GetFlags(divisor) &
                   BigNumberFlags.FlagNegative);
                FastInteger fastPrecision = (!hasPrecision) ? new FastInteger(0) :
                  FastInteger.FromBig(ctx.Precision);
                FastInteger dividendPrecision = null;
                FastInteger divisorPrecision = null;
                if (integerMode == IntegerModeFixedScale)
                {
                    FastInteger shift;
                    EInteger rem;
                    FastInteger fastDesiredExponent =
                        FastInteger.FromBig(desiredExponent);
                    if (ctx != null && ctx.HasFlags &&
                        fastDesiredExponent.CompareTo(expdiff) > 0)
                    {
                        // Treat as rounded if the desired exponent is greater
                        // than the "ideal" exponent
                        ctx.Flags |= EContext.FlagRounded;
                    }
                    if (expdiff.CompareTo(fastDesiredExponent) <= 0)
                    {
                        shift = fastDesiredExponent.Copy().Subtract(expdiff);
                        EInteger quo;
                        {
                            EInteger[] divrem = mantissaDividend.DivRem(mantissaDivisor);
                            quo = divrem[0];
                            rem = divrem[1];
                        }
                        return this.RoundToScale(
              quo,
              rem,
              mantissaDivisor,
              desiredExponent,
              shift,
              resultNeg,
              ctx);
                    }
                    if (ctx != null && ctx.Precision.Sign != 0 &&
                     expdiff.Copy().SubtractInt(8).CompareTo(fastPrecision) >
                        0)
                    {
                        // NOTE: 8 guard digits
                        // Result would require a too-high precision since
                        // exponent difference is much higher
                        return this.SignalInvalidWithMessage(
              ctx,
              "Result can't fit the precision");
                    }
                    else
                    {
                        shift = expdiff.Copy().Subtract(fastDesiredExponent);
                        mantissaDividend =
                          this.TryMultiplyByRadixPower(mantissaDividend, shift);
                        if (mantissaDividend == null)
                        {
                            return this.SignalInvalidWithMessage(
                              ctx,
                              "Result requires too much memory");
                        }
                        EInteger quo;
                        {
                            EInteger[] divrem = mantissaDividend.DivRem(mantissaDivisor);
                            quo = divrem[0];
                            rem = divrem[1];
                        }
                        return this.RoundToScale(
                          quo,
             rem,
             mantissaDivisor,
             desiredExponent,
             new FastInteger(0),
             resultNeg,
             ctx);
                    }
                }
                if (integerMode == IntegerModeRegular)
                {
                    EInteger rem = null;
                    EInteger quo = null;
                    EInteger[] divrem = mantissaDividend.DivRem(mantissaDivisor);
                    quo = divrem[0];
                    rem = divrem[1];
                    if (rem.IsZero)
                    {
                        // Dividend is divisible by divisor
                        // DebugUtility.Log("divisible dividend");
                        quo = quo.Abs();
                        return this.RoundToPrecision(
              this.helper.CreateNewWithFlagsFastInt(FastIntegerFixed.FromBig(quo), FastIntegerFixed.FromFastInteger(expdiff), resultNeg ? BigNumberFlags.FlagNegative : 0),
              ctx);
                    }
                    rem = null;
                    quo = null;
                    if (hasPrecision)
                    {
#if DEBUG
                        if (ctx == null)
                        {
                            throw new ArgumentNullException(nameof(ctx));
                        }
#endif
                        // DebugUtility.Log("has precision");
                        EInteger divid = mantissaDividend;
                        FastInteger shift = FastInteger.FromBig(ctx.Precision);
                        dividendPrecision =
                               this.helper.CreateShiftAccumulator(mantissaDividend)
                                .GetDigitLength();
                        divisorPrecision =
                          this.helper.CreateShiftAccumulator(mantissaDivisor)
                          .GetDigitLength();
                        FastInteger dividPrecision = dividendPrecision.Copy();
                        FastInteger divisPrecision = divisorPrecision.Copy();
                        if (dividendPrecision.CompareTo(divisorPrecision) <= 0)
                        {
                            divisorPrecision = divisorPrecision.Copy()
                              .Subtract(dividendPrecision);
                            divisorPrecision.Increment();
                            shift.Add(divisorPrecision);
                            divid = this.TryMultiplyByRadixPower(divid, shift);
                            dividPrecision.Add(shift);
                            if (divid == null)
                            {
                                return this.SignalInvalidWithMessage(
                                ctx,
                                "Result requires too much memory");
                            }
                        }
                        else
                        {
                            // Already greater than divisor precision
                            dividendPrecision = dividendPrecision.Copy()
                              .Subtract(divisorPrecision);
                            if (dividendPrecision.CompareTo(shift) <= 0)
                            {
                                shift.Subtract(dividendPrecision);
                                shift.Increment();
                                divid = this.TryMultiplyByRadixPower(divid, shift);
                                dividPrecision.Add(shift);
                                if (divid == null)
                                {
                                    return this.SignalInvalidWithMessage(
                                  ctx,
                                  "Result requires too much memory");
                                }
                            }
                            else
                            {
                                // no need to shift
                                shift.SetInt(0);
                            }
                        }
                        dividendPrecision = dividPrecision;
                        divisorPrecision = divisPrecision;
                        if (shift.Sign != 0 || quo == null)
                        {
                            // if shift isn't zero, recalculate the quotient
                            // and remainder
                            EInteger[] divrem2 = divid.DivRem(mantissaDivisor);
                            quo = divrem2[0];
                            rem = divrem2[1];
                        }
                        // DebugUtility.Log(String.Format("" + divid + "" +
                        // mantissaDivisor + " -> quo= " + quo + " rem= " +
                        // (rem)));
                        int[] digitStatus = this.RoundToScaleStatus(
                          rem,
                          mantissaDivisor,
                          ctx);
                        if (digitStatus == null)
                        {
                            return this.SignalInvalidWithMessage(
                ctx,
                "Rounding was required");
                        }
                        FastInteger natexp = naturalExponent.Copy().Subtract(shift);
                        EContext ctxcopy = ctx.WithBlankFlags();
                        T retval2 = this.helper.CreateNewWithFlags(
                          quo,
                          natexp.AsEInteger(),
                          resultNeg ? BigNumberFlags.FlagNegative : 0);
                        retval2 = this.RoundToPrecisionInternal(
                          retval2,
                          digitStatus[0],
                          digitStatus[1],
                          null,
                          false,
                          ctxcopy);
                        if ((ctxcopy.Flags & EContext.FlagInexact) != 0)
                        {
                            if (ctx.HasFlags)
                            {
                                ctx.Flags |= ctxcopy.Flags;
                            }
                            return retval2;
                        }
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= ctxcopy.Flags & ~EContext.FlagRounded;
                        }
                        return this.ReduceToPrecisionAndIdealExponent(
                          retval2,
                          ctx,
                          rem.IsZero ? null : fastPrecision,
                          expdiff);
                    }
                }
                // Rest of method assumes unlimited precision
                // and IntegerModeRegular
                int mantcmp = mantissaDividend.CompareTo(mantissaDivisor);
                if (mantcmp == 0)
                {
                    result = new FastInteger(1);
                    mantissaDividend = EInteger.Zero;
                }
                else
                {
                    EInteger gcd = mantissaDividend.Gcd(mantissaDivisor);
                    // DebugUtility.Log("mgcd/den1=" + mantissaDividend + "/" + (//
                    // mantissaDivisor) + "/" + gcd);
                    if (gcd.CompareTo(EInteger.One) != 0)
                    {
                        mantissaDividend /= gcd;
                        mantissaDivisor /= gcd;
                    }
                    // DebugUtility.Log("mgcd/den2=" + mantissaDividend + "/" + (//
                    // mantissaDivisor) + "/" + gcd);
                    FastInteger divShift = this.helper.DivisionShift(
                        mantissaDividend,
                        mantissaDivisor);

                    if (divShift == null)
                    {
                        return this.SignalInvalidWithMessage(
              ctx,
              "Result would have a nonterminating expansion");
                    }
                    mantissaDividend = this.helper.MultiplyByRadixPower(
                      mantissaDividend,
                      divShift);
                    adjust = divShift.Copy();
                    // DebugUtility.Log("mant " + mantissaDividend + " " +
                    // (// mantissaDivisor));
                    EInteger[] quorem = mantissaDividend.DivRem(mantissaDivisor);
#if DEBUG
                    if (!quorem[1].IsZero)
                    {
                        throw new ArgumentException("doesn't satisfy quorem[1].IsZero");
                    }
#endif

                    mantissaDividend = quorem[1];
                    result = FastInteger.FromBig(quorem[0]);
                }
                // mantissaDividend now has the remainder
                FastInteger exp = expdiff.Copy().Subtract(adjust);
                ERounding rounding = (ctx == null) ? ERounding.HalfEven : ctx.Rounding;
                int lastDiscarded = 0;
                int olderDiscarded = 0;
                if (!mantissaDividend.IsZero)
                {
                    if (rounding == ERounding.HalfDown || rounding == ERounding.HalfEven ||
                        rounding == ERounding.HalfUp)
                    {
                        EInteger halfDivisor = mantissaDivisor >> 1;
                        int cmpHalf = mantissaDividend.CompareTo(halfDivisor);
                        if ((cmpHalf == 0) && mantissaDivisor.IsEven)
                        {
                            // remainder is exactly half
                            lastDiscarded = radix / 2;
                            olderDiscarded = 0;
                        }
                        else if (cmpHalf > 0)
                        {
                            // remainder is greater than half
                            lastDiscarded = radix / 2;
                            olderDiscarded = 1;
                        }
                        else
                        {
                            // remainder is less than half
                            lastDiscarded = 0;
                            olderDiscarded = 1;
                        }
                    }
                    else
                    {
                        if (rounding == ERounding.None)
                        {
                            return this.SignalInvalidWithMessage(
                              ctx,
                              "Rounding was required");
                        }
                        lastDiscarded = 1;
                        olderDiscarded = 1;
                    }
                }
                EInteger bigResult = result.AsEInteger();
                if (ctx != null && ctx.HasFlags && exp.CompareTo(expdiff) > 0)
                {
                    // Treat as rounded if the true exponent is greater
                    // than the "ideal" exponent
                    ctx.Flags |= EContext.FlagRounded;
                }
                EInteger bigexp = exp.AsEInteger();
                T retval = this.helper.CreateNewWithFlags(
                  bigResult,
                  bigexp,
                  resultNeg ? BigNumberFlags.FlagNegative : 0);
                return this.RoundToPrecisionInternal(
          retval,
          lastDiscarded,
          olderDiscarded,
          null,
          false,
          ctx);
            }
        }

        private T DivisionHandleSpecial(
      T thisValue,
      T other,
      EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0 && (otherFlags &
          BigNumberFlags.FlagInfinity) != 0)
                {
                    // Attempt to divide infinity by infinity
                    return this.SignalInvalid(ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.EnsureSign(
            thisValue,
            ((thisFlags ^ otherFlags) & BigNumberFlags.FlagNegative) != 0);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Divisor is infinity, so result will be epsilon
                    if (ctx != null && ctx.HasExponentRange && ctx.Precision.Sign > 0)
                    {
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= EContext.FlagClamped;
                        }
                        EInteger bigexp = ctx.EMin;
                        EInteger bigprec = ctx.Precision;
                        if (ctx.AdjustExponent)
                        {
                            bigexp -= (EInteger)bigprec;
                            bigexp += EInteger.One;
                        }
                        thisFlags = (thisFlags ^ otherFlags) & BigNumberFlags.FlagNegative;
                        return this.helper.CreateNewWithFlags(
              EInteger.Zero,
              bigexp,
              thisFlags);
                    }
                    thisFlags = (thisFlags ^ otherFlags) & BigNumberFlags.FlagNegative;
                    return this.RoundToPrecision(
             this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, thisFlags),
             ctx);
                }
            }
            return default(T);
        }

        private T EnsureSign(T val, bool negative)
        {
            if (val == null)
            {
                return val;
            }
            int flags = this.helper.GetFlags(val);
            if ((negative && (flags & BigNumberFlags.FlagNegative) == 0) ||
                (!negative && (flags & BigNumberFlags.FlagNegative) != 0))
            {
                flags &= ~BigNumberFlags.FlagNegative;
                flags |= negative ? BigNumberFlags.FlagNegative : 0;
                return this.helper.CreateNewWithFlags(
          this.helper.GetMantissa(val),
          this.helper.GetExponent(val),
          flags);
            }
            return val;
        }

        private T ExpInternal(
      T thisValue,
      EInteger workingPrecision,
      EContext ctx)
        {
            T one = this.helper.ValueOf(1);
            int precisionAdd = this.thisRadix == 2 ? 18 : 12;
            EContext ctxdiv = SetPrecisionIfLimited(
              ctx,
              workingPrecision + (EInteger)precisionAdd)
              .WithRounding(ERounding.OddOrZeroFiveUp);
            EInteger bigintN = (EInteger)2;
            EInteger facto = EInteger.One;
            // Guess starts with 1 + thisValue
            T guess = this.Add(one, thisValue, null);
            T lastGuess = guess;
            T pow = thisValue;
            bool more = true;
            int lastCompare = 0;
            int vacillations = 0;
            while (more)
            {
                lastGuess = guess;
                // Iterate by:
                // newGuess = guess + (thisValue^n/factorial(n))
                // (n starts at 2 and increases by 1 after
                // each iteration)
                pow = this.Multiply(pow, thisValue, ctxdiv);
                facto *= (EInteger)bigintN;
                T tmp = this.Divide(
                  pow,
                  this.helper.CreateNewWithFlags(facto, EInteger.Zero, 0),
                  ctxdiv);
                T newGuess = this.Add(guess, tmp, ctxdiv);
                // DebugUtility.Log("newguess" +
                // this.helper.GetMantissa(newGuess)+" ctxdiv " +
                // ctxdiv.Precision);
                // DebugUtility.Log("newguess " + newGuess);
                // DebugUtility.Log("newguessN " + NextPlus(newGuess,ctxdiv));
                {
                    int guessCmp = this.CompareTo(lastGuess, newGuess);
                    if (guessCmp == 0)
                    {
                        more = false;
                    }
                    else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                            guessCmp < 0))
                    {
                        // Guesses are vacillating
                        ++vacillations;
                        more &= vacillations <= 3 || guessCmp <= 0;
                    }
                    lastCompare = guessCmp;
                }
                guess = newGuess;
                if (more)
                {
                    bigintN += EInteger.One;
                }
            }
            return this.RoundToPrecision(guess, ctx);
        }

        private T ExtendPrecision(T thisValue, EContext ctx)
        {
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            EInteger mant = this.helper.GetMantissa(thisValue);
            FastInteger digits =
              this.helper.CreateShiftAccumulator(mant).GetDigitLength();
            FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
            EInteger exponent = this.helper.GetExponent(thisValue);
            if (digits.CompareTo(fastPrecision) < 0)
            {
                fastPrecision.Subtract(digits);
                mant = this.TryMultiplyByRadixPower(mant, fastPrecision);
                if (mant == null)
                {
                    return this.SignalInvalidWithMessage(
                      ctx,
                      "Result requires too much memory");
                }
                EInteger bigPrec = fastPrecision.AsEInteger();
                exponent -= (EInteger)bigPrec;
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagRounded;
                ctx.Flags |= EContext.FlagInexact;
            }
            return this.RoundToPrecision(
              this.helper.CreateNewWithFlags(mant, exponent, 0),
              ctx);
        }

        private T HandleNotANumber(T thisValue, T other, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            // Check this value then the other value for signaling NaN
            if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            // Check this value then the other value for quiet NaN
            return ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(thisValue, ctx) : (((otherFlags &
                      BigNumberFlags.FlagQuietNaN) != 0) ? this.ReturnQuietNaN(
        other,
        ctx) : default(T));
        }

        private bool IsFinite(T val)
        {
            return (this.helper.GetFlags(val) & BigNumberFlags.FlagSpecial) == 0;
        }

        private bool IsNegative(T val)
        {
            return (this.helper.GetFlags(val) & BigNumberFlags.FlagNegative) != 0;
        }

        private bool IsWithinExponentRangeForPow(
          T thisValue,
          EContext ctx)
        {
            if (ctx == null || !ctx.HasExponentRange)
            {
                return true;
            }
            FastInteger digits =

        this.helper.CreateShiftAccumulator(this.helper.GetMantissa(thisValue))
              .GetDigitLength();
            EInteger exp = this.helper.GetExponent(thisValue);
            FastInteger fi = FastInteger.FromBig(exp);
            if (ctx.AdjustExponent)
            {
                fi.Add(digits);
                fi.Decrement();
            }
            // DebugUtility.Log("" + exp + " -> " + fi);
            if (fi.Sign < 0)
            {
                fi.Negate().Divide(2).Negate();
                // DebugUtility.Log("" + exp + " II -> " + fi);
            }
            exp = fi.AsEInteger();
            return exp.CompareTo(ctx.EMin) >= 0 && exp.CompareTo(ctx.EMax) <= 0;
        }

        private T LnInternal(
      T thisValue,
      EInteger workingPrecision,
      EContext ctx)
        {
            bool more = true;
            int lastCompare = 0;
            int vacillations = 0;
            EContext ctxdiv = SetPrecisionIfLimited(
              ctx,
              workingPrecision + (EInteger)6)
              .WithRounding(ERounding.OddOrZeroFiveUp);
            T z = this.Add(this.NegateRaw(thisValue), this.helper.ValueOf(1), null);
            T zpow = this.Multiply(z, z, ctxdiv);
            T guess = this.NegateRaw(z);
            T lastGuess = default(T);
            EInteger denom = (EInteger)2;
            while (more)
            {
                lastGuess = guess;
                T tmp = this.Divide(
          zpow,
          this.helper.CreateNewWithFlags(denom, EInteger.Zero, 0),
          ctxdiv);
                T newGuess = this.Add(guess, this.NegateRaw(tmp), ctxdiv);
                {
                    int guessCmp = this.CompareTo(lastGuess, newGuess);
                    if (guessCmp == 0)
                    {
                        more = false;
                    }
                    else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                            guessCmp < 0))
                    {
                        // Guesses are vacillating
                        ++vacillations;
                        more &= vacillations <= 3 || guessCmp <= 0;
                    }
                    lastCompare = guessCmp;
                }
                guess = newGuess;
                if (more)
                {
                    zpow = this.Multiply(zpow, z, ctxdiv);
                    denom += EInteger.One;
                }
            }
            return this.RoundToPrecision(guess, ctx);
        }

        private T LnTenConstant(EContext ctx)
        {
#if DEBUG
            if (ctx == null)
            {
                throw new ArgumentNullException(nameof(ctx));
            }
#endif
            T thisValue = this.helper.ValueOf(10);
            FastInteger error;
            EInteger bigError;
            error = new FastInteger(10);
            bigError = error.AsEInteger();
            EContext ctxdiv = SetPrecisionIfLimited(
              ctx,
              ctx.Precision + bigError)
              .WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
            for (int i = 0; i < 9; ++i)
            {
                thisValue = this.SquareRoot(thisValue, ctxdiv.WithUnlimitedExponents());
            }
            // Find -Ln(1/thisValue)
            thisValue = this.Divide(this.helper.ValueOf(1), thisValue, ctxdiv);
            thisValue = this.LnInternal(thisValue, ctxdiv.Precision, ctxdiv);
            thisValue = this.NegateRaw(thisValue);
            thisValue = this.Multiply(thisValue, this.helper.ValueOf(1 << 9), ctx);
            if (ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInexact;
                ctx.Flags |= EContext.FlagRounded;
            }
            return thisValue;
        }

        private T MinMaxHandleSpecial(
      T thisValue,
      T otherValue,
      EContext ctx,
      bool isMinOp,
      bool compareAbs)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                // Check this value then the other value for signaling NaN
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(thisValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(otherValue, ctx);
                }
                // Check this value then the other value for quiet NaN
                if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        // both values are quiet NaN
                        return this.ReturnQuietNaN(thisValue, ctx);
                    }
                    // return "other" for being numeric
                    return this.RoundToPrecision(otherValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    // At this point, "thisValue" can't be NaN,
                    // return "thisValue" for being numeric
                    return this.RoundToPrecision(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if (compareAbs && (otherFlags & BigNumberFlags.FlagInfinity) == 0)
                    {
                        // treat this as larger
                        return isMinOp ? this.RoundToPrecision(otherValue, ctx) : thisValue;
                    }
                    // This value is infinity
                    if (isMinOp)
                    {
                        // if negative, will be less than every other number
                        return ((thisFlags & BigNumberFlags.FlagNegative) != 0) ?
                          thisValue : this.RoundToPrecision(otherValue, ctx);
                        // if positive, will be greater
                    }
                    // if positive, will be greater than every other number
                    return ((thisFlags & BigNumberFlags.FlagNegative) == 0) ?
                      thisValue : this.RoundToPrecision(otherValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if (compareAbs)
                    {
                        // treat this as larger (the first value
                        // won't be infinity at this point
                        return isMinOp ? this.RoundToPrecision(thisValue, ctx) : otherValue;
                    }
                    return isMinOp ? (((otherFlags & BigNumberFlags.FlagNegative) ==
                              0) ? this.RoundToPrecision(thisValue, ctx) :
                       otherValue) : (((otherFlags & BigNumberFlags.FlagNegative) !=
                          0) ? this.RoundToPrecision(thisValue, ctx) : otherValue);
                }
            }
            return default(T);
        }

        private T MultiplyAddHandleSpecial(
      T op1,
      T op2,
      T op3,
      EContext ctx)
        {
            int op1Flags = this.helper.GetFlags(op1);
            // Check operands in order for signaling NaN
            if ((op1Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(op1, ctx);
            }
            int op2Flags = this.helper.GetFlags(op2);
            if ((op2Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(op2, ctx);
            }
            int op3Flags = this.helper.GetFlags(op3);
            if ((op3Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(op3, ctx);
            }
            // Check operands in order for quiet NaN
            if ((op1Flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(op1, ctx);
            }
            if ((op2Flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(op2, ctx);
            }
            // Check multiplying infinity by 0 (important to check
            // now before checking third operand for quiet NaN because
            // this signals invalid operation and the operation starts
            // with multiplying only the first two operands)
            if ((op1Flags & BigNumberFlags.FlagInfinity) != 0)
            {
                // Attempt to multiply infinity by 0
                if ((op2Flags & BigNumberFlags.FlagSpecial) == 0 &&
                    this.helper.GetMantissa(op2).IsZero)
                {
                    return this.SignalInvalid(ctx);
                }
            }
            if ((op2Flags & BigNumberFlags.FlagInfinity) != 0)
            {
                // Attempt to multiply infinity by 0
                if ((op1Flags & BigNumberFlags.FlagSpecial) == 0 &&
                    this.helper.GetMantissa(op1).IsZero)
                {
                    return this.SignalInvalid(ctx);
                }
            }
            // Now check third operand for quiet NaN
            return ((op3Flags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(op3, ctx) : default(T);
        }

        private T NegateRaw(T val)
        {
            if (val == null)
            {
                return val;
            }
            int sign = this.helper.GetFlags(val) & BigNumberFlags.FlagNegative;
            return this.helper.CreateNewWithFlags(
        this.helper.GetMantissa(val),
        this.helper.GetExponent(val),
        sign == 0 ? BigNumberFlags.FlagNegative : 0);
        }

        private T PowerIntegral(
      T thisValue,
      EInteger powIntBig,
      EContext ctx)
        {
            int sign = powIntBig.Sign;
            T one = this.helper.ValueOf(1);
            if (sign == 0)
            {
                // however 0 to the power of 0 is undefined
                return this.RoundToPrecision(one, ctx);
            }
            if (powIntBig.Equals(EInteger.One))
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            if (powIntBig.Equals((EInteger)2))
            {
                return this.Multiply(thisValue, thisValue, ctx);
            }
            if (powIntBig.Equals((EInteger)3))
            {
                return this.Multiply(
          thisValue,
          this.Multiply(thisValue, thisValue, null),
          ctx);
            }
            bool retvalNeg = this.IsNegative(thisValue) && !powIntBig.IsEven;
            FastInteger error = this.helper.CreateShiftAccumulator(
              powIntBig.Abs()).GetDigitLength();
            error = error.Copy();
            error.AddInt(18);
            EInteger bigError = error.AsEInteger();
            EContext ctxdiv = SetPrecisionIfLimited(
              ctx,
              ctx.Precision + (EInteger)bigError)
              .WithRounding(ERounding.OddOrZeroFiveUp).WithBlankFlags();
            if (sign < 0)
            {
                // Use the reciprocal for negative powers
                thisValue = this.Divide(one, thisValue, ctxdiv);
                if ((ctxdiv.Flags & EContext.FlagOverflow) != 0)
                {
                    return this.SignalOverflow2(ctx, retvalNeg);
                }
                powIntBig = -powIntBig;
            }
            T r = one;
            while (!powIntBig.IsZero)
            {
                if (!powIntBig.IsEven)
                {
                    r = this.Multiply(r, thisValue, ctxdiv);
                    if ((ctxdiv.Flags & EContext.FlagOverflow) != 0)
                    {
                        return this.SignalOverflow2(ctx, retvalNeg);
                    }
                }
                powIntBig >>= 1;
                if (!powIntBig.IsZero)
                {
                    ctxdiv.Flags = 0;
                    T tmp = this.Multiply(thisValue, thisValue, ctxdiv);
                    if ((ctxdiv.Flags & EContext.FlagOverflow) != 0)
                    {
                        // Avoid multiplying too huge numbers with
                        // limited exponent range
                        return this.SignalOverflow2(ctx, retvalNeg);
                    }
                    thisValue = tmp;
                }
                // DebugUtility.Log("r="+r);
            }
            return this.RoundToPrecision(r, ctx);
        }

        private T ReduceToPrecisionAndIdealExponent(
          T thisValue,
          EContext ctx,
          FastInteger precision,
          FastInteger idealExp)
        {
            T ret = this.RoundToPrecision(thisValue, ctx);
            if (ret != null && (this.helper.GetFlags(ret) &
                          BigNumberFlags.FlagSpecial) == 0)
            {
                EInteger bigmant = this.helper.GetMantissa(ret);
                FastInteger exp = FastInteger.FromBig(this.helper.GetExponent(ret));
                int radix = this.thisRadix;
                if (bigmant.IsZero)
                {
                    exp = new FastInteger(0);
                }
                else
                {
                    FastInteger digits = (precision == null) ? null :
                      this.helper.CreateShiftAccumulator(bigmant).GetDigitLength();
                    bigmant = NumberUtility.ReduceTrailingZeros(
                      bigmant,
                      exp,
                      radix,
                      digits,
                      precision,
                      idealExp);
                }
                int flags = this.helper.GetFlags(thisValue);
                ret = this.helper.CreateNewWithFlags(
          bigmant,
          exp.AsEInteger(),
          flags);
                if (ctx != null && ctx.ClampNormalExponents)
                {
                    EContext ctxtmp = ctx.WithBlankFlags();
                    ret = this.RoundToPrecision(ret, ctxtmp);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxtmp.Flags & ~EContext.FlagClamped;
                    }
                }
                ret = this.EnsureSign(ret, (flags & BigNumberFlags.FlagNegative) != 0);
            }
            return ret;
        }

        private T RemainderHandleSpecial(
      T thisValue,
      T other,
      EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.SignalInvalid(ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.RoundToPrecision(thisValue, ctx);
                }
            }
            return this.helper.GetMantissa(other).IsZero ? this.SignalInvalid(ctx) :
              default(T);
        }

        private T ReturnQuietNaN(T thisValue, EContext ctx)
        {
            EInteger mant = this.helper.GetMantissa(thisValue);
            bool mantChanged = false;
            if (!mant.IsZero && ctx != null && ctx.HasMaxPrecision)
            {
                FastInteger compPrecision = FastInteger.FromBig(ctx.Precision);
                if (this.helper.CreateShiftAccumulator(mant).GetDigitLength()
                    .CompareTo(compPrecision) >= 0)
                {
                    // Mant's precision is higher than the maximum precision
                    EInteger limit = this.TryMultiplyByRadixPower(
                      EInteger.One,
                      compPrecision);
                    if (limit == null)
                    {
                        // Limit can't be allocated
                        return this.SignalInvalidWithMessage(
              ctx,
              "Result requires too much memory");
                    }
                    if (mant.CompareTo(limit) >= 0)
                    {
                        mant %= (EInteger)limit;
                        mantChanged = true;
                    }
                }
            }
            int flags = this.helper.GetFlags(thisValue);
            if (!mantChanged && (flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return thisValue;
            }
            flags &= BigNumberFlags.FlagNegative;
            flags |= BigNumberFlags.FlagQuietNaN;
            return this.helper.CreateNewWithFlags(mant, EInteger.Zero, flags);
        }

        private bool RoundGivenAccum(
      IShiftAccumulator accum,
      ERounding rounding,
      bool neg)
        {
            bool incremented = false;
            int radix = this.thisRadix;
            int lastDiscarded = accum.LastDiscardedDigit;
            int olderDiscarded = accum.OlderDiscardedDigits;
            if (rounding == ERounding.OddOrZeroFiveUp)
            {
                rounding = (radix == 2) ? ERounding.Odd : ERounding.ZeroFiveUp;
            }
            if (rounding == ERounding.HalfUp)
            {
                incremented |= lastDiscarded >= (radix / 2);
            }
            else if (rounding == ERounding.HalfEven)
            {
                if (lastDiscarded >= (radix / 2))
                {
                    if (lastDiscarded > (radix / 2) || olderDiscarded != 0)
                    {
                        incremented = true;
                    }
                    else
                    {
                        incremented |= !accum.ShiftedIntFast.IsEvenNumber;
                    }
                }
            }
            else if (rounding == ERounding.Ceiling)
            {
                incremented |= !neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Floor)
            {
                incremented |= neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.HalfDown)
            {
                incremented |= lastDiscarded > (radix / 2) || (lastDiscarded ==
                        (radix / 2) && olderDiscarded != 0);
            }
            else if (rounding == ERounding.Up)
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Odd)
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0 &&
                  accum.ShiftedIntFast.IsEvenNumber;
            }
            else if (rounding == ERounding.ZeroFiveUp)
            {
                if ((lastDiscarded | olderDiscarded) != 0)
                {
                    if (radix == 2)
                    {
                        incremented = true;
                    }
                    else
                    {
                        int lastDigit = FastIntegerFixed.FromFastInteger(
                          accum.ShiftedIntFast).Mod(radix);
                        if (lastDigit == 0 || lastDigit == (radix / 2))
                        {
                            incremented = true;
                        }
                    }
                }
            }
            return incremented;
        }

        private bool RoundGivenDigits(
      int lastDiscarded,
      int olderDiscarded,
      ERounding rounding,
      bool neg,
      EInteger bigval)
        {
            bool incremented = false;
            int radix = this.thisRadix;
            if (rounding == ERounding.OddOrZeroFiveUp)
            {
                rounding = (radix == 2) ? ERounding.Odd : ERounding.ZeroFiveUp;
            }
            if (rounding == ERounding.HalfUp)
            {
                incremented |= lastDiscarded >= (radix / 2);
            }
            else if (rounding == ERounding.HalfEven)
            {
                if (lastDiscarded >= (radix / 2))
                {
                    if (lastDiscarded > (radix / 2) || olderDiscarded != 0)
                    {
                        incremented = true;
                    }
                    else
                    {
                        incremented |= !bigval.IsEven;
                    }
                }
            }
            else if (rounding == ERounding.Ceiling)
            {
                incremented |= !neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Floor)
            {
                incremented |= neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.HalfDown)
            {
                incremented |= lastDiscarded > (radix / 2) || (lastDiscarded ==
                        (radix / 2) && olderDiscarded != 0);
            }
            else if (rounding == ERounding.Up)
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Odd)
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0 && bigval.IsEven;
            }
            else if (rounding == ERounding.ZeroFiveUp)
            {
                if ((lastDiscarded | olderDiscarded) != 0)
                {
                    if (radix == 2)
                    {
                        incremented = true;
                    }
                    else
                    {
                        EInteger bigdigit = bigval % (EInteger)radix;
                        int lastDigit = (int)bigdigit;
                        if (lastDigit == 0 || lastDigit == (radix / 2))
                        {
                            incremented = true;
                        }
                    }
                }
            }
            return incremented;
        }

        // binaryPrec means whether precision is the number of bits and not
        // digits
        private T RoundToPrecisionInternal(
      T thisValue,
      int lastDiscarded,
      int olderDiscarded,
      FastInteger shift,
      bool adjustNegativeZero,
      EContext ctx)
        {
            // If context has unlimited precision and exponent range,
            // and no discarded digits or shifting
            bool unlimitedPrecisionExp = ctx == null ||
               (!ctx.HasMaxPrecision && !ctx.HasExponentRange);
            int thisFlags = this.helper.GetFlags(thisValue);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    if (ctx != null && ctx.HasFlags)
                    {
                        ctx.Flags |= EContext.FlagInvalid;
                    }
                    return this.ReturnQuietNaN(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    return this.ReturnQuietNaN(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return thisValue;
                }
            }
            if (unlimitedPrecisionExp &&
               (lastDiscarded | olderDiscarded) == 0 &&
               (shift == null || shift.IsValueZero))
            {
                if (!(adjustNegativeZero &&
                  (thisFlags & BigNumberFlags.FlagNegative) != 0 &&
                  this.helper.GetMantissa(thisValue).IsZero))
                {
                    return thisValue;
                }
            }
            if (unlimitedPrecisionExp &&
              (ctx == null || (!ctx.HasFlags && ctx.Traps == 0)) &&
              (shift == null || shift.IsValueZero))
            {
                ERounding er = (ctx == null) ? ERounding.HalfDown : ctx.Rounding;
                bool negative = (thisFlags & BigNumberFlags.FlagNegative) != 0;
                bool negzero = adjustNegativeZero && negative &&
                this.helper.GetMantissa(thisValue).IsZero &&
                (er != ERounding.Floor);
                if (!negzero)
                {
                    if (er == ERounding.Down)
                    {
                        return thisValue;
                    }
                    if (this.thisRadix == 10 && (er == ERounding.HalfEven) &&
                      lastDiscarded < 5)
                    {
                        return thisValue;
                    }
                    if (this.thisRadix == 10 && (er == ERounding.HalfEven) &&
                      (lastDiscarded > 5 || olderDiscarded != 0))
                    {
                        FastIntegerFixed bm = this.helper.GetMantissaFastInt(thisValue);
                        return this.helper.CreateNewWithFlagsFastInt(
                          FastIntegerFixed.Add(bm, FastIntegerFixed.One),
                          this.helper.GetExponentFastInt(thisValue),
                          thisFlags);
                    }
                    if (this.thisRadix == 2 && (er == ERounding.HalfEven) &&
                      lastDiscarded == 0)
                    {
                        return thisValue;
                    }
                    if (!this.RoundGivenDigits(
           lastDiscarded,
           olderDiscarded,
           er,
           negative,
                      this.helper.GetMantissa(thisValue)))
                    {
                        return thisValue;
                    }
                    else
                    {
                        FastIntegerFixed bm = this.helper.GetMantissaFastInt(thisValue);
                        return this.helper.CreateNewWithFlagsFastInt(
                          FastIntegerFixed.Add(bm, FastIntegerFixed.One),
                          this.helper.GetExponentFastInt(thisValue),
                          thisFlags);
                    }
                }
            }
            ctx = ctx ?? EContext.UnlimitedHalfEven.WithRounding(ERounding.HalfEven);
            bool binaryPrec = ctx.IsPrecisionInBits;
            // get the precision
            FastInteger fastPrecision = ctx.Precision.CanFitInInt32() ? new
          FastInteger(ctx.Precision.ToInt32Checked()) :
            FastInteger.FromBig(ctx.Precision);
            // No need to check if precision is less than 0, since the
            // PrecisionContext object should already ensure this
            binaryPrec &= this.thisRadix != 2 && !fastPrecision.IsValueZero;
            IShiftAccumulator accum = null;
            FastInteger fastAdjustedExp;
            FastInteger fastNormalMin;
            FastInteger fastEMin = null;
            FastInteger fastEMax = null;
            // get the exponent range
            if (ctx != null && ctx.HasExponentRange)
            {
                fastEMax = ctx.EMax.CanFitInInt32() ? new
               FastInteger(ctx.EMax.ToInt32Checked()) : FastInteger.FromBig(ctx.EMax);
                fastEMin = ctx.EMin.CanFitInInt32() ? new
               FastInteger(ctx.EMin.ToInt32Checked()) : FastInteger.FromBig(ctx.EMin);
            }
            ERounding rounding = (ctx == null) ? ERounding.HalfEven : ctx.Rounding;
            bool unlimitedPrec = fastPrecision.IsValueZero;
            if (!binaryPrec)
            {
                // if (total%100 == 0) {
                // DebugUtility.Log("used=" + used + "/" + eligible + "/" + total);
                // }
                // Fast path to check if rounding is necessary at all
                // NOTE: At this point, the number won't be infinity or NaN
                if (fastPrecision.Sign > 0 && (shift == null || shift.IsValueZero))
                {
                    FastIntegerFixed mantabs = this.helper.GetMantissaFastInt(thisValue);
                    if (adjustNegativeZero && (thisFlags & BigNumberFlags.FlagNegative) !=
                        0 && mantabs.IsValueZero && (ctx.Rounding != ERounding.Floor))
                    {
                        // Change negative zero to positive zero
                        // except if the rounding mode is Floor
                        thisValue = this.EnsureSign(thisValue, false);
                        thisFlags = 0;
                    }
                    accum = this.helper.CreateShiftAccumulatorWithDigitsFastInt(
                      mantabs,
                      lastDiscarded,
                      olderDiscarded);
                    FastInteger digitCount = accum.GetDigitLength();
                    if (digitCount.CompareTo(fastPrecision) <= 0)
                    {
                        if (!this.RoundGivenAccum(
              accum,
              ctx.Rounding,
              (thisFlags & BigNumberFlags.FlagNegative) != 0))
                        {
                            if (ctx.HasFlags && (lastDiscarded | olderDiscarded) != 0)
                            {
                                ctx.Flags |= EContext.FlagInexact | EContext.FlagRounded;
                            }
                            if (!ctx.HasExponentRange)
                            {
                                return thisValue;
                            }
                            FastIntegerFixed bigexp = this.helper.GetExponentFastInt(thisValue);
                            if (ctx == null || ctx.AdjustExponent)
                            {
                                fastAdjustedExp = bigexp.ToFastInteger()
                                  .Add(fastPrecision).Decrement();
                                fastNormalMin = fastEMin.Copy()
                                  .Add(fastPrecision).Decrement();
                            }
                            else
                            {
                                fastAdjustedExp = bigexp.ToFastInteger();
                                fastNormalMin = fastEMin;
                            }
                            // DebugUtility.Log("{0}->{1},{2}"
                            // , fastAdjustedExp, fastEMax, fastNormalMin);
                            if (fastAdjustedExp.CompareTo(fastEMax) <= 0 &&
                                fastAdjustedExp.CompareTo(fastNormalMin) >= 0)
                            {
                                return thisValue;
                            }
                        }
                        else
                        {
                            if (ctx.HasFlags && (lastDiscarded | olderDiscarded) != 0)
                            {
                                ctx.Flags |= EContext.FlagInexact | EContext.FlagRounded;
                            }
                            bool stillWithinPrecision = false;
                            mantabs = mantabs.Increment();
                            int precisionCmp = digitCount.CompareTo(fastPrecision);
                            if (precisionCmp < 0 ||
                                (precisionCmp == 0 && (this.thisRadix & 1) == 0 &&
                                !mantabs.IsEvenNumber))
                            {
                                stillWithinPrecision = true;
                            }
                            else
                            {
                                EInteger radixPower =
                                  this.TryMultiplyByRadixPower(EInteger.One, fastPrecision);
                                // DebugUtility.Log("now " + mantabs + "," + fastPrecision);
                                if (radixPower == null)
                                {
                                    return this.SignalInvalidWithMessage(
                                  ctx,
                                  "Result requires too much memory");
                                }
                                stillWithinPrecision =
                                      mantabs.ToEInteger().CompareTo(radixPower) <
                                        0;
                            }
                            if (stillWithinPrecision)
                            {
                                if (!ctx.HasExponentRange)
                                {
                                    return this.helper.CreateNewWithFlagsFastInt(
                                      mantabs,
                                      this.helper.GetExponentFastInt(thisValue),
                                      thisFlags);
                                }
                                FastIntegerFixed bigexp = this.helper.GetExponentFastInt(thisValue);
                                if (ctx == null || ctx.AdjustExponent)
                                {
                                    fastAdjustedExp = bigexp.ToFastInteger()
                                      .Add(fastPrecision).Decrement();
                                    fastNormalMin = fastEMin.Copy()
                                      .Add(fastPrecision).Decrement();
                                }
                                else
                                {
                                    fastAdjustedExp = bigexp.ToFastInteger();
                                    fastNormalMin = fastEMin;
                                }
                                if (fastAdjustedExp.CompareTo(fastEMax) <= 0 &&
                                    fastAdjustedExp.CompareTo(fastNormalMin) >= 0)
                                {
                                    return this.helper.CreateNewWithFlagsFastInt(
                    mantabs,
                    bigexp,
                    thisFlags);
                                }
                            }
                        }
                    }
                }
            }
            if (adjustNegativeZero && (thisFlags & BigNumberFlags.FlagNegative) !=
                0 && (rounding != ERounding.Floor) &&
               this.helper.GetMantissa(thisValue).IsZero)
            {
                // Change negative zero to positive zero
                // except if the rounding mode is Floor
                thisValue = this.EnsureSign(thisValue, false);
                thisFlags = 0;
            }
            bool neg = (thisFlags & BigNumberFlags.FlagNegative) != 0;
            FastIntegerFixed bigmantissa = this.helper.GetMantissaFastInt(thisValue);
            bool mantissaWasZero = bigmantissa.IsValueZero && (lastDiscarded |
                          olderDiscarded) == 0;
            FastInteger exp = this.helper.GetExponentFastInt(thisValue).ToFastInteger();
            int flags = 0;
            if (accum == null)
            {
                accum = this.helper.CreateShiftAccumulatorWithDigitsFastInt(
                          bigmantissa,
                          lastDiscarded,
                          olderDiscarded);
            }
#if DEBUG
            if (!accum.DiscardedDigitCount.IsValueZero)
            {
                throw new ArgumentException(
              "doesn't satisfy accum.DiscardedDigitCount.IsValueZero");
            }
#endif
            FastInteger bitLength = fastPrecision;
            if (binaryPrec)
            {
                fastPrecision = this.MaxDigitLengthForBitLength(fastPrecision);
            }
            bool nonHalfRounding = rounding != ERounding.HalfEven &&
              rounding != ERounding.HalfUp && rounding != ERounding.HalfDown;
            if (!unlimitedPrec)
            {
                accum.ShiftToDigits(fastPrecision, shift, nonHalfRounding);
            }
            else
            {
                if (shift != null && shift.Sign != 0)
                {
                    if (nonHalfRounding)
                    {
                        accum.TruncateRight(shift);
                    }
                    else
                    {
                        accum.ShiftRight(shift);
                    }
                }
                fastPrecision = accum.GetDigitLength();
            }
            if (binaryPrec)
            {
                while (this.IsHigherThanBitLength(accum.ShiftedInt, bitLength))
                {
                    accum.ShiftRightInt(1);
                }
            }
            FastInteger discardedBits = accum.DiscardedDigitCount.Copy();
            exp.Add(discardedBits);
            FastInteger adjExponent;
            adjExponent = ctx.AdjustExponent ?
              exp.Copy().Add(accum.GetDigitLength()).Decrement() : exp.Copy();
            if (binaryPrec && fastEMax != null && adjExponent.CompareTo(fastEMax)
                == 0)
            {
                // May or may not be an overflow depending on the mantissa
                FastInteger expdiff =
                  fastPrecision.Copy().Subtract(accum.GetDigitLength());
                EInteger currMantissa = accum.ShiftedInt;
                currMantissa = this.TryMultiplyByRadixPower(currMantissa, expdiff);
                if (currMantissa == null)
                {
                    return this.SignalInvalidWithMessage(
                      ctx,
                      "Result requires too much memory");
                }
                if (this.IsHigherThanBitLength(currMantissa, bitLength))
                {
                    // Mantissa too high, treat as overflow
                    adjExponent.Increment();
                }
            }
            if (fastEMax != null && adjExponent.CompareTo(fastEMax) > 0)
            {
                if (mantissaWasZero)
                {
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= flags | EContext.FlagClamped;
                    }
                    if (ctx.ClampNormalExponents)
                    {
                        // Clamp exponents to eMax + 1 - precision
                        // if directed
                        FastInteger clampExp = fastEMax.Copy();
                        if (ctx.AdjustExponent)
                        {
                            clampExp.Increment().Subtract(fastPrecision);
                        }
                        if (fastEMax.CompareTo(clampExp) > 0)
                        {
                            if (ctx.HasFlags)
                            {
                                ctx.Flags |= EContext.FlagClamped;
                            }
                            fastEMax = clampExp;
                        }
                    }
                    return this.helper.CreateNewWithFlagsFastInt(
            bigmantissa,
            FastIntegerFixed.FromFastInteger(fastEMax),
            thisFlags);
                }
                // Overflow
                flags |= EContext.FlagOverflow |
                  EContext.FlagInexact | EContext.FlagRounded;
                if (rounding == ERounding.None)
                {
                    return this.SignalInvalidWithMessage(ctx, "Rounding was required");
                }
                if (!unlimitedPrec && (rounding == ERounding.Down || rounding ==
                        ERounding.ZeroFiveUp ||
                      (rounding == ERounding.OddOrZeroFiveUp && this.thisRadix != 2) ||
                        (rounding == ERounding.Ceiling && neg) || (rounding ==
                          ERounding.Floor && !neg)))
                {
                    // Set to the highest possible value for
                    // the given precision
                    EInteger overflowMant = EInteger.Zero;
                    if (binaryPrec)
                    {
                        overflowMant = ShiftedMask(bitLength);
                    }
                    else
                    {
                        overflowMant = this.TryMultiplyByRadixPower(
                          EInteger.One,
                          fastPrecision);
                        if (overflowMant == null)
                        {
                            return this.SignalInvalidWithMessage(
                              ctx,
                              "Result requires too much memory");
                        }
                        overflowMant -= EInteger.One;
                    }
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= flags;
                    }
                    FastInteger clamp = ctx.AdjustExponent ?
                      fastEMax.Copy().Increment().Subtract(fastPrecision) :
                      fastEMax;
                    return this.helper.CreateNewWithFlagsFastInt(
                      FastIntegerFixed.FromBig(overflowMant),
                      FastIntegerFixed.FromFastInteger(clamp),
                      neg ? BigNumberFlags.FlagNegative : 0);
                }
                if (ctx.HasFlags)
                {
                    ctx.Flags |= flags;
                }
                return this.SignalOverflow(neg);
            }
            if (fastEMin != null && adjExponent.CompareTo(fastEMin) < 0)
            {
                // Subnormal
                FastInteger fastETiny = fastEMin;
                if (ctx.AdjustExponent)
                {
                    fastETiny = fastETiny.Copy().Subtract(fastPrecision).Increment();
                }
                if (ctx.HasFlags)
                {
                    if (!accum.ShiftedInt.IsZero)
                    {
                        FastInteger newAdjExponent = adjExponent;
                        if (this.RoundGivenAccum(accum, rounding, neg))
                        {
                            EInteger earlyRounded = accum.ShiftedInt + EInteger.One;
                            if (!unlimitedPrec && (earlyRounded.IsEven || (this.thisRadix & 1) !=
                                  0))
                            {
                                IShiftAccumulator accum2 =
                                  this.helper.CreateShiftAccumulator(earlyRounded);
                                FastInteger newDigitLength = accum2.GetDigitLength();
                                // Ensure newDigitLength doesn't exceed precision
                                if (binaryPrec || newDigitLength.CompareTo(fastPrecision) > 0)
                                {
                                    newDigitLength = fastPrecision.Copy();
                                }
                                newAdjExponent = ctx.AdjustExponent ?
                                  exp.Copy().Add(newDigitLength).Decrement() : exp;
                            }
                        }
                        if (newAdjExponent.CompareTo(fastEMin) < 0)
                        {
                            // DebugUtility.Log("subnormal");
                            flags |= EContext.FlagSubnormal;
                        }
                    }
                }
                // DebugUtility.Log("exp=" + exp + " eTiny=" + fastETiny);
                FastInteger subExp = exp.Copy();
                // DebugUtility.Log("exp=" + subExp + " eTiny=" + fastETiny);
                if (subExp.CompareTo(fastETiny) < 0)
                {
                    // DebugUtility.Log("Less than ETiny");
                    FastInteger expdiff = fastETiny.Copy().Subtract(exp);
                    // DebugUtility.Log("<ETiny: " + (accum.ShiftedInt));
                    if (nonHalfRounding)
                    {
                        accum.TruncateRight(expdiff);
                    }
                    else
                    {
                        accum.ShiftRight(expdiff);
                    }
                    // DebugUtility.Log("<ETiny2: " + (accum.ShiftedInt));
                    FastInteger newmantissa = accum.ShiftedIntFast;
                    bool nonZeroDiscardedDigits = (accum.LastDiscardedDigit |
                      accum.OlderDiscardedDigits) != 0;
                    // DebugUtility.Log("<nzdd= " + nonZeroDiscardedDigits);
                    if (nonZeroDiscardedDigits && rounding == ERounding.None)
                    {
                        return this.SignalInvalidWithMessage(
                          ctx,
                          "Rounding was required");
                    }
                    if (accum.DiscardedDigitCount.Sign != 0 || nonZeroDiscardedDigits)
                    {
                        if (ctx.HasFlags)
                        {
                            if (!mantissaWasZero)
                            {
                                flags |= EContext.FlagRounded;
                            }
                            if (nonZeroDiscardedDigits)
                            {
                                flags |= EContext.FlagInexact |
                                  EContext.FlagRounded;
                            }
                        }
                        if (this.RoundGivenAccum(accum, rounding, neg))
                        {
                            newmantissa.Increment();
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        if (newmantissa.IsValueZero)
                        {
                            flags |= EContext.FlagClamped;
                        }
                        // DebugUtility.Log("" + flags + "," + (flags &
                        // (EContext.FlagSubnormal |
                        // EContext.FlagInexact)));
                        if ((flags & (EContext.FlagSubnormal |
                        EContext.FlagInexact)) == (EContext.FlagSubnormal |
                             EContext.FlagInexact))
                        {
                            flags |= EContext.FlagUnderflow |
                              EContext.FlagRounded;
                        }
                        ctx.Flags |= flags;
                    }
                    if (ctx.ClampNormalExponents)
                    {
                        // Clamp exponents to eMax + 1 - precision
                        // if directed
                        FastInteger clampExp = fastEMax.Copy();
                        if (ctx.AdjustExponent)
                        {
                            clampExp.Increment().Subtract(fastPrecision);
                        }
                        if (fastETiny.CompareTo(clampExp) > 0)
                        {
                            if (!newmantissa.IsValueZero)
                            {
                                expdiff = fastETiny.Copy().Subtract(clampExp);
                                // Change bigmantissa for use
                                // in the return value
                                bigmantissa = this.TryMultiplyByRadixPowerFastInt(
                                FastIntegerFixed.FromFastInteger(newmantissa),
                                expdiff);
                                if (bigmantissa == null)
                                {
                                    return this.SignalInvalidWithMessage(
                                  ctx,
                                  "Result requires too much memory");
                                }
                                if (ctx.HasFlags)
                                {
                                    ctx.Flags |= EContext.FlagClamped;
                                }
                                return this.helper.CreateNewWithFlagsFastInt(
                                  bigmantissa,
                                  FastIntegerFixed.FromFastInteger(clampExp),
                                  neg ? BigNumberFlags.FlagNegative : 0);
                            }
                            if (ctx.HasFlags)
                            {
                                ctx.Flags |= EContext.FlagClamped;
                            }
                            fastETiny = clampExp;
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= flags;
                    }
                    return this.helper.CreateNewWithFlagsFastInt(
            FastIntegerFixed.FromFastInteger(newmantissa),
            FastIntegerFixed.FromFastInteger(fastETiny),
            neg ? BigNumberFlags.FlagNegative : 0);
                }
            }
            // DebugUtility.Log("" + accum.ShiftedInt + ", exp=" + (//
            // adjExponent) + "/" + fastEMin);
            bool recheckOverflow = false;
            bool doRounding = accum.DiscardedDigitCount.Sign != 0 ||
              (accum.LastDiscardedDigit | accum.OlderDiscardedDigits) != 0;
            if (doRounding)
            {
                if (!bigmantissa.IsValueZero)
                {
                    flags |= EContext.FlagRounded;
                }
                bigmantissa = FastIntegerFixed.FromFastInteger(accum.ShiftedIntFast);
                if ((accum.LastDiscardedDigit | accum.OlderDiscardedDigits) != 0)
                {
                    flags |= EContext.FlagInexact | EContext.FlagRounded;
                    if (rounding == ERounding.None)
                    {
                        return this.SignalInvalidWithMessage(ctx, "Rounding was required");
                    }
                }
                if (this.RoundGivenAccum(accum, rounding, neg))
                {
                    // DebugUtility.Log("recheck overflow {0} {1} / {2}"
                    // , adjExponent, fastEMax, accum.ShiftedInt);
                    bigmantissa = bigmantissa.Increment();
                    recheckOverflow |= binaryPrec;
                    // Check if mantissa's precision is now greater
                    // than the one set by the context
                    if (!unlimitedPrec && (bigmantissa.IsEvenNumber || (this.thisRadix &
                          1) != 0) && (binaryPrec ||
                          accum.GetDigitLength().CompareTo(fastPrecision) >=
                              0))
                    {
                        accum = this.helper.CreateShiftAccumulatorWithDigitsFastInt(
                          bigmantissa,
                          0,
                          0);
                        FastInteger newDigitLength = accum.GetDigitLength();
                        if (binaryPrec || newDigitLength.CompareTo(fastPrecision) > 0)
                        {
                            FastInteger neededShift =
                              newDigitLength.Copy().Subtract(fastPrecision);
                            if (nonHalfRounding)
                            {
                                accum.TruncateRight(neededShift);
                            }
                            else
                            {
                                accum.ShiftRight(neededShift);
                            }
                            if (binaryPrec)
                            {
                                while (
                    this.IsHigherThanBitLength(
                    accum.ShiftedInt,
                    bitLength))
                                {
                                    accum.ShiftRightInt(1);
                                }
                            }
                            if (accum.DiscardedDigitCount.Sign != 0)
                            {
                                exp.Add(accum.DiscardedDigitCount);
                                discardedBits.Add(accum.DiscardedDigitCount);
                                bigmantissa = FastIntegerFixed.FromFastInteger(
                                  accum.ShiftedIntFast);
                                recheckOverflow |= !binaryPrec;
                            }
                        }
                    }
                }
            }
            if (fastEMax != null && recheckOverflow)
            {
                // Check for overflow again
                // DebugUtility.Log("recheck overflow2 {0} {1} / {2}"
                // , adjExponent, fastEMax, accum.ShiftedInt);
                adjExponent = exp.Copy();
                if (ctx.AdjustExponent)
                {
                    adjExponent.Add(accum.GetDigitLength()).Decrement();
                }
                if (binaryPrec && fastEMax != null &&
                    adjExponent.CompareTo(fastEMax) == 0)
                {
                    // May or may not be an overflow depending on the mantissa
                    // (uses accumulator from previous steps, including the check
                    // if the mantissa now exceeded the precision)
                    FastInteger expdiff =
                      fastPrecision.Copy().Subtract(accum.GetDigitLength());
                    EInteger currMantissa = accum.ShiftedInt;
                    currMantissa = this.TryMultiplyByRadixPower(currMantissa, expdiff);
                    if (currMantissa == null)
                    {
                        return this.SignalInvalidWithMessage(
                          ctx,
                          "Result requires too much memory");
                    }
                    if (this.IsHigherThanBitLength(currMantissa, bitLength))
                    {
                        // Mantissa too high, treat as overflow
                        adjExponent.Increment();
                    }
                }
                if (adjExponent.CompareTo(fastEMax) > 0)
                {
                    flags |= EContext.FlagOverflow |
                      EContext.FlagInexact | EContext.FlagRounded;
                    if (!unlimitedPrec && (rounding == ERounding.Down || rounding ==
                             ERounding.ZeroFiveUp ||
                  (rounding == ERounding.OddOrZeroFiveUp || rounding == ERounding.Odd) ||
                      (rounding == ERounding.Ceiling &&
                          neg) || (rounding == ERounding.Floor && !neg)))
                    {
                        // Set to the highest possible value for
                        // the given precision
                        EInteger overflowMant = EInteger.Zero;
                        if (binaryPrec)
                        {
                            overflowMant = ShiftedMask(bitLength);
                        }
                        else
                        {
                            overflowMant = this.TryMultiplyByRadixPower(
                              EInteger.One,
                              fastPrecision);
                            if (overflowMant == null)
                            {
                                return this.SignalInvalidWithMessage(
                                ctx,
                                "Result requires too much memory");
                            }
                            overflowMant -= EInteger.One;
                        }
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= flags;
                        }
                        FastInteger clamp;
                        clamp = ctx.AdjustExponent ?
                          fastEMax.Copy().Increment().Subtract(fastPrecision) :
                          fastEMax;
                        return this.helper.CreateNewWithFlags(
                          overflowMant,
                          clamp.AsEInteger(),
                          neg ? BigNumberFlags.FlagNegative : 0);
                    }
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= flags;
                    }
                    return this.SignalOverflow(neg);
                }
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= flags;
            }
            if (ctx.ClampNormalExponents)
            {
                // Clamp exponents to eMax + 1 - precision
                // if directed
                FastInteger clampExp = fastEMax.Copy();
                if (ctx.AdjustExponent)
                {
                    clampExp.Increment().Subtract(fastPrecision);
                }
                if (exp.CompareTo(clampExp) > 0)
                {
                    if (!bigmantissa.IsValueZero)
                    {
                        FastInteger expdiff = exp.Copy().Subtract(clampExp);
                        // DebugUtility.Log("Clamping " + exp + " to " + clampExp);
                        bigmantissa = this.TryMultiplyByRadixPowerFastInt(
                          bigmantissa,
                          expdiff);
                        if (bigmantissa == null)
                        {
                            return this.SignalInvalidWithMessage(
                              ctx,
                              "Result requires too much memory");
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= EContext.FlagClamped;
                    }
                    exp = clampExp;
                }
            }
            return this.helper.CreateNewWithFlagsFastInt(
        bigmantissa,
        FastIntegerFixed.FromFastInteger(exp),
        neg ? BigNumberFlags.FlagNegative : 0);
        }

        private T RoundToScale(
      EInteger mantissa,
      EInteger remainder,
      EInteger divisor,
      EInteger desiredExponent,
      FastInteger shift,
      bool neg,
      EContext ctx)
        {
#if DEBUG
            if (mantissa.Sign < 0)
            {
                throw new ArgumentException("doesn't satisfy mantissa.Sign>= 0");
            }
            if (remainder.Sign < 0)
            {
                throw new ArgumentException("doesn't satisfy remainder.Sign>= 0");
            }
            if (divisor.Sign < 0)
            {
                throw new ArgumentException("doesn't satisfy divisor.Sign>= 0");
            }
#endif
            IShiftAccumulator accum;
            ERounding rounding = (ctx == null) ? ERounding.HalfEven : ctx.Rounding;
            int lastDiscarded = 0;
            int olderDiscarded = 0;
            if (!remainder.IsZero)
            {
                if (rounding == ERounding.HalfDown || rounding == ERounding.HalfUp ||
                    rounding == ERounding.HalfEven)
                {
                    EInteger halfDivisor = divisor >> 1;
                    int cmpHalf = remainder.CompareTo(halfDivisor);
                    if ((cmpHalf == 0) && divisor.IsEven)
                    {
                        // remainder is exactly half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 0;
                    }
                    else if (cmpHalf > 0)
                    {
                        // remainder is greater than half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 1;
                    }
                    else
                    {
                        // remainder is less than half
                        lastDiscarded = 0;
                        olderDiscarded = 1;
                    }
                }
                else
                {
                    // Rounding mode doesn't care about
                    // whether remainder is exactly half
                    if (rounding == ERounding.None)
                    {
                        return this.SignalInvalidWithMessage(ctx, "Rounding was required");
                    }
                    lastDiscarded = 1;
                    olderDiscarded = 1;
                }
            }
            int flags = 0;
            EInteger newmantissa = mantissa;
            if (shift.IsValueZero)
            {
                if ((lastDiscarded | olderDiscarded) != 0)
                {
                    flags |= EContext.FlagInexact | EContext.FlagRounded;
                    if (rounding == ERounding.None)
                    {
                        return this.SignalInvalidWithMessage(ctx, "Rounding was required");
                    }
                    if (
                      this.RoundGivenDigits(
            lastDiscarded,
            olderDiscarded,
            rounding,
            neg,
            newmantissa))
                    {
                        newmantissa += EInteger.One;
                    }
                }
            }
            else
            {
                accum = this.helper.CreateShiftAccumulatorWithDigits(
                  mantissa,
                  lastDiscarded,
                  olderDiscarded);
                accum.ShiftRight(shift);
                newmantissa = accum.ShiftedInt;
                if (accum.DiscardedDigitCount.Sign != 0 ||
                    (accum.LastDiscardedDigit | accum.OlderDiscardedDigits) !=
                    0)
                {
                    if (!mantissa.IsZero)
                    {
                        flags |= EContext.FlagRounded;
                    }
                    if ((accum.LastDiscardedDigit | accum.OlderDiscardedDigits) != 0)
                    {
                        flags |= EContext.FlagInexact | EContext.FlagRounded;
                        if (rounding == ERounding.None)
                        {
                            return this.SignalInvalidWithMessage(
                              ctx,
                              "Rounding was required");
                        }
                    }
                    if (this.RoundGivenAccum(accum, rounding, neg))
                    {
                        newmantissa += EInteger.One;
                    }
                }
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= flags;
            }
            return this.helper.CreateNewWithFlags(
              newmantissa,
              desiredExponent,
              neg ? BigNumberFlags.FlagNegative : 0);
        }

        private int[] RoundToScaleStatus(
      EInteger remainder,
      EInteger divisor,
      EContext ctx)
        {
            ERounding rounding = (ctx == null) ? ERounding.HalfEven : ctx.Rounding;
            int lastDiscarded = 0;
            int olderDiscarded = 0;
            if (!remainder.IsZero)
            {
                if (rounding == ERounding.HalfDown || rounding == ERounding.HalfUp ||
                    rounding == ERounding.HalfEven)
                {
                    EInteger halfDivisor = divisor.ShiftRight(1);
                    int cmpHalf = remainder.CompareTo(halfDivisor);
                    if ((cmpHalf == 0) && divisor.IsEven)
                    {
                        // remainder is exactly half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 0;
                    }
                    else if (cmpHalf > 0)
                    {
                        // remainder is greater than half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 1;
                    }
                    else
                    {
                        // remainder is less than half
                        lastDiscarded = 0;
                        olderDiscarded = 1;
                    }
                }
                else
                {
                    // Rounding mode doesn't care about
                    // whether remainder is exactly half
                    if (rounding == ERounding.None)
                    {
                        // Rounding was required
                        return null;
                    }
                    lastDiscarded = 1;
                    olderDiscarded = 1;
                }
            }
            return new[] { lastDiscarded, olderDiscarded };
        }

        private T SignalDivideByZero(EContext ctx, bool neg)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagDivideByZero;
            }
            if (this.support == BigNumberFlags.FiniteOnly)
            {
                throw new DivideByZeroException("Division by zero");
            }
            return this.helper.CreateNewWithFlags(
              EInteger.Zero,
              EInteger.Zero,
              BigNumberFlags.FlagInfinity | (neg ? BigNumberFlags.FlagNegative : 0));
        }

        private T SignalingNaNInvalid(T value, EContext ctx)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            return this.ReturnQuietNaN(value, ctx);
        }

        private T SignalInvalid(EContext ctx)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            if (this.support == BigNumberFlags.FiniteOnly)
            {
                throw new ArithmeticException("Invalid operation");
            }
            return this.helper.CreateNewWithFlags(
              EInteger.Zero,
              EInteger.Zero,
              BigNumberFlags.FlagQuietNaN);
        }

        private T SignalInvalidWithMessage(EContext ctx, string str)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            if (this.support == BigNumberFlags.FiniteOnly)
            {
                throw new ArithmeticException(str);
            }
            return this.helper.CreateNewWithFlags(
        EInteger.Zero,
        EInteger.Zero,
        BigNumberFlags.FlagQuietNaN);
        }

        private T SignalOverflow(bool neg)
        {
            return this.support == BigNumberFlags.FiniteOnly ? default(T) :
              this.helper.CreateNewWithFlags(
        EInteger.Zero,
        EInteger.Zero,
        (neg ? BigNumberFlags.FlagNegative : 0) | BigNumberFlags.FlagInfinity);
        }

        private T SignalOverflow2(EContext ctx, bool neg)
        {
            if (ctx != null)
            {
                ERounding roundingOnOverflow = ctx.Rounding;
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagOverflow |
                      EContext.FlagInexact | EContext.FlagRounded;
                }
                if (ctx.HasMaxPrecision && ctx.HasExponentRange &&
                    (roundingOnOverflow == ERounding.Down || roundingOnOverflow ==
                     ERounding.ZeroFiveUp ||
                        (roundingOnOverflow == ERounding.OddOrZeroFiveUp ||
                          roundingOnOverflow == ERounding.Odd) ||
                     (roundingOnOverflow == ERounding.Ceiling && neg) ||
                     (roundingOnOverflow == ERounding.Floor && !neg)))
                {
                    // Set to the highest possible value for
                    // the given precision
                    EInteger overflowMant = EInteger.Zero;
                    FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
                    overflowMant = this.TryMultiplyByRadixPower(
                      EInteger.One,
                      fastPrecision);
                    if (overflowMant == null)
                    {
                        return this.SignalInvalidWithMessage(
                          ctx,
                          "Result requires too much memory");
                    }
                    overflowMant -= EInteger.One;
                    FastInteger clamp = FastInteger.FromBig(ctx.EMax);
                    if (ctx.AdjustExponent)
                    {
                        clamp.Increment().Subtract(fastPrecision);
                    }
                    return this.helper.CreateNewWithFlags(
                      overflowMant,
                      clamp.AsEInteger(),
                      neg ? BigNumberFlags.FlagNegative : 0);
                }
            }
            return this.SignalOverflow(neg);
        }

        private T SquareRootHandleSpecial(T thisValue, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    return this.ReturnQuietNaN(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Square root of infinity
                    return ((thisFlags & BigNumberFlags.FlagNegative) != 0) ?
                      this.SignalInvalid(ctx) : thisValue;
                }
            }
            int sign = this.helper.GetSign(thisValue);
            return (sign < 0) ? this.SignalInvalid(ctx) : default(T);
        }

        private EInteger TryMultiplyByRadixPower(
          EInteger bi,
          FastInteger radixPower)
        {
            if (bi.IsZero)
            {
                return bi;
            }
            if (!radixPower.CanFitInInt32())
            {
                // NOTE: For radix 10, each digit fits less than 1 byte; the
                // supported byte length is thus less than the maximum value
                // of a 32-bit integer (2GB).
                FastInteger fastBI = FastInteger.FromBig(valueMaxDigits);
                if (this.thisRadix != 10 || radixPower.CompareTo(fastBI) > 0)
                {
                    return null;
                }
            }
            return this.helper.MultiplyByRadixPower(bi, radixPower);
        }

        private FastIntegerFixed TryMultiplyByRadixPowerFastInt(
          FastIntegerFixed bi,
          FastInteger radixPower)
        {
            if (bi.IsValueZero)
            {
                return bi;
            }
            if (!radixPower.CanFitInInt32())
            {
                // NOTE: For radix 10, each digit fits less than 1 byte; the
                // supported byte length is thus less than the maximum value
                // of a 32-bit integer (2GB).
                FastInteger fastBI = FastInteger.FromBig(valueMaxDigits);
                if (this.thisRadix != 10 || radixPower.CompareTo(fastBI) > 0)
                {
                    return null;
                }
            }
            return FastIntegerFixed.FromBig(this.helper.MultiplyByRadixPower(
              bi.ToEInteger(),
              radixPower));
        }

        private T ValueOf(int value, EContext ctx)
        {
            return (ctx == null || !ctx.HasExponentRange ||
                    ctx.ExponentWithinRange(EInteger.Zero)) ?
              this.helper.ValueOf(value) :
              this.RoundToPrecision(this.helper.ValueOf(value), ctx);
        }
    }

    // <summary>Implements the simplified arithmetic in Appendix A of the
    // General Decimal Arithmetic Specification. Unfortunately, it doesn't
    // pass all the test cases, since some aspects of the spec are left
    // open. For example: in which cases is the Clamped flag set? The test
    // cases set the Clamped flag in only a handful of test cases, all
    // within the <c>exp</c> operation.</summary>
    // <typeparam name='T'>Data type for a numeric value in a particular
    // radix.</typeparam>
    internal sealed class SimpleRadixMath<T> : IRadixMath<T>
    {
        private readonly IRadixMath<T> wrapper;

        public SimpleRadixMath(IRadixMath<T> wrapper)
        {
            this.wrapper = wrapper;
        }

        private static EContext GetContextWithFlags(EContext ctx)
        {
            return (ctx == null) ? ctx : ctx.WithBlankFlags();
        }

        private T SignalInvalid(EContext ctx)
        {
            if (this.GetHelper().GetArithmeticSupport() ==
                BigNumberFlags.FiniteOnly)
            {
                throw new ArithmeticException("Invalid operation");
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            return this.GetHelper().CreateNewWithFlags(
              EInteger.Zero,
              EInteger.Zero,
              BigNumberFlags.FlagQuietNaN);
        }

        private T PostProcess(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc)
        {
            return this.PostProcessEx(thisValue, ctxDest, ctxSrc, false, false);
        }

        private T PostProcessAfterDivision(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc)
        {
            return this.PostProcessEx(thisValue, ctxDest, ctxSrc, true, false);
        }

        private T PostProcessAfterQuantize(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc)
        {
            return this.PostProcessEx(thisValue, ctxDest, ctxSrc, false, true);
        }

        private T PostProcessEx(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc,
          bool afterDivision,
          bool afterQuantize)
        {
            int thisFlags = this.GetHelper().GetFlags(thisValue);
            if (ctxDest != null && ctxSrc != null)
            {
                if (ctxDest.HasFlags)
                {
                    if (!ctxSrc.ClampNormalExponents)
                    {
                        ctxSrc.Flags &= ~EContext.FlagClamped;
                    }
                    ctxDest.Flags |= ctxSrc.Flags;
                    if ((ctxSrc.Flags & EContext.FlagSubnormal) != 0)
                    {
                        // Treat subnormal numbers as underflows
                        ctxDest.Flags |= BigNumberFlags.UnderflowFlags;
                    }
                }
            }
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                return (ctxDest.Flags == 0) ? this.SignalInvalid(ctxDest) : thisValue;
            }
            EInteger mant = this.GetHelper().GetMantissa(thisValue).Abs();
            if (mant.IsZero)
            {
                return afterQuantize ? this.GetHelper().CreateNewWithFlags(
                  mant,
                  this.GetHelper().GetExponent(thisValue),
                  0) : this.wrapper.RoundToPrecision(
                  this.GetHelper().ValueOf(0),
                  ctxDest);
            }
            if (afterQuantize)
            {
                return thisValue;
            }
            EInteger exp = this.GetHelper().GetExponent(thisValue);
            if (exp.Sign > 0)
            {
                FastInteger fastExp = FastInteger.FromBig(exp);
                if (ctxDest == null || !ctxDest.HasMaxPrecision)
                {
                    mant = this.GetHelper().MultiplyByRadixPower(mant, fastExp);
                    return this.GetHelper().CreateNewWithFlags(
                      mant,
                      EInteger.Zero,
                      thisFlags);
                }
                if (!ctxDest.ExponentWithinRange(exp))
                {
                    return thisValue;
                }
                FastInteger prec = FastInteger.FromBig(ctxDest.Precision);
                FastInteger digits =
                  this.GetHelper().CreateShiftAccumulator(mant).GetDigitLength();
                prec.Subtract(digits);
                if (prec.Sign > 0 && prec.CompareTo(fastExp) >= 0)
                {
                    mant = this.GetHelper().MultiplyByRadixPower(mant, fastExp);
                    return this.GetHelper().CreateNewWithFlags(
                      mant,
                      EInteger.Zero,
                      thisFlags);
                }
                if (afterDivision)
                {
                    int radix = this.GetHelper().GetRadix();
                    mant = NumberUtility.ReduceTrailingZeros(
                      mant,
                      fastExp,
                      radix,
                      null,
                      null,
                      null);
                    thisValue = this.GetHelper().CreateNewWithFlags(
                      mant,
                      fastExp.AsEInteger(),
                      thisFlags);
                }
            }
            else if (afterDivision && exp.Sign < 0)
            {
                FastInteger fastExp = FastInteger.FromBig(exp);
                int radix = this.GetHelper().GetRadix();
                mant = NumberUtility.ReduceTrailingZeros(
                  mant, fastExp, radix, null, null, new FastInteger(0));
                thisValue = this.GetHelper().CreateNewWithFlags(
                  mant,
                  fastExp.AsEInteger(),
                  thisFlags);
            }
            return thisValue;
        }

        private T ReturnQuietNaN(T thisValue, EContext ctx)
        {
            EInteger mant = this.GetHelper().GetMantissa(thisValue).Abs();
            bool mantChanged = false;
            if (!mant.IsZero && ctx != null && ctx.HasMaxPrecision)
            {
                EInteger limit = this.GetHelper().MultiplyByRadixPower(
                  EInteger.One,
                  FastInteger.FromBig(ctx.Precision));
                if (mant.CompareTo(limit) >= 0)
                {
                    mant %= (EInteger)limit;
                    mantChanged = true;
                }
            }
            int flags = this.GetHelper().GetFlags(thisValue);
            if (!mantChanged && (flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return thisValue;
            }
            flags &= BigNumberFlags.FlagNegative;
            flags |= BigNumberFlags.FlagQuietNaN;
            return this.GetHelper().CreateNewWithFlags(mant, EInteger.Zero, flags);
        }

        private T HandleNotANumber(T thisValue, T other, EContext ctx)
        {
            int thisFlags = this.GetHelper().GetFlags(thisValue);
            int otherFlags = this.GetHelper().GetFlags(other);
            // Check this value then the other value for signaling NaN
            if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            // Check this value then the other value for quiet NaN
            return ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(thisValue, ctx) : (((otherFlags &
                      BigNumberFlags.FlagQuietNaN) != 0) ? this.ReturnQuietNaN(
                          other,
                          ctx) : default(T));
        }

        private T CheckNotANumber3(
          T thisValue,
          T other,
          T other2,
          EContext ctx)
        {
            int thisFlags = this.GetHelper().GetFlags(thisValue);
            int otherFlags = this.GetHelper().GetFlags(other);
            int other2Flags = this.GetHelper().GetFlags(other2);
            // Check this value then the other value for signaling NaN
            if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            if ((other2Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            // Check this value then the other value for quiet NaN
            return ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(thisValue, ctx) : (((otherFlags &
                      BigNumberFlags.FlagQuietNaN) != 0) ? this.ReturnQuietNaN(
                          other,
                          ctx) :
                          (((other2Flags & BigNumberFlags.FlagQuietNaN) !=
                      0) ? this.ReturnQuietNaN(other, ctx) : default(T)));
        }

        private T SignalingNaNInvalid(T value, EContext ctx)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            return this.ReturnQuietNaN(value, ctx);
        }

        private T CheckNotANumber1(T val, EContext ctx)
        {
            return this.HandleNotANumber(val, val, ctx);
        }

        private T CheckNotANumber2(T val, T val2, EContext ctx)
        {
            return this.HandleNotANumber(val, val2, ctx);
        }

        private T RoundBeforeOp(T val, EContext ctx)
        {
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return val;
            }
            int thisFlags = this.GetHelper().GetFlags(val);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                return val;
            }
            FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
            EInteger mant = this.GetHelper().GetMantissa(val).Abs();
            FastInteger digits =
              this.GetHelper().CreateShiftAccumulator(mant).GetDigitLength();
            EContext ctx2 = ctx.WithBlankFlags().WithTraps(0);
            if (digits.CompareTo(fastPrecision) <= 0)
            {
                // Rounding is only to be done if the digit count is
                // too big (distinguishing this case is material
                // if the value also has an exponent that's out of range)
                return val;
            }
            val = this.wrapper.RoundToPrecision(val, ctx2);
            // the only time rounding can signal an invalid
            // operation is if an operand is signaling NaN, but
            // this was already checked beforehand
#if DEBUG
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                throw new
                  ArgumentException("doesn't satisfy (ctx2.Flags&FlagInvalid)==0");
            }
#endif
            if ((ctx2.Flags & EContext.FlagInexact) != 0)
            {
                if (ctx.HasFlags)
                {
                    ctx.Flags |= BigNumberFlags.LostDigitsFlags;
                }
            }
            if ((ctx2.Flags & EContext.FlagRounded) != 0)
            {
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagRounded;
                }
            }
            if ((ctx2.Flags & EContext.FlagSubnormal) != 0)
            {
                // Console.WriteLine("Subnormal input: " + val);
            }
            if ((ctx2.Flags & EContext.FlagUnderflow) != 0)
            {
                // Console.WriteLine("Underflow");
            }
            if ((ctx2.Flags & EContext.FlagOverflow) != 0)
            {
                bool neg = (thisFlags & BigNumberFlags.FlagNegative) != 0;
                ctx.Flags |= EContext.FlagLostDigits;
                return this.SignalOverflow2(ctx, neg);
            }
            return val;
        }

        public T DivideToIntegerNaturalScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            divisor = this.RoundBeforeOp(divisor, ctx2);
            thisValue = this.wrapper.DivideToIntegerNaturalScale(
              thisValue,
              divisor,
              ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        public T DivideToIntegerZeroScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            divisor = this.RoundBeforeOp(divisor, ctx2);
            thisValue = this.wrapper.DivideToIntegerZeroScale(
              thisValue,
              divisor,
              ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        public T Abs(T value, EContext ctx)
        {
            T ret = this.CheckNotANumber1(value, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            value = this.RoundBeforeOp(value, ctx2);
            value = this.wrapper.Abs(value, ctx2);
            return this.PostProcess(value, ctx, ctx2);
        }

        public T Negate(T value, EContext ctx)
        {
            T ret = this.CheckNotANumber1(value, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            value = this.RoundBeforeOp(value, ctx2);
            value = this.wrapper.Negate(value, ctx2);
            return this.PostProcess(value, ctx, ctx2);
        }

        // <summary>Finds the remainder that results when dividing two T
        // objects.</summary>
        // <param name='thisValue'></param>
        // <summary>Finds the remainder that results when dividing two T
        // objects.</summary>
        // <param name='thisValue'></param>
        // <param name='divisor'></param>
        // <param name='ctx'> (3).</param>
        // <returns>The remainder of the two objects.</returns>
        public T Remainder(
      T thisValue,
      T divisor,
      EContext ctx,
      bool roundAfterDivide)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            divisor = this.RoundBeforeOp(divisor, ctx2);
            thisValue = this.wrapper.Remainder(
              thisValue,
              divisor,
              ctx2,
              roundAfterDivide);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            divisor = this.RoundBeforeOp(divisor, ctx2);
            thisValue = this.wrapper.RemainderNear(thisValue, divisor, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T Pi(EContext ctx)
        {
            return this.wrapper.Pi(ctx);
        }

        private T SignalOverflow2(EContext pc, bool neg)
        {
            if (pc != null)
            {
                ERounding roundingOnOverflow = pc.Rounding;
                if (pc.HasFlags)
                {
                    pc.Flags |= EContext.FlagOverflow |
                      EContext.FlagInexact | EContext.FlagRounded;
                }
                if (pc.HasMaxPrecision && pc.HasExponentRange &&
                    (roundingOnOverflow == ERounding.Down || roundingOnOverflow ==
                     ERounding.ZeroFiveUp ||
                     (roundingOnOverflow == ERounding.OddOrZeroFiveUp) ||
                     (roundingOnOverflow == ERounding.Odd) ||
                     (roundingOnOverflow == ERounding.Ceiling && neg) ||
                     (roundingOnOverflow == ERounding.Floor && !neg)))
                {
                    // Set to the highest possible value for
                    // the given precision
                    EInteger overflowMant = EInteger.Zero;
                    FastInteger fastPrecision = FastInteger.FromBig(pc.Precision);
                    overflowMant = this.GetHelper().MultiplyByRadixPower(
                      EInteger.One,
                      fastPrecision);
                    overflowMant -= EInteger.One;
                    FastInteger clamp =
                      FastInteger.FromBig(pc.EMax).Increment().Subtract(fastPrecision);
                    return this.GetHelper().CreateNewWithFlags(
                      overflowMant,
                      clamp.AsEInteger(),
                      neg ? BigNumberFlags.FlagNegative : 0);
                }
            }
            return this.GetHelper().GetArithmeticSupport() ==
              BigNumberFlags.FiniteOnly ?
              default(T) : this.GetHelper().CreateNewWithFlags(
                EInteger.Zero,
                EInteger.Zero,
                (neg ? BigNumberFlags.FlagNegative : 0) | BigNumberFlags.FlagInfinity);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, pow, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            // Console.WriteLine("op was " + thisValue + ", "+pow);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            pow = this.RoundBeforeOp(pow, ctx2);
            // Console.WriteLine("op now " + thisValue + ", "+pow);
            int powSign = this.GetHelper().GetSign(pow);
            thisValue = (powSign == 0 && this.GetHelper().GetSign(thisValue) == 0) ?
              this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(1), ctx2) :
              this.wrapper.Power(thisValue, pow, ctx2);
            // Console.WriteLine("was " + thisValue);
            thisValue = this.PostProcessAfterDivision(thisValue, ctx, ctx2);
            // Console.WriteLine("result was " + thisValue);
            // Console.WriteLine("now " + thisValue);
            return thisValue;
        }

        public T Log10(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.Log10(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T Ln(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            // Console.WriteLine("was: " + thisValue);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            // Console.WriteLine("now: " + thisValue);
            thisValue = this.wrapper.Ln(thisValue, ctx2);
            // Console.WriteLine("result: " + thisValue);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public IRadixMathHelper<T> GetHelper()
        {
            return this.wrapper.GetHelper();
        }

        public T Exp(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.Exp(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            // Console.WriteLine("op was " + thisValue);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            // Console.WriteLine("op now " + thisValue);
            thisValue = this.wrapper.SquareRoot(thisValue, ctx2);
            // Console.WriteLine("result was " + thisValue);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.NextMinus(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, otherValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            otherValue = this.RoundBeforeOp(otherValue, ctx2);
            thisValue = this.wrapper.NextToward(thisValue, otherValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.NextPlus(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T DivideToExponent(
          T thisValue,
          T divisor,
          EInteger desiredExponent,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            divisor = this.RoundBeforeOp(divisor, ctx2);
            thisValue = this.wrapper.DivideToExponent(
              thisValue,
              divisor,
              desiredExponent,
              ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        // <summary>Divides two T objects.</summary>
        // <param name='thisValue'></param>
        // <summary>Divides two T objects.</summary>
        // <param name='thisValue'></param>
        // <param name='divisor'></param>
        // <param name='ctx'> (3).</param>
        // <returns>The quotient of the two objects.</returns>
        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            divisor = this.RoundBeforeOp(divisor, ctx2);
            thisValue = this.wrapper.Divide(thisValue, divisor, ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.RoundBeforeOp(a, ctx2);
            b = this.RoundBeforeOp(b, ctx2);
            a = this.wrapper.MinMagnitude(a, b, ctx2);
            return this.PostProcess(a, ctx, ctx2);
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.RoundBeforeOp(a, ctx2);
            b = this.RoundBeforeOp(b, ctx2);
            a = this.wrapper.MaxMagnitude(a, b, ctx2);
            return this.PostProcess(a, ctx, ctx2);
        }

        public T Max(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.RoundBeforeOp(a, ctx2);
            b = this.RoundBeforeOp(b, ctx2);
            // choose the left operand if both are equal
            a = (this.CompareTo(a, b) >= 0) ? a : b;
            return this.PostProcess(a, ctx, ctx2);
        }

        public T Min(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.RoundBeforeOp(a, ctx2);
            b = this.RoundBeforeOp(b, ctx2);
            // choose the left operand if both are equal
            a = (this.CompareTo(a, b) <= 0) ? a : b;
            return this.PostProcess(a, ctx, ctx2);
        }

        // <summary>Multiplies two T objects.</summary>
        // <param name='thisValue'></param>
        // <summary>Multiplies two T objects.</summary>
        // <param name='thisValue'></param>
        // <param name='other'></param>
        // <param name='ctx'> (3).</param>
        // <returns>The product of the two objects.</returns>
        public T Multiply(T thisValue, T other, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, other, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            other = this.RoundBeforeOp(other, ctx2);
            thisValue = this.wrapper.Multiply(thisValue, other, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T MultiplyAndAdd(
          T thisValue,
          T multiplicand,
          T augend,
          EContext ctx)
        {
            T ret = this.CheckNotANumber3(thisValue, multiplicand, augend, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            multiplicand = this.RoundBeforeOp(multiplicand, ctx2);
            augend = this.RoundBeforeOp(augend, ctx2);
            // the only time the first operand to the addition can be
            // 0 is if either thisValue rounded or multiplicand
            // rounded is 0
            bool zeroA = this.GetHelper().GetSign(thisValue) == 0 ||
              this.GetHelper().GetSign(multiplicand) == 0;
            bool zeroB = this.GetHelper().GetSign(augend) == 0;
            if (zeroA)
            {
                thisValue = zeroB ?
                  this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(0), ctx2) :
                  augend;
                thisValue = this.RoundToPrecision(thisValue, ctx2);
            }
            else
            {
                thisValue = !zeroB ? this.wrapper.MultiplyAndAdd(
          thisValue,
          multiplicand,
          augend,
          ctx2) : this.wrapper.Multiply(thisValue, multiplicand, ctx2);
            }
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T Plus(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.Plus(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T RoundToPrecision(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.RoundToPrecision(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            // Console.WriteLine("was: "+thisValue+", "+otherValue);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            // Console.WriteLine("now: "+thisValue+", "+otherValue);
            otherValue = this.RoundBeforeOp(otherValue, ctx2);
            // Apparently, subnormal values of "otherValue" raise
            // an invalid operation flag, according to the test cases
            EContext ctx3 = ctx2?.WithBlankFlags();
            this.wrapper.RoundToPrecision(otherValue, ctx3);
            if (ctx3 != null && (ctx3.Flags & EContext.FlagSubnormal) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            thisValue = this.wrapper.Quantize(thisValue, otherValue, ctx2);
            // Console.WriteLine("result: "+thisValue);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T RoundToExponentExact(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.RoundToExponentExact(thisValue, expOther, ctx);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T RoundToExponentSimple(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.RoundToExponentSimple(thisValue, expOther, ctx2);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T RoundToExponentNoRoundedFlag(
          T thisValue,
          EInteger exponent,
          EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.RoundToExponentNoRoundedFlag(
              thisValue,
              exponent,
              ctx);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            thisValue = this.wrapper.Reduce(thisValue, ctx);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, other, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.RoundBeforeOp(thisValue, ctx2);
            other = this.RoundBeforeOp(other, ctx2);
            bool zeroA = this.GetHelper().GetSign(thisValue) == 0;
            bool zeroB = this.GetHelper().GetSign(other) == 0;
            if (zeroA)
            {
                thisValue = zeroB ?
                  this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(0), ctx2) :
                  other;
                thisValue = this.RoundToPrecision(thisValue, ctx2);
            }
            else
            {
                thisValue = (!zeroB) ? this.wrapper.AddEx(
                  thisValue,
                  other,
                  ctx2,
                  true) :
                  this.RoundToPrecision(thisValue, ctx2);
            }
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T AddEx(
          T thisValue,
          T other,
          EContext ctx,
          bool roundToOperandPrecision)
        {
            // NOTE: Ignores roundToOperandPrecision
            return this.Add(thisValue, other, ctx);
        }

        // <summary>Compares a T object with this instance.</summary>
        // <param name='thisValue'></param>
        // <param name='otherValue'>A T object.</param>
        // <param name='treatQuietNansAsSignaling'>A Boolean object.</param>
        // <param name='ctx'>A PrecisionContext object.</param>
        // <returns>Zero if the values are equal; a negative number if this
        // instance is less, or a positive number if this instance is
        // greater.</returns>
        public T CompareToWithContext(
          T thisValue,
          T otherValue,
          bool treatQuietNansAsSignaling,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, otherValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            thisValue = this.RoundBeforeOp(thisValue, ctx);
            otherValue = this.RoundBeforeOp(otherValue, ctx);
            return this.wrapper.CompareToWithContext(
              thisValue,
              otherValue,
              treatQuietNansAsSignaling,
              ctx);
        }

        // <summary>Compares a T object with this instance.</summary>
        // <param name='thisValue'></param>
        // <returns>Zero if the values are equal; a negative number if this
        // instance is less, or a positive number if this instance is
        // greater.</returns>
        public int CompareTo(T thisValue, T otherValue)
        {
            return this.wrapper.CompareTo(thisValue, otherValue);
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            if (this.GetHelper().GetSign(thisValue) == 0)
            {
                return this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(0), ctx);
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.wrapper.RoundToPrecision(thisValue, ctx2);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }
    }

    // <summary>Implements arithmetic methods that support
    // traps.</summary>
    // <typeparam name='T'>Data type for a numeric value in a particular
    // radix.</typeparam>
    internal class TrappableRadixMath<T> : IRadixMath<T>
    {
        private static void ThrowTrapException(
        int flag,
        EContext ctx,
        object result)
        {
            throw new ETrapException(flag, ctx, result);
        }

        private static EContext GetTrappableContext(EContext ctx)
        {
            return (ctx == null) ? null : ((ctx.Traps == 0) ? ctx :
            ctx.WithBlankFlags());
        }

        private T TriggerTraps(
      T result,
      EContext src,
      EContext dst)
        {
            if (src == null || src.Flags == 0)
            {
                return result;
            }
            if (dst != null && dst.HasFlags)
            {
                dst.Flags |= src.Flags;
            }
            int traps = (dst != null) ? dst.Traps : 0;
            traps &= src.Flags;
            if (traps == 0)
            {
                return result;
            }
            int mutexConditions = traps & (~(
              EContext.FlagClamped | EContext.FlagInexact | EContext.FlagRounded | EContext.FlagSubnormal));
            if (mutexConditions != 0)
            {
                for (int i = 0; i < 32; ++i)
                {
                    int flag = mutexConditions & (i << 1);
                    if (flag != 0)
                    {
                        ThrowTrapException(flag, dst, result);
                    }
                }
            }
            if ((traps & EContext.FlagSubnormal) != 0)
            {
                ThrowTrapException(
          traps & EContext.FlagSubnormal,
          dst,
          result);
            }
            if ((traps & EContext.FlagInexact) != 0)
            {
                ThrowTrapException(
          traps & EContext.FlagInexact,
          dst,
          result);
            }
            if ((traps & EContext.FlagRounded) != 0)
            {
                ThrowTrapException(
          traps & EContext.FlagRounded,
          dst,
          result);
            }
            if ((traps & EContext.FlagClamped) != 0)
            {
                ThrowTrapException(
          traps & EContext.FlagClamped,
          dst,
          result);
            }
            return result;
        }

        private readonly IRadixMath<T> math;

        public TrappableRadixMath(IRadixMath<T> math)
        {

#if DEBUG
#endif
            this.math = math ?? throw new ArgumentNullException(nameof(math));
        }

        public T DivideToIntegerNaturalScale(
      T thisValue,
      T divisor,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.DivideToIntegerNaturalScale(
        thisValue,
        divisor,
        tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T DivideToIntegerZeroScale(
      T thisValue,
      T divisor,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.DivideToIntegerZeroScale(thisValue, divisor, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Abs(T value, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Abs(value, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Negate(T value, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Negate(value, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Remainder(
      T thisValue,
      T divisor,
      EContext ctx,
      bool roundAfterDivide)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Remainder(
          thisValue,
          divisor,
          tctx,
          roundAfterDivide);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public IRadixMathHelper<T> GetHelper()
        {
            return this.math.GetHelper();
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.RemainderNear(thisValue, divisor, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Pi(EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Pi(tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Power(thisValue, pow, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Log10(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Log10(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Ln(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Ln(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Exp(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Exp(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.SquareRoot(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.NextMinus(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.NextToward(thisValue, otherValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.NextPlus(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T DivideToExponent(
      T thisValue,
      T divisor,
      EInteger desiredExponent,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.DivideToExponent(
        thisValue,
        divisor,
        desiredExponent,
        tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Divide(thisValue, divisor, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.MinMagnitude(a, b, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.MaxMagnitude(a, b, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Max(T a, T b, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Max(a, b, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Min(T a, T b, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Min(a, b, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Multiply(T thisValue, T other, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Multiply(thisValue, other, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T MultiplyAndAdd(
      T thisValue,
      T multiplicand,
      T augend,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.MultiplyAndAdd(
        thisValue,
        multiplicand,
        augend,
        tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Plus(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Plus(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T RoundToPrecision(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.RoundToPrecision(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Quantize(thisValue, otherValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T RoundToExponentExact(
      T thisValue,
      EInteger expOther,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.RoundToExponentExact(thisValue, expOther, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T RoundToExponentSimple(
      T thisValue,
      EInteger expOther,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.RoundToExponentSimple(thisValue, expOther, ctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T RoundToExponentNoRoundedFlag(
      T thisValue,
      EInteger exponent,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.RoundToExponentNoRoundedFlag(
        thisValue,
        exponent,
        ctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Reduce(thisValue, ctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.Add(thisValue, other, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        // <summary>Compares a T object with this instance.</summary>
        // <param name='thisValue'></param>
        // <param name='otherValue'>A T object.</param>
        // <param name='treatQuietNansAsSignaling'>A Boolean object.</param>
        // <param name='ctx'>A PrecisionContext object.</param>
        // <returns>Zero if the values are equal; a negative number if this
        // instance is less, or a positive number if this instance is
        // greater.</returns>
        public T CompareToWithContext(
      T thisValue,
      T otherValue,
      bool treatQuietNansAsSignaling,
      EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.CompareToWithContext(
              thisValue,
              otherValue,
              treatQuietNansAsSignaling,
              tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        // <summary>Compares a T object with this instance.</summary>
        // <param name='thisValue'></param>
        // <returns>Zero if the values are equal; a negative number if this
        // instance is less, or a positive number if this instance is
        // greater.</returns>
        public int CompareTo(T thisValue, T otherValue)
        {
            return this.math.CompareTo(thisValue, otherValue);
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.RoundAfterConversion(thisValue, tctx);
            return this.TriggerTraps(result, tctx, ctx);
        }

        public T AddEx(
        T thisValue,
        T other,
        EContext ctx,
        bool roundToOperandPrecision)
        {
            EContext tctx = GetTrappableContext(ctx);
            T result = this.math.AddEx(
        thisValue,
        other,
        ctx,
        roundToOperandPrecision);
            return this.TriggerTraps(result, tctx, ctx);
        }
    }

}
